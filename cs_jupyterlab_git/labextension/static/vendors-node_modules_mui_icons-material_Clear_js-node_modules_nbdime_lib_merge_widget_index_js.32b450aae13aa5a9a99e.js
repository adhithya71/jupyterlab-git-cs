(self["webpackChunk_cs_jupyterlab_git"] = self["webpackChunk_cs_jupyterlab_git"] || []).push([["vendors-node_modules_mui_icons-material_Clear_js-node_modules_nbdime_lib_merge_widget_index_js"],{

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ ((module) => {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@mui/icons-material/Clear.js":
/*!***************************************************!*\
  !*** ./node_modules/@mui/icons-material/Clear.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

"use client";

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@mui/icons-material/utils/createSvgIcon.js"));
var _jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
var _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), 'Clear');
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/@mui/icons-material/utils/createSvgIcon.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@mui/icons-material/utils/createSvgIcon.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

'use client';

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _utils.createSvgIcon;
  }
}));
var _utils = __webpack_require__(/*! @mui/material/utils */ "./node_modules/@mui/material/utils/index.js");

/***/ }),

/***/ "./node_modules/json-stable-stringify/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/json-stable-stringify/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(/*! jsonify */ "./node_modules/jsonify/index.js");

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};


/***/ }),

/***/ "./node_modules/jsonify/index.js":
/*!***************************************!*\
  !*** ./node_modules/jsonify/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.parse = __webpack_require__(/*! ./lib/parse */ "./node_modules/jsonify/lib/parse.js");
exports.stringify = __webpack_require__(/*! ./lib/stringify */ "./node_modules/jsonify/lib/stringify.js");


/***/ }),

/***/ "./node_modules/jsonify/lib/parse.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonify/lib/parse.js ***!
  \*******************************************/
/***/ ((module) => {

var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};


/***/ }),

/***/ "./node_modules/jsonify/lib/stringify.js":
/*!***********************************************!*\
  !*** ./node_modules/jsonify/lib/stringify.js ***!
  \***********************************************/
/***/ ((module) => {

var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};


/***/ }),

/***/ "./node_modules/nbdime/lib/chunking/decisionchunking.js":
/*!**************************************************************!*\
  !*** ./node_modules/nbdime/lib/chunking/decisionchunking.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   splitMergeDecisionsOnChunks: () => (/* binding */ splitMergeDecisionsOnChunks)
/* harmony export */ });
/* harmony import */ var _diff_diffentries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../diff/diffentries */ "./node_modules/nbdime/lib/diff/diffentries.js");
/* harmony import */ var _merge_decisions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../merge/decisions */ "./node_modules/nbdime/lib/merge/decisions.js");
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");



function anyDiffs(diffs) {
    for (let d of diffs) {
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_2__.hasEntries)(d)) {
            return true;
        }
    }
    return false;
}
function getSectionBoundaries(diffs) {
    let boundaries = [];
    for (let e of diffs) {
        let j = e.key;
        let k;
        boundaries.push(j);
        if (e.op === 'addrange') {
            // Pass
        }
        else if (e.op === 'removerange') {
            k = j + e.length;
            boundaries.push(k);
        }
        else if (e.op === 'patch') {
            k = j + 1;
            boundaries.push(k);
        }
    }
    return boundaries.filter(_common_util__WEBPACK_IMPORTED_MODULE_2__.unique);
}
function splitDiffsOnBoundaries(diffs, boundaries) {
    let newdiffs = [];
    if (!Array.isArray(boundaries)) {
        throw new Error();
    }
    // Next relevant boundary index
    let b = 0;
    for (let e of diffs) {
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_2__.valueIn)(e.op, ['addrange', 'patch'])) {
            // Nothing to split
            newdiffs.push(e);
        }
        else if (e.op === 'removerange') {
            // Skip boundaries smaller than key
            while (boundaries[b] < e.key) {
                b += 1;
            }
            // key should be included in the boundaries
            if (boundaries[b] !== e.key) {
                throw new Error();
            }
            // Add diff entries for each interval between boundaries up to k
            while (b < boundaries.length - 1 &&
                boundaries[b + 1] <= e.key + e.length) {
                newdiffs.push((0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opRemoveRange)(boundaries[b], boundaries[b + 1] - boundaries[b]));
                b += 1;
            }
        }
        else {
            throw new Error('Unhandled diff entry op ' + e.op);
        }
    }
    return newdiffs;
}
/**
 * Make list of chunks on the form (j, k, diffs0, diffs1, ..., diffsN),
 * where `j` and `k` are line numbers in the base, and the `diffsX`
 * entries are subsets from `diffs` that are part of the chunk.
 *
 * Because the diff entries have been split on the union of
 * begin/end boundaries of all diff entries, the keys of
 * diff entries on each side will always match a boundary
 * exactly. The only situation where multiple diff entries
 * on one side matches a boundary is when add/remove or
 * add/patch pairs occur, i.e. when inserting something
 * just before an item that is removed or modified.
 */
function makeChunks(boundaries, diffs) {
    let iDiffs = Array.apply(null, Array(diffs.length)).map(Number.prototype.valueOf, 0);
    let chunks = [];
    for (let i = 0; i < boundaries.length; ++i) {
        // Find span of next chunk
        let j = boundaries[i];
        let k = i < boundaries.length - 1 ? boundaries[i + 1] : j;
        // Collect diff entries from each side
        // starting at beginning of this chunk
        let subDiffs = [];
        for (let m = 0; m < diffs.length; ++m) {
            let d = diffs[m];
            let dis = [];
            while (d && iDiffs[m] < d.length && d[iDiffs[m]].key === j) {
                dis.push(d[iDiffs[m]]);
                iDiffs[m] += 1;
            }
            subDiffs.push(dis);
        }
        // Add non-empty chunks
        if (anyDiffs(subDiffs)) {
            let c = { baseStart: j, baseEnd: k, diffs: subDiffs };
            chunks.push(c);
        }
    }
    return chunks;
}
/**
 * Return list of chunks (i, j, d0, d1, ..., dn) where dX are
 *  lists of diff entries affecting the range base[i:j].
 *
 *  If d0 and d1 are both empty the chunk is not modified.
 *
 *  Includes full range 0:len(base).
 *
 *  Each diff list contains either 0, 1, or 2 entries,
 *  in case of 2 entries the first will be an insert
 *  at i (the beginning of the range) and the other a
 *  removerange or patch covering the full range i:j.
 */
function makeMergeChunks(base, diffs) {
    // Split diffs on union of diff entry boundaries such that
    // no diff entry overlaps with more than one other entry.
    // Including 0,N makes loop over chunks cleaner.
    let boundaries = [0, base.length];
    for (let d of diffs) {
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_2__.hasEntries)(d)) {
            let newBoundaries = getSectionBoundaries(d);
            boundaries = boundaries.concat(newBoundaries);
        }
    }
    boundaries = boundaries.filter(_common_util__WEBPACK_IMPORTED_MODULE_2__.unique).sort();
    let splitDiffs = [];
    for (let d of diffs) {
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_2__.hasEntries)(d)) {
            splitDiffs.push(splitDiffsOnBoundaries(d, boundaries));
        }
        else {
            splitDiffs.push(d);
        }
    }
    // Make list of chunks on the form (j, k, diffs)
    let chunks = makeChunks(boundaries, splitDiffs);
    return chunks;
}
function splitDecisionByChunks(base, decision, chunks) {
    if (chunks.length < 2) {
        return [decision];
    }
    let out = [];
    for (let c of chunks) {
        let cd = decision.customDiff;
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_2__.hasEntries)(cd)) {
            if (decision.localPath.length > 0) {
                cd = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_1__.pushPath)(cd, decision.localPath);
            }
            // Split custom diff according to chunk lines
            let boundaries = [0, base.length, c.baseStart, c.baseEnd]
                .filter(_common_util__WEBPACK_IMPORTED_MODULE_2__.unique)
                .sort();
            cd = splitDiffsOnBoundaries(cd, boundaries);
        }
        out.push(new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(decision.absolutePath.slice(), c.diffs[0], c.diffs[1], decision.action, decision.conflict));
    }
    return out;
}
function splitMergeDecisionsOnChunks(base, decisions) {
    let out = [];
    for (let md of decisions) {
        let diffs = [
            (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_1__.buildDiffs)(base, [md], 'local'),
            (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_1__.buildDiffs)(base, [md], 'remote'),
        ];
        let chunks = makeMergeChunks(base, diffs);
        out = out.concat(splitDecisionByChunks(base, md, chunks));
    }
    return out;
}


/***/ }),

/***/ "./node_modules/nbdime/lib/chunking/diffchunking.js":
/*!**********************************************************!*\
  !*** ./node_modules/nbdime/lib/chunking/diffchunking.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Chunk: () => (/* binding */ Chunk),
/* harmony export */   Chunker: () => (/* binding */ Chunker),
/* harmony export */   LineChunker: () => (/* binding */ LineChunker),
/* harmony export */   labelSource: () => (/* binding */ labelSource),
/* harmony export */   lineToNormalChunks: () => (/* binding */ lineToNormalChunks)
/* harmony export */ });
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * A chunk is a range of lines in a string based diff
 * that logically belong together.
 *
 * Chunks can be used for:
 *  - Correlating diff entries in the base and remote, e.g.
 *    for aligning lines in two editors.
 *  - Finding parts of the unchanged text that are not needed
 *    as context (can be hidden)
 *  - Navigating a diff ("Go to next diff")
 */
class Chunk {
    constructor(baseFrom, baseTo, remoteFrom, remoteTo, source) {
        this.baseFrom = baseFrom;
        this.baseTo = baseTo;
        this.remoteFrom = remoteFrom;
        this.remoteTo = remoteTo;
        this.sources = source ? [source] : [];
    }
    /**
     * Checks whether the given line number is within the range spanned by editFrom - editTo
     */
    inEdit(line) {
        return line >= this.baseFrom && line <= this.baseTo;
    }
    /**
     * Checks whether the given line number is within the range spanned by origFrom - origTo
     */
    inOrig(line) {
        return line >= this.remoteFrom && line <= this.remoteTo;
    }
}
class Chunker {
    constructor() {
        this._currentGhost = null;
        this.chunks = [];
        this.editOffset = 0;
    }
    _getCurrent() {
        if (this._currentGhost) {
            this._currentGhost = null;
            return null;
        }
        return this.chunks.length > 0 ? this.chunks[this.chunks.length - 1] : null;
    }
    _overlapChunk(chunk, range, isAddition) {
        if (isAddition) {
            return chunk.inOrig(range.from.line);
        }
        else {
            return chunk.inEdit(range.from.line);
        }
    }
    addDiff(range, isAddition) {
        let linediff = range.to.line - range.from.line;
        if (range.endsOnNewline) {
            linediff += 1;
        }
        const firstLineNew = range.from.column === 0 && linediff > 0;
        const startOffset = range.chunkStartLine ? 0 : 1;
        const endOffset = range.chunkStartLine && range.endsOnNewline && firstLineNew ? 0 : 1;
        let current = this._getCurrent();
        if (current) {
            // Have existing chunk, check for overlap
            if (isAddition) {
                if (this._overlapChunk(current, range, isAddition)) {
                    current.remoteTo = Math.max(current.remoteTo, range.from.line + endOffset + linediff);
                    current.baseTo = Math.max(current.baseTo, range.from.line + endOffset + this.editOffset);
                    if (range.source && !(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(range.source, current.sources)) {
                        current.sources.push(range.source);
                    }
                }
                else {
                    // No overlap with chunk, start new one
                    current = null;
                }
            }
            else {
                if (this._overlapChunk(current, range, isAddition)) {
                    current.remoteTo = Math.max(current.remoteTo, range.from.line + endOffset - this.editOffset);
                    current.baseTo = Math.max(current.baseTo, range.from.line + endOffset + linediff);
                    if (range.source && !(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(range.source, current.sources)) {
                        current.sources.push(range.source);
                    }
                }
                else {
                    // No overlap with chunk, start new one
                    current = null;
                }
            }
        }
        if (!current) {
            // No current chunk, start a new one
            if (isAddition) {
                let startRemote = range.from.line;
                let startBase = startRemote + this.editOffset;
                current = new Chunk(startBase + startOffset, startBase + endOffset, startRemote + startOffset, startRemote + endOffset + linediff);
            }
            else {
                let startBase = range.from.line;
                let startRemote = startBase - this.editOffset;
                current = new Chunk(startBase + startOffset, startBase + endOffset + linediff, startRemote + startOffset, startRemote + endOffset);
            }
            if (range.source) {
                current.sources.push(range.source);
            }
            this.chunks.push(current);
        }
        current.sources = current.sources.filter(_common_util__WEBPACK_IMPORTED_MODULE_0__.unique);
        this.editOffset += isAddition ? -linediff : linediff;
    }
    /**
     * Chunk a region where changes will occur if a currently unapplied diff were
     * applied.
     */
    addGhost(range, isAddition, offset) {
        // Do a one-to-one chunk as base
        let linediff = range.to.line - range.from.line;
        if (range.endsOnNewline) {
            linediff += 1;
        }
        let firstLineNew = range.from.column === 0 && linediff > 0;
        let startOffset = range.chunkStartLine ? 0 : 1;
        let endOffset = range.chunkStartLine && range.endsOnNewline && firstLineNew ? 0 : 1;
        if (!isAddition) {
            endOffset += linediff;
        }
        let current = this._currentGhost;
        // Subtract offset from other editor
        let startEdit = range.from.line + (isAddition ? offset : 0);
        if (current) {
            // Have existing chunk, check for overlap
            let startOrig = startEdit - this.editOffset;
            if (current.baseTo > startEdit) {
                current.remoteTo = Math.max(current.remoteTo, startOrig + endOffset);
                current.baseTo = Math.max(current.baseTo, startEdit + endOffset);
                if (range.source && !(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(range.source, current.sources)) {
                    current.sources.push(range.source);
                }
            }
            else {
                // No overlap with chunk, start new one
                current = null;
            }
        }
        if (!current) {
            let startOrig = startEdit - this.editOffset;
            current = new Chunk(startEdit + startOffset, startEdit + endOffset, startOrig + startOffset, startOrig + endOffset);
            if (range.source) {
                current.sources.push(range.source);
            }
            this.chunks.push(current);
        }
        this._currentGhost = current;
        current.sources = current.sources.filter(_common_util__WEBPACK_IMPORTED_MODULE_0__.unique);
        // this._doAdd(range, isAddition);
    }
}
/**
 * A chunker that only chunks diffs within lines with each other
 *
 * While the default chunker would chunk together a change at the end of one
 * line with a change at the start of the next line, this chunker will keep
 * each line separate. This is useful e.g. for merging.
 */
class LineChunker extends Chunker {
    _overlapChunk(chunk, range, isAddition) {
        let fromLine = range.from.line;
        if (chunk.baseFrom !== chunk.baseTo || chunk.remoteFrom >= chunk.remoteTo) {
            // Ensure aligned addition/removal on same line
            // still chunk together
            fromLine += 1;
        }
        if (isAddition) {
            return chunk.inOrig(fromLine);
        }
        else {
            return chunk.inEdit(fromLine);
        }
    }
}
/**
 * Transform an array of lines to normal chunks
 */
function lineToNormalChunks(lineChunks) {
    // We already have line chunks, so simply merge those chunks that overlap
    let current = null;
    let ret = [];
    for (let c of lineChunks) {
        if (current === null) {
            current = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.shallowCopy)(c);
        }
        else {
            if (current.inEdit(c.baseFrom)) {
                // Overlaps, combine
                current.remoteTo = Math.max(current.remoteTo, c.remoteTo);
                current.baseTo = Math.max(current.baseTo, c.baseTo);
                current.sources = current.sources.concat(c.sources);
            }
            else {
                // No overlap, start new
                ret.push(current);
                current = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.shallowCopy)(c);
            }
        }
        current.sources = current.sources.filter(_common_util__WEBPACK_IMPORTED_MODULE_0__.unique);
    }
    if (current !== null) {
        ret.push(current);
    }
    return ret;
}
/**
 * Label a set of diffs with a source, recursively.
 */
function labelSource(diff, source) {
    if (diff) {
        for (let d of diff) {
            d.source = source;
            if (d.op === 'patch') {
                labelSource(d.diff, source);
            }
        }
    }
    return diff;
}


/***/ }),

/***/ "./node_modules/nbdime/lib/chunking/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nbdime/lib/chunking/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Chunk: () => (/* reexport safe */ _diffchunking__WEBPACK_IMPORTED_MODULE_0__.Chunk),
/* harmony export */   Chunker: () => (/* reexport safe */ _diffchunking__WEBPACK_IMPORTED_MODULE_0__.Chunker),
/* harmony export */   LineChunker: () => (/* reexport safe */ _diffchunking__WEBPACK_IMPORTED_MODULE_0__.LineChunker),
/* harmony export */   labelSource: () => (/* reexport safe */ _diffchunking__WEBPACK_IMPORTED_MODULE_0__.labelSource),
/* harmony export */   lineToNormalChunks: () => (/* reexport safe */ _diffchunking__WEBPACK_IMPORTED_MODULE_0__.lineToNormalChunks),
/* harmony export */   splitMergeDecisionsOnChunks: () => (/* reexport safe */ _decisionchunking__WEBPACK_IMPORTED_MODULE_1__.splitMergeDecisionsOnChunks)
/* harmony export */ });
/* harmony import */ var _diffchunking__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diffchunking */ "./node_modules/nbdime/lib/chunking/diffchunking.js");
/* harmony import */ var _decisionchunking__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decisionchunking */ "./node_modules/nbdime/lib/chunking/decisionchunking.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/***/ }),

/***/ "./node_modules/nbdime/lib/common/basepanel.js":
/*!*****************************************************!*\
  !*** ./node_modules/nbdime/lib/common/basepanel.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DiffPanel: () => (/* binding */ DiffPanel),
/* harmony export */   MergePanel: () => (/* binding */ MergePanel)
/* harmony export */ });
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * Common panel for diff views
 */
class DiffPanel extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Panel {
    constructor({ model, editorFactory, translator, ...viewOptions }) {
        super();
        this._editorFactory = editorFactory;
        this._model = model;
        this._translator = translator ?? _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator;
        this._viewOptions = viewOptions;
    }
}
/**
 * Common panel for merge views
 */
class MergePanel extends DiffPanel {
}


/***/ }),

/***/ "./node_modules/nbdime/lib/common/collapsiblepanel.js":
/*!************************************************************!*\
  !*** ./node_modules/nbdime/lib/common/collapsiblepanel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CollapsiblePanel: () => (/* binding */ CollapsiblePanel)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


const COLLAPSIBLE_CLASS = 'jp-CollapsiblePanel';
const COLLAPSIBLE_HEADER = 'jp-CollapsiblePanel-header';
const COLLAPSIBLE_HEADER_ICON = 'jp-CollapsiblePanel-header-icon';
const COLLAPSIBLE_HEADER_ICON_OPEN = 'jp-CollapsiblePanel-header-icon-opened';
const COLLAPSIBLE_HEADER_ICON_CLOSED = 'jp-CollapsiblePanel-header-icon-closed';
const COLLAPSIBLE_SLIDER = 'jp-CollapsiblePanel-slider';
const COLLAPSIBLE_OPEN = 'jp-CollapsiblePanel-opened';
const COLLAPSIBLE_CLOSED = 'jp-CollapsiblePanel-closed';
const COLLAPSIBLE_CONTAINER = 'jp-CollapsiblePanel-container';
/**
 * CollapsiblePanel
 */
class CollapsiblePanel extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel {
    static createHeader(headerTitle) {
        let header = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
        header.addClass(COLLAPSIBLE_HEADER);
        if (headerTitle) {
            header.node.textContent = headerTitle;
        }
        let button = document.createElement('button');
        button.className = COLLAPSIBLE_HEADER_ICON;
        header.node.appendChild(button);
        return header;
    }
    constructor(inner, headerTitle, collapsed) {
        super();
        this.addClass(COLLAPSIBLE_CLASS);
        this.inner = inner;
        let header = CollapsiblePanel.createHeader(headerTitle);
        this.header = header;
        this.button = header.node.getElementsByClassName(COLLAPSIBLE_HEADER_ICON)[0];
        header.node.onclick = this.toggleCollapsed.bind(this);
        this.addWidget(header);
        this.container = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
        this.container.addClass(COLLAPSIBLE_CONTAINER);
        this.slider = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
        this.slider.addClass(COLLAPSIBLE_SLIDER);
        this.slider.addWidget(inner);
        this.container.addWidget(this.slider);
        this.addWidget(this.container);
        this.slider.addClass(collapsed === true ? COLLAPSIBLE_CLOSED : COLLAPSIBLE_OPEN);
        this.button.classList.add(collapsed === true
            ? COLLAPSIBLE_HEADER_ICON_CLOSED
            : COLLAPSIBLE_HEADER_ICON_OPEN);
        this.button.classList.add('fa');
        this.button.classList.add(collapsed === true ? 'fa-caret-down' : 'fa-caret-up');
    }
    toggleCollapsed() {
        let slider = this.slider;
        let button = this.button;
        if (this.collapsed) {
            slider.removeClass(COLLAPSIBLE_CLOSED);
            slider.addClass(COLLAPSIBLE_OPEN);
            button.classList.remove(COLLAPSIBLE_HEADER_ICON_CLOSED);
            button.classList.add(COLLAPSIBLE_HEADER_ICON_OPEN);
            this.button.classList.remove('fa-caret-down');
            this.button.classList.add('fa-caret-up');
        }
        else {
            slider.removeClass(COLLAPSIBLE_OPEN);
            slider.addClass(COLLAPSIBLE_CLOSED);
            button.classList.remove(COLLAPSIBLE_HEADER_ICON_OPEN);
            button.classList.add(COLLAPSIBLE_HEADER_ICON_CLOSED);
            this.button.classList.remove('fa-caret-up');
            this.button.classList.add('fa-caret-down');
        }
    }
    get collapsed() {
        return this.slider.hasClass(COLLAPSIBLE_CLOSED);
    }
    set headerTitle(value) {
        this.header.node.innerText = value;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/common/dragpanel.js":
/*!*****************************************************!*\
  !*** ./node_modules/nbdime/lib/common/dragpanel.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DragDropPanel: () => (/* binding */ DragDropPanel),
/* harmony export */   DragDropPanelBase: () => (/* binding */ DragDropPanelBase),
/* harmony export */   DragPanel: () => (/* binding */ DragPanel),
/* harmony export */   DropPanel: () => (/* binding */ DropPanel),
/* harmony export */   FriendlyDragDrop: () => (/* binding */ FriendlyDragDrop),
/* harmony export */   MIME_INDEX: () => (/* binding */ MIME_INDEX),
/* harmony export */   belongsToUs: () => (/* binding */ belongsToUs),
/* harmony export */   findChild: () => (/* binding */ findChild)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/dragdrop */ "webpack/sharing/consume/default/@lumino/dragdrop");
/* harmony import */ var _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * The class name added to the DropPanel
 */
const DROP_WIDGET_CLASS = 'jp-DropPanel';
/**
 * The class name added to the DragPanel
 */
const DRAG_WIDGET_CLASS = 'jp-DragPanel';
/**
 * The class name added to something which can be used to drag a box
 */
const DRAG_HANDLE = 'jp-mod-dragHandle';
/**
 * The class name of the default drag handle
 */
const DEFAULT_DRAG_HANDLE_CLASS = 'jp-DragPanel-dragHandle';
/**
 * The class name added to a drop target.
 */
const DROP_TARGET_CLASS = 'jp-mod-dropTarget';
/**
 * MIME type representing drag data by index
 */
const MIME_INDEX = 'application/vnd.jupyter.dragindex';
/**
 * The threshold in pixels to start a drag event.
 */
const DRAG_THRESHOLD = 5;
/**
 * Determine whether node is equal to or a decendant of our panel, and that is does
 * not belong to a nested drag panel.
 */
function belongsToUs(node, parentClass, parentNode) {
    let candidate = node;
    // Traverse DOM until drag panel encountered:
    while (candidate && !candidate.classList.contains(parentClass)) {
        candidate = candidate.parentElement;
    }
    return !!candidate && candidate === parentNode;
}
/**
 * Find the direct child node of `parent`, which has `node` as a descendant.
 * Alternatively, parent can be a collection of children.
 *
 * Returns null if not found.
 */
function findChild(parent, node) {
    // Work our way up the DOM to an element which has this node as parent
    let child = null;
    let parentIsArray = Array.isArray(parent);
    let isDirectChild = (child) => {
        if (parentIsArray) {
            return parent.indexOf(child) > -1;
        }
        else {
            return child.parentElement === parent;
        }
    };
    let candidate = node;
    while (candidate && candidate !== parent) {
        if (isDirectChild(candidate)) {
            child = candidate;
            break;
        }
        candidate = candidate.parentElement;
    }
    return child;
}
/**
 * A panel class which allows the user to drop mime data onto it.
 *
 * To complete the class, the following functions need to be implemented:
 *  - processDrop: Process pre-screened drop events
 *
 * The functionallity of the class can be extended by overriding the following
 * functions:
 *  - findDropTarget(): Override if anything other than the direct children
 *    of the widget's node are to be the drop targets.
 *
 * For maximum control, `evtDrop` can be overriden.
 */
class DropPanel extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel {
    /**
     * Construct a drop widget.
     */
    constructor(options = {}) {
        super(options);
        this.acceptDropsFromExternalSource =
            options.acceptDropsFromExternalSource === true;
        this.addClass(DROP_WIDGET_CLASS);
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the drop widget's node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'lm-dragenter':
                this._evtDragEnter(event);
                break;
            case 'lm-dragleave':
                this._evtDragLeave(event);
                break;
            case 'lm-dragover':
                this._evtDragOver(event);
                break;
            case 'lm-drop':
                this.evtDrop(event);
                break;
            default:
                break;
        }
    }
    validateSource(event) {
        return this.acceptDropsFromExternalSource || event.source === this;
    }
    /**
     * Find a drop target from a given drag event target.
     *
     * Returns null if no valid drop target was found.
     *
     * The default implementation returns the direct child that is the parent of
     * `node`, or `node` if it is itself a direct child. It also checks that the
     * needed mime type is included
     */
    findDropTarget(input, mimeData) {
        if (!mimeData.hasData(MIME_INDEX)) {
            return null;
        }
        return findChild(this.node, input);
    }
    /**
     * Handle the `'lm-drop'` event for the widget.
     *
     * Responsible for pre-processing event before calling `processDrop`.
     *
     * Should normally only be overriden if you cannot achive your goal by
     * other overrides.
     */
    evtDrop(event) {
        let target = event.target;
        while (target && target.parentElement) {
            if (target.classList.contains(DROP_TARGET_CLASS)) {
                target.classList.remove(DROP_TARGET_CLASS);
                break;
            }
            target = target.parentElement;
        }
        if (!target || !belongsToUs(target, DROP_WIDGET_CLASS, this.node)) {
            // Ignore event
            return;
        }
        // If configured to, only accept internal moves:
        if (!this.validateSource(event)) {
            event.dropAction = 'none';
            event.preventDefault();
            event.stopPropagation();
            return;
        }
        this.processDrop(target, event);
    }
    /**
     * Handle `after_attach` messages for the widget.
     */
    onAfterAttach(msg) {
        let node = this.node;
        node.addEventListener('lm-dragenter', this);
        node.addEventListener('lm-dragleave', this);
        node.addEventListener('lm-dragover', this);
        node.addEventListener('lm-drop', this);
    }
    /**
     * Handle `before_detach` messages for the widget.
     */
    onBeforeDetach(msg) {
        let node = this.node;
        node.removeEventListener('lm-dragenter', this);
        node.removeEventListener('lm-dragleave', this);
        node.removeEventListener('lm-dragover', this);
        node.removeEventListener('lm-drop', this);
    }
    /**
     * Handle the `'lm-dragenter'` event for the widget.
     */
    _evtDragEnter(event) {
        if (!this.validateSource(event)) {
            return;
        }
        let target = this.findDropTarget(event.target, event.mimeData);
        if (target === null) {
            return;
        }
        this._clearDropTarget();
        target.classList.add(DROP_TARGET_CLASS);
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Handle the `'lm-dragleave'` event for the widget.
     */
    _evtDragLeave(event) {
        event.preventDefault();
        event.stopPropagation();
        this._clearDropTarget();
    }
    /**
     * Handle the `'lm-dragover'` event for the widget.
     */
    _evtDragOver(event) {
        if (!this.validateSource(event)) {
            return;
        }
        this._clearDropTarget();
        let target = this.findDropTarget(event.target, event.mimeData);
        if (target === null) {
            return;
        }
        target.classList.add(DROP_TARGET_CLASS);
        event.preventDefault();
        event.stopPropagation();
        event.dropAction = event.proposedAction;
    }
    /**
     * Clear existing drop target from out children.
     *
     * #### Notes
     * This function assumes there are only one active drop target
     */
    _clearDropTarget() {
        let elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);
        if (elements.length) {
            elements[0].classList.remove(DROP_TARGET_CLASS);
        }
    }
}
/**
 * An internal base class for implementing drag operations on top
 * of drop class.
 */
class DragDropPanelBase extends DropPanel {
    /**
     * Construct a drag and drop base widget.
     */
    constructor(options = {}) {
        super(options);
        /**
         * Drag data stored in _startDrag
         */
        this.drag = null;
        this.dragHandleClass = DRAG_HANDLE;
        /**
         * Data stored on mouse down to determine if drag treshold has
         * been overcome, and to initialize drag once it has.
         */
        this._clickData = null;
        this.childrenAreDragHandles = options.childrenAreDragHandles === true;
        this.addClass(DRAG_WIDGET_CLASS);
    }
    /**
     * Dispose of the resources held by the directory listing.
     */
    dispose() {
        this.drag = null;
        this._clickData = null;
        super.dispose();
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the drag widget's node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'mousedown':
                this._evtDragMousedown(event);
                break;
            case 'mouseup':
                this._evtDragMouseup(event);
                break;
            case 'mousemove':
                this._evtDragMousemove(event);
                break;
            default:
                super.handleEvent(event);
                break;
        }
    }
    /**
     * Finds the drag target (the node to move) from a drag handle.
     *
     * Returns null if no valid drag target was found.
     *
     * The default implementation returns the direct child that is the ancestor of
     * (or equal to) the handle.
     */
    findDragTarget(handle) {
        return findChild(this.node, handle);
    }
    /**
     * Returns the drag image to use when dragging using the given handle.
     *
     * The default implementation returns a clone of the drag target.
     */
    getDragImage(handle) {
        let target = this.findDragTarget(handle);
        if (target) {
            return target.cloneNode(true);
        }
        return null;
    }
    /**
     * Called when a drag has completed with this panel as a source
     */
    onDragComplete(action) {
        this.drag = null;
    }
    /**
     * Handle `after_attach` messages for the widget.
     */
    onAfterAttach(msg) {
        let node = this.node;
        node.addEventListener('mousedown', this);
        super.onAfterAttach(msg);
    }
    /**
     * Handle `before_detach` messages for the widget.
     */
    onBeforeDetach(msg) {
        let node = this.node;
        node.removeEventListener('click', this);
        node.removeEventListener('dblclick', this);
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        super.onBeforeDetach(msg);
    }
    /**
     * Start a drag event.
     *
     * Called when dragginging and DRAG_THRESHOLD is met.
     *
     * Should normally only be overriden if you cannot achieve your goal by
     * other overrides.
     */
    startDrag(handle, clientX, clientY) {
        // Create the drag image.
        let dragImage = this.getDragImage(handle);
        // Set up the drag event.
        this.drag = new _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2__.Drag({
            dragImage: dragImage || undefined,
            mimeData: new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.MimeData(),
            supportedActions: 'all',
            proposedAction: 'copy',
            source: this,
        });
        this.addMimeData(handle, this.drag.mimeData);
        // Start the drag and remove the mousemove listener.
        this.drag.start(clientX, clientY).then(this.onDragComplete.bind(this));
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
    }
    /**
     * Check if node, or any of nodes ancestors are a drag handle
     *
     * If it is a drag handle, it returns the handle, if not returns null.
     */
    _findDragHandle(node) {
        let handle = null;
        if (this.childrenAreDragHandles) {
            // Simple scenario, just look for node among children
            if (belongsToUs(node, DRAG_WIDGET_CLASS, this.node)) {
                handle = node;
            }
        }
        else {
            // Otherwise, traverse up DOM to check if click is on a drag handle
            let candidate = node;
            while (candidate && candidate !== this.node) {
                if (candidate.classList.contains(this.dragHandleClass)) {
                    handle = candidate;
                    break;
                }
                candidate = candidate.parentElement;
            }
            // Finally, check that handle does not belong to a nested drag panel
            if (handle !== null &&
                !belongsToUs(handle, DRAG_WIDGET_CLASS, this.node)) {
                // Handle belongs to a nested drag panel:
                handle = null;
            }
        }
        return handle;
    }
    /**
     * Handle the `'mousedown'` event for the widget.
     */
    _evtDragMousedown(event) {
        let target = event.target;
        let handle = this._findDragHandle(target);
        if (handle === null) {
            return;
        }
        // Left mouse press for drag start.
        if (event.button === 0) {
            this._clickData = {
                pressX: event.clientX,
                pressY: event.clientY,
                handle: handle,
            };
            document.addEventListener('mouseup', this, true);
            document.addEventListener('mousemove', this, true);
            event.preventDefault();
        }
    }
    /**
     * Handle the `'mouseup'` event for the widget.
     */
    _evtDragMouseup(event) {
        if (event.button !== 0 || !this.drag) {
            document.removeEventListener('mousemove', this, true);
            document.removeEventListener('mouseup', this, true);
            this.drag = null;
            return;
        }
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Handle the `'mousemove'` event for the widget.
     */
    _evtDragMousemove(event) {
        // Bail if we are already dragging.
        if (this.drag) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        // Check for a drag initialization.
        let data = this._clickData;
        if (!data) {
            throw new Error('Missing drag data');
        }
        let dx = Math.abs(event.clientX - data.pressX);
        let dy = Math.abs(event.clientY - data.pressY);
        if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
            return;
        }
        this.startDrag(data.handle, event.clientX, event.clientY);
        this._clickData = null;
    }
}
/**
 * A panel which allows the user to initiate drag operations.
 *
 * Any descendant element with the drag handle class `'jp-mod-dragHandle'`
 * will serve as a handle that can be used for dragging. If DragPanels are
 * nested, handles will only belong to the closest parent DragPanel. For
 * convenience, the functions `makeHandle`, `unmakeHandle` and
 * `createDefaultHandle` can be used to indicate which elements should be
 * made handles. `createDefaultHandle` will create a new element as a handle
 * with a default styling class applied. Optionally, `childrenAreDragHandles`
 * can be set to indicate that all direct children are themselve drag handles.
 *
 * To complete the class, the following functions need to be implemented:
 * - addMimeData: Adds mime data to new drag events
 *
 * The functionallity of the class can be extended by overriding the following
 * functions:
 *  - findDragTarget(): Override if anything other than the direct children
 *    of the widget's node are to be drag targets.
 *  - getDragImage: Override to change the drag image (the default is a
 *    copy of the drag target).
 *  - onDragComplete(): Callback on drag source when a drag has completed.
 */
class DragPanel extends DragDropPanelBase {
    /**
     * Construct a drag widget.
     */
    constructor(options = {}) {
        // Implementation removes DropPanel options
        super(options);
    }
    /**
     * No-op on DragPanel, as it does not support dropping
     */
    processDrop(dropTarget, event) {
        // Intentionally empty
    }
    /**
     * Simply returns null for DragPanel, as it does not support dropping
     */
    findDropTarget(input, mimeData) {
        return null;
    }
}
/**
 * A widget which allows the user to rearrange widgets in the panel by
 * drag and drop. An internal drag and drop of a widget will cause it
 * to be inserted (by `insertWidget`) in the index of the widget it was
 * dropped on.
 *
 * Any descendant element with the drag handle class `'jp-mod-dragHandle'`
 * will serve as a handle that can be used for dragging. If DragPanels are
 * nested, handles will only belong to the closest parent DragPanel. For
 * convenience, the functions `makeHandle`, `unmakeHandle` and
 * `createDefaultHandle` can be used to indicate which elements should be
 * made handles. `createDefaultHandle` will create a new element as a handle
 * with a default styling class applied. Optionally, `childrenAreDragHandles`
 * can be set to indicate that all direct children are themselve drag handles.
 *
 * The functionallity of the class can be extended by overriding the following
 * functions:
 *  - addMimeData: Override to add other drag data to the mime bundle.
 *    This is often a necessary step for allowing dragging to external
 *    drop targets.
 *  - processDrop: Override if you need to handle other mime data than the
 *    default. For allowing drops from external sources, the field
 *    `acceptDropsFromExternalSource` should be set as well.
 *  - findDragTarget(): Override if anything other than the direct children
 *    of the widget's node are to be drag targets.
 *  - findDropTarget(): Override if anything other than the direct children
 *    of the widget's node are to be the drop targets.
 *  - getIndexOfChildNode(): Override to change the key used to represent
 *    the drag and drop target (default is index of child widget).
 *  - move(): Override to change how a move is handled.
 *  - getDragImage: Override to change the drag image (the default is a
 *    copy of the drag target).
 *  - onDragComplete(): Callback on drag source when a drag has completed.
 *
 * To drag and drop other things than all direct children, the following functions
 * should be overriden: `findDragTarget`, `findDropTarget` and possibly
 * `getIndexOfChildNode` and `move` to allow for custom to/from keys.
 *
 * For maximum control, `startDrag` and `evtDrop` can be overriden.
 */
class DragDropPanel extends DragDropPanelBase {
    /**
     * Called when a widget should be moved as a consequence of an internal drag event.
     *
     * The default implementation assumes the keys `from` and `to` are numbers
     * indexing the drag panel's direct children. It then moves the child at the
     * `to` key to the location of the `from` key.
     */
    move(from, to) {
        if (to !== from) {
            // Adjust for the shifting of elements once 'from' is removed
            if (to > from) {
                to -= 1;
            }
            this.insertWidget(to, this.widgets[from]);
        }
    }
    /**
     * Returns a key used to represent the child node.
     *
     * The default implementation returns the index of node in
     * `this.layout.widgets`.
     *
     * Returns null if not found.
     */
    getIndexOfChildNode(node, parent) {
        parent = parent || this.layout;
        for (let i = 0; i < parent.widgets.length; i++) {
            if (parent.widgets[i].node === node) {
                return i;
            }
        }
        return null;
    }
    /**
     * Adds mime data represeting the drag data to the drag event's MimeData bundle.
     *
     * The default implementation adds mime data indicating the index of the direct
     * child being dragged (as indicated by findDragTarget).
     *
     * Override this method if you have data that cannot be communicated well by an
     * index, for example if the data should be able to be dropped on an external
     * target that only understands direct mime data.
     *
     * As the method simply adds mime data for a specific key, overriders can call
     * this method before/after adding their own mime data to still support default
     * dragging behavior.
     */
    addMimeData(handle, mimeData) {
        let target = this.findDragTarget(handle);
        let key = this.getIndexOfChildNode(target);
        if (key !== null) {
            mimeData.setData(MIME_INDEX, key);
        }
    }
    /**
     * Processes a drop event.
     *
     * This function is called after checking:
     *  - That the `dropTarget` is a valid drop target
     *  - The value of `event.source` if `acceptDropsFromExternalSource` is false
     *
     * The default implementation assumes calling `getIndexOfChildNode` with
     * `dropTarget` will be valid. It will call `move` with that index as `to`,
     * and the index stored in the mime data as `from`.
     *
     * Override this if you need to handle other mime data than the default.
     */
    processDrop(dropTarget, event) {
        if (!DropPanel.isValidAction(event.supportedActions, 'move') ||
            event.proposedAction === 'none') {
            // The default implementation only handles move action
            // OR Accept proposed none action, and perform no-op
            event.dropAction = 'none';
            event.preventDefault();
            event.stopPropagation();
            return;
        }
        if (!this.validateSource(event)) {
            // Source indicates external drop, incorrect use in subclass
            throw new Error('Invalid source!');
        }
        let sourceKey = event.mimeData.getData(MIME_INDEX);
        let targetKey = this.getIndexOfChildNode(dropTarget);
        if (targetKey === null) {
            // Invalid target somehow
            return;
        }
        // We have an acceptable drop, handle:
        this.move(sourceKey, targetKey);
        event.preventDefault();
        event.stopPropagation();
        event.dropAction = 'move';
    }
}
/**
 * The namespace for the `DropPanel` class statics.
 */
(function (DropPanel) {
    /**
     * Validate a drop action against a SupportedActions type
     */
    function isValidAction(supported, action) {
        switch (supported) {
            case 'all':
                return true;
            case 'link-move':
                return action === 'move' || action === 'link';
            case 'copy-move':
                return action === 'move' || action === 'copy';
            case 'copy-link':
                return action === 'link' || action === 'copy';
            default:
                return action === supported;
        }
    }
    DropPanel.isValidAction = isValidAction;
})(DropPanel || (DropPanel = {}));
/**
 * The namespace for the `DragPanel` class statics.
 */
(function (DragPanel) {
    /**
     * Mark a widget as a drag handle.
     *
     * Using this, any child-widget can be a drag handle, as long as mouse events
     * are propagated from it to the DragPanel.
     */
    function makeHandle(handle) {
        handle.addClass(DRAG_HANDLE);
    }
    DragPanel.makeHandle = makeHandle;
    /**
     * Unmark a widget as a drag handle
     */
    function unmakeHandle(handle) {
        handle.removeClass(DRAG_HANDLE);
    }
    DragPanel.unmakeHandle = unmakeHandle;
    /**
     * Create a default handle widget for dragging (see styling in DragPanel.css).
     *
     * The handle will need to be styled to ensure a minimum size
     */
    function createDefaultHandle() {
        let widget = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget();
        widget.addClass(DEFAULT_DRAG_HANDLE_CLASS);
        makeHandle(widget);
        return widget;
    }
    DragPanel.createDefaultHandle = createDefaultHandle;
})(DragPanel || (DragPanel = {}));
class FriendlyDragDrop extends DragDropPanel {
    static makeGroup() {
        const id = this._counter++;
        FriendlyDragDrop._groups[id] = [];
        return id;
    }
    setFriendlyGroup(id) {
        this._groupId = id;
        FriendlyDragDrop._groups[id].push(this);
    }
    addToFriendlyGroup(other) {
        other.setFriendlyGroup(this._groupId);
    }
    get friends() {
        if (this._groupId === undefined) {
            throw new Error('Uninitialized drag-drop group');
        }
        return FriendlyDragDrop._groups[this._groupId];
    }
    getIndexOfChildNode(node, parent) {
        const friends = this.friends;
        for (let panel of friends) {
            if (!belongsToUs(node, DROP_WIDGET_CLASS, panel.node)) {
                continue;
            }
            let child = findChild(panel.node, node);
            if (child !== null) {
                return [
                    panel.friends.indexOf(panel),
                    super.getIndexOfChildNode(child, panel.layout),
                ];
            }
        }
        return null;
    }
    validateSource(event) {
        if (this.acceptDropsFromExternalSource) {
            return this.friends.indexOf(event.source) !== -1;
        }
        return super.validateSource(event);
    }
}
FriendlyDragDrop._counter = 0;
FriendlyDragDrop._groups = {};


/***/ }),

/***/ "./node_modules/nbdime/lib/common/editor.js":
/*!**************************************************!*\
  !*** ./node_modules/nbdime/lib/common/editor.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EditorWidget: () => (/* binding */ EditorWidget),
/* harmony export */   createEditorFactory: () => (/* binding */ createEditorFactory)
/* harmony export */ });
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ "webpack/sharing/consume/default/@codemirror/language");
/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyter_ydoc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyter/ydoc */ "webpack/sharing/consume/default/@jupyter/ydoc");
/* harmony import */ var _jupyter_ydoc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyter_ydoc__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/codeeditor */ "webpack/sharing/consume/default/@jupyterlab/codeeditor");
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/codemirror */ "webpack/sharing/consume/default/@jupyterlab/codemirror");
/* harmony import */ var _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






class EditorWidget extends _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2__.CodeEditorWrapper {
    /**
     * Store all editor instances for operations that
     * need to loop over all instances.
     */
    constructor(options) {
        const { factory, value, ...others } = options;
        const sharedModel = new _jupyter_ydoc__WEBPACK_IMPORTED_MODULE_1__.YFile();
        if (value) {
            sharedModel.source = value;
        }
        const model = new _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_2__.CodeEditor.Model({ sharedModel });
        super({
            model: model,
            factory: factory ?? createEditorFactory(),
            editorOptions: others,
        });
        this.staticLoaded = false;
    }
    get cm() {
        return this.editor.editor;
    }
    get doc() {
        return this.editor.doc;
    }
}
function createExtensionsRegistry(themes) {
    const extensions = new _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.EditorExtensionRegistry();
    // Register default extensions
    const extensionNameList = [
        'lineNumbers',
        'readOnly',
        'theme',
        'allowMultipleSelections',
        'tabSize',
    ];
    for (const extensionFactory of _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.EditorExtensionRegistry.getDefaultExtensions({
        themes,
    })) {
        for (const extensionName of extensionNameList) {
            if (extensionFactory.name === extensionName) {
                extensions.addExtension(extensionFactory);
            }
        }
    }
    extensions.addExtension({
        name: 'shared-model-binding',
        factory: options => {
            const sharedModel = options.model.sharedModel;
            return _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.EditorExtensionRegistry.createImmutableExtension((0,_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.ybinding)({
                ytext: sharedModel.ysource,
                undoManager: sharedModel.undoManager ?? undefined,
            }));
        },
    });
    return extensions;
}
function createLanguagesRegistry() {
    const languages = new _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.EditorLanguageRegistry();
    // Register default languages
    for (const language of _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.EditorLanguageRegistry.getDefaultLanguages()) {
        languages.addLanguage(language);
    }
    // Add Jupyter Markdown flavor here to support
    // code block highlighting.
    languages.addLanguage({
        name: 'ipythongfm',
        mime: 'text/x-ipythongfm',
        load: async () => {
            const [m, tex] = await Promise.all([
                Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_codemirror_lang-markdown_dist_index_js"), __webpack_require__.e("webpack_sharing_consume_default_lezer_common-webpack_sharing_consume_default_lezer_highlight")]).then(__webpack_require__.bind(__webpack_require__, /*! @codemirror/lang-markdown */ "./node_modules/@codemirror/lang-markdown/dist/index.js")),
                __webpack_require__.e(/*! import() */ "node_modules_codemirror_legacy-modes_mode_stex_js").then(__webpack_require__.bind(__webpack_require__, /*! @codemirror/legacy-modes/mode/stex */ "./node_modules/@codemirror/legacy-modes/mode/stex.js")),
            ]);
            return m.markdown({
                base: m.markdownLanguage,
                codeLanguages: (info) => languages.findBest(info),
                extensions: [
                    (0,_jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.parseMathIPython)(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.StreamLanguage.define(tex.stexMath).parser),
                ],
            });
        },
    });
    return languages;
}
function createThemeRegistry() {
    const themes = new _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.EditorThemeRegistry();
    for (const theme of _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.EditorThemeRegistry.getDefaultThemes()) {
        themes.addTheme(theme);
    }
    return themes;
}
function createEditorFactory(options = {}) {
    const factory = new _jupyterlab_codemirror__WEBPACK_IMPORTED_MODULE_3__.CodeMirrorEditorFactory({
        extensions: options.extensions ?? createExtensionsRegistry(createThemeRegistry()),
        languages: options.languages ?? createLanguagesRegistry(),
        translator: options.translator ?? _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__.nullTranslator,
    });
    return factory.newInlineEditor.bind(factory);
}


/***/ }),

/***/ "./node_modules/nbdime/lib/common/exceptions.js":
/*!******************************************************!*\
  !*** ./node_modules/nbdime/lib/common/exceptions.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotifyUserError: () => (/* binding */ NotifyUserError)
/* harmony export */ });
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * An error that should be displayed to the user
 */
class NotifyUserError extends Error {
    constructor(message, severity = 'error') {
        super(message);
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, NotifyUserError.prototype);
        this.message = message;
        this.stack = new Error().stack;
        this.severity = severity;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/common/mergeview.js":
/*!*****************************************************!*\
  !*** ./node_modules/nbdime/lib/common/mergeview.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DIFF_OP: () => (/* binding */ DIFF_OP),
/* harmony export */   DiffView: () => (/* binding */ DiffView),
/* harmony export */   EventDirection: () => (/* binding */ EventDirection),
/* harmony export */   MergeView: () => (/* binding */ MergeView),
/* harmony export */   createNbdimeMergeView: () => (/* binding */ createNbdimeMergeView),
/* harmony export */   paddingWidgetField: () => (/* binding */ paddingWidgetField),
/* harmony export */   replacePaddingWidgetEffect: () => (/* binding */ replacePaddingWidgetEffect)
/* harmony export */ });
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ "webpack/sharing/consume/default/@codemirror/state");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ "webpack/sharing/consume/default/@codemirror/view");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _merge_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../merge/model */ "./node_modules/nbdime/lib/merge/model/index.js");
/* harmony import */ var _diff_range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../diff/range */ "./node_modules/nbdime/lib/diff/range.js");
/* harmony import */ var _chunking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../chunking */ "./node_modules/nbdime/lib/chunking/index.js");
/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./editor */ "./node_modules/nbdime/lib/common/editor.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util */ "./node_modules/nbdime/lib/common/util.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// This code is based on the CodeMirror mergeview.js source:
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE










const PICKER_SYMBOL = '\u27ad\uFE0E';
const CONFLICT_MARKER = '\u26A0\uFE0E';
var DIFF_OP;
(function (DIFF_OP) {
    DIFF_OP[DIFF_OP["DIFF_DELETE"] = -1] = "DIFF_DELETE";
    DIFF_OP[DIFF_OP["DIFF_INSERT"] = 1] = "DIFF_INSERT";
    DIFF_OP[DIFF_OP["DIFF_EQUAL"] = 0] = "DIFF_EQUAL";
})(DIFF_OP || (DIFF_OP = {}));
var EventDirection;
(function (EventDirection) {
    EventDirection[EventDirection["INCOMING"] = 0] = "INCOMING";
    EventDirection[EventDirection["OUTGOING"] = 1] = "OUTGOING";
})(EventDirection || (EventDirection = {}));
const GUTTER_PICKER_CLASS = 'jp-Merge-gutter-picker';
const GUTTER_CONFLICT_CLASS = 'jp-Merge-gutter-conflict';
const CHUNK_CONFLICT_CLASS = 'jp-Merge-conflict';
const conflictDecoration = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.line({ class: CHUNK_CONFLICT_CLASS });
const lineHighlightTypeList = ['chunk', 'conflict', 'start', 'end'];
var Private;
(function (Private) {
    function buildEditorDecorationDict(editorType, chunkAction) {
        const suffix = chunkAction ? '-' + chunkAction : '';
        const prefix = 'cm-merge' + '-' + editorType;
        const dict = {
            chunk: _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.line({ class: prefix + '-chunk' + suffix }),
            start: _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.line({
                class: prefix + '-chunk' + '-' + 'start' + suffix,
            }),
            end: _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.line({ class: prefix + '-chunk' + '-' + 'end' + suffix }),
            endEmpty: _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.line({
                class: prefix + '-chunk' + '-' + 'end' + suffix + '-empty',
            }),
            conflict: conflictDecoration,
            inserted: _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({ class: prefix + '-' + 'inserted' }),
            deleted: _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({ class: prefix + '-' + 'deleted' }),
        };
        return dict;
    }
    Private.buildEditorDecorationDict = buildEditorDecorationDict;
})(Private || (Private = {}));
const mergeViewDecorationDict = {
    left: Private.buildEditorDecorationDict('l'),
    right: Private.buildEditorDecorationDict('r'),
    localMerge: Private.buildEditorDecorationDict('m', 'local'),
    remoteMerge: Private.buildEditorDecorationDict('m', 'remote'),
    customMerge: Private.buildEditorDecorationDict('m', 'custom'),
    eitherMerge: Private.buildEditorDecorationDict('m', 'either'),
    mixedMerge: Private.buildEditorDecorationDict('m', 'mixed'),
};
/**
 * Additional theme element
 */
const baseTheme = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({
    '.cm-collapsedLines': {
        cursor: 'pointer',
        color: 'var(--jp-ui-font-color1)',
        backgroundColor: 'var(--jp-layout-color2)',
        border: 'var(--jp-border-width) solid var(--jp-border-color1)',
        fontSize: '90%',
        padding: '0 3px',
        borderRadius: '4px',
    },
});
/**
 * Get common editor extensions
 *
 * @param isMergeView Whether the editor is within a merge view or not.
 * @returns Editor extensions
 */
function getCommonEditorExtensions(isMergeView = true) {
    const extensions = [baseTheme, highlightField, paddingWidgetField];
    return isMergeView
        ? [
            ...extensions,
            gutterMarkerField,
            pickerLineChunkMappingField,
            conflictMarkerLineChunkMappingField,
        ]
        : extensions;
}
function applyMapping({ from, to }, mapping) {
    const map = { from: mapping.mapPos(from), to: mapping.mapPos(to) };
    return map;
}
/**
 * Effect for adding highlighting on lines or on characters
 */
const addHighlightEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: applyMapping,
});
/**
 * Effect for removing highlighting on lines or on characters
 */
const removeHighlightEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: applyMapping,
});
/**
 * StateField storing information about highlighting elements of an editor
 */
const highlightField = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({
    create() {
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none;
    },
    update(highlightRanges, transaction) {
        highlightRanges = highlightRanges.map(transaction.changes);
        for (let e of transaction.effects) {
            let decoration;
            if (e.is(addHighlightEffect)) {
                decoration =
                    mergeViewDecorationDict[e.value.decorationKey][e.value.highlightType];
                highlightRanges = highlightRanges.update({
                    add: [decoration.range(e.value.from, e.value.to)],
                });
            }
            if (e.is(removeHighlightEffect)) {
                decoration =
                    mergeViewDecorationDict[e.value.decorationKey][e.value.highlightType];
                highlightRanges = highlightRanges.update({
                    filter: (from, to, value) => {
                        return decoration.spec.class !== value.spec.class;
                    },
                });
            }
        }
        return highlightRanges;
    },
    provide: field => _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(field),
});
/**
 * StateField storing information about padding widgets used to keep the alignment between different editors
 */
const replacePaddingWidgetEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: (value, mapping) => value.map(mapping),
});
/**
 * StateField storing information about padding widgets used to keep the alignment between different editors
 */
const paddingWidgetField = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({
    create: () => _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none,
    update: (paddingWidgetRanges, transaction) => {
        for (let e of transaction.effects) {
            if (e.is(replacePaddingWidgetEffect)) {
                return e.value;
            }
        }
        return paddingWidgetRanges.map(transaction.changes);
    },
    provide: field => _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(field),
});
/**
 * Widget used for aligning lines of different editors that need to be at the same distance from the top of the document
 */
class PaddingWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {
    constructor(size) {
        super();
        this.size = size;
    }
    toDOM() {
        let elt = document.createElement('div');
        elt.className = 'cm-merge-spacer';
        elt.style.height = this.size + 'px';
        elt.style.minWidth = '1px';
        return elt;
    }
}
/**
 * Effect for adding a gutter marker
 */
const addGutterMarkerEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: (val, mapping) => ({
        from: mapping.mapPos(val.from),
        block: val.block,
        on: val.on,
        type: val.type,
    }),
});
/**
 * Effect for removing a gutter marker
 */
const removeGutterMarkerEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: val => ({ type: val.type }),
});
class MergeMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.GutterMarker {
    constructor(options) {
        super();
        this.symbol = options.symbol;
        this.className = options.className;
        this.block = options.block;
    }
    toDOM() {
        let pickerMarker = elt('div', this.symbol);
        pickerMarker.className = this.className;
        return pickerMarker;
    }
    eq(other) {
        return other === this;
    }
}
/**
 * StateField storing information about gutter markers (picker and conflict ones)
 */
const gutterMarkerField = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({
    create: () => {
        return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.empty;
    },
    update: (gutters, transaction) => {
        gutters = gutters.map(transaction.changes);
        for (let e of transaction.effects) {
            if (e.is(addGutterMarkerEffect)) {
                if (e.value.on) {
                    const marker = e.value.type === 'picker'
                        ? e.value.block
                            ? pickerBlockMarker
                            : pickerMarker
                        : e.value.block
                            ? conflictBlockMarker
                            : conflictMarker;
                    // check for overlap (duplicates) with same type
                    let overlap = false;
                    gutters.between(e.value.from, e.value.from, (from, to, value) => {
                        if (from === e.value.from && value.eq(marker)) {
                            overlap = true;
                            return false;
                        }
                        return;
                    });
                    if (!overlap) {
                        gutters = gutters.update({ add: [marker.range(e.value.from)] });
                    }
                }
            }
            if (e.is(removeGutterMarkerEffect)) {
                gutters = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.empty;
            }
        }
        return gutters;
    },
});
/**
 * Picker gutter marker DOM Element 
 */
const pickerMarker = new MergeMarker({
    symbol: PICKER_SYMBOL,
    className: GUTTER_PICKER_CLASS,
    block: false,
});
const pickerBlockMarker = new MergeMarker({
    symbol: PICKER_SYMBOL,
    className: GUTTER_PICKER_CLASS,
    block: true,
});
/**
 * Conflict gutter marker DOM Element 
 */
const conflictMarker = new MergeMarker({
    symbol: CONFLICT_MARKER,
    className: GUTTER_CONFLICT_CLASS,
    block: false,
});
const conflictBlockMarker = new MergeMarker({
    symbol: CONFLICT_MARKER,
    className: GUTTER_CONFLICT_CLASS,
    block: true,
});
/**
 * Effect for adding a mapping between a line and a chunk
 * This is used for adding the gutters at the right place : there is a single gutter marker associated with each chunk
 */
const addLineChunkMappingEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: (val, mapping) => ({
        line: mapping.mapPos(val.line),
        chunk: val.chunk,
        type: val.type,
    }),
});
/**
 * Effect for removing a mapping between a line and a chunk
 * This is used for removing the gutters from the right place there is a single gutter marker associated with each chunk
 */
const removeLineChunkMappingEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: val => ({ type: val.type }),
});
/**
 * StateField storing information about the mapping between a line and a chunk for picker gutter markers
 */
const pickerLineChunkMappingField = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({
    create: () => {
        return new Map();
    },
    update: (lineChunkMapping, transaction) => {
        let newLineChunkMapping = lineChunkMapping;
        for (let e of transaction.effects) {
            if (e.is(addLineChunkMappingEffect) && e.value.type === 'picker') {
                newLineChunkMapping.set(e.value.line, e.value.chunk);
            }
        }
        return newLineChunkMapping;
    },
});
/**
 * StateField storing information about the mapping between a line and a chunk for conflict gutter markers
 */
const conflictMarkerLineChunkMappingField = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({
    create: () => {
        return new Map();
    },
    update: (lineChunkMapping, transaction) => {
        let newLineChunkMapping = lineChunkMapping;
        for (let e of transaction.effects) {
            if (e.is(addLineChunkMappingEffect) && e.value.type === 'conflict') {
                newLineChunkMapping.set(e.value.line, e.value.chunk);
            }
        }
        return newLineChunkMapping;
    },
});
/**
 * uncollapseEffect effect to synchronize uncollapseEffectd ranges between editors.
 */
const uncollapseEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: (value, change) => change.mapPos(value),
});
/**
 * Effect to set the collapser widgets in an editor
 */
const setCollapsersEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({
    map: (value, mapping) => value.map(mapping),
});
class CollapseWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {
    constructor(lines, siblings) {
        super();
        this.lines = lines;
        this.siblings = siblings;
    }
    eq(other) {
        return (this.lines == other.lines &&
            this.siblings.every(sibling => other.siblings.findIndex(otherSibling => otherSibling.line == sibling.line &&
                otherSibling.cm == sibling.cm) >= 0));
    }
    toDOM(view) {
        let outer = document.createElement('div');
        outer.className = 'cm-collapsedLines';
        outer.textContent = view.state.phrase('($ unchanged lines)', this.lines);
        outer.addEventListener('click', e => {
            const pos = view.posAtDOM(e.target);
            this.siblings.forEach(sibling => {
                if (sibling.cm === view) {
                    view.dispatch({ effects: uncollapseEffect.of(pos) });
                }
                else {
                    const from = sibling.cm.state.doc.line(sibling.line).from;
                    sibling.cm.dispatch({ effects: uncollapseEffect.of(from) });
                }
            });
        });
        return outer;
    }
    ignoreEvent(e) {
        return e instanceof MouseEvent;
    }
    get estimatedHeight() {
        return 27;
    }
}
/**
 * StateField storing information about the collapsed ranges
 */
const CollapsedRangesField = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({
    create(state) {
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none;
    },
    update(deco, tr) {
        for (let e of tr.effects) {
            if (e.is(setCollapsersEffect)) {
                return e.value;
            }
        }
        deco = deco.map(tr.changes);
        for (let e of tr.effects)
            if (e.is(uncollapseEffect))
                deco = deco.update({ filter: from => from != e.value });
        return deco;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f),
});
/**
 * A wrapper view for showing StringDiffModels in a MergeView
 */
function createNbdimeMergeView(options) {
    const { remote, local, merged, readOnly, factory, collapseIdentical, showBase, translator, } = options;
    let opts = {
        remote,
        local,
        merged,
        config: { readOnly },
        factory: factory ?? (0,_editor__WEBPACK_IMPORTED_MODULE_7__.createEditorFactory)(),
        collapseIdentical,
        showBase,
        translator,
    };
    let mergeview = new MergeView(opts);
    let editors = [];
    if (mergeview.left) {
        editors.push(mergeview.left);
    }
    if (mergeview.right) {
        editors.push(mergeview.right);
    }
    if (mergeview.merge) {
        editors.push(mergeview.merge);
    }
    let mimetype = (remote || merged).mimetype;
    if (mimetype) {
        // Set the editor mode to the MIME type.
        for (let e of editors) {
            e.remoteEditorWidget.model.mimeType = mimetype;
        }
        mergeview.base.model.mimeType = mimetype;
    }
    return mergeview;
}
/**
 * Used by MergeView to show diff in a string diff model
 */
class DiffView {
    constructor({ model, type, options, lockScroll, translator, }) {
        this._model = model;
        this._trans = (translator ?? _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__.nullTranslator).load('nbdime');
        this._type = type;
        this._lockScroll = lockScroll ?? true;
        let remoteValue = this._model.remote || '';
        this._remoteEditorWidget = new _editor__WEBPACK_IMPORTED_MODULE_7__.EditorWidget({
            ...options,
            value: remoteValue,
        });
        this.setScrollLock(this._lockScroll);
    }
    init(baseWidget) {
        this._baseEditorWidget = baseWidget;
        this._lineChunks = this._model.getLineChunks();
        this._chunks = (0,_chunking__WEBPACK_IMPORTED_MODULE_6__.lineToNormalChunks)(this._lineChunks);
        this.updateView();
        this.syncScroll();
    }
    /**
     * Update the highlighting in the views of baseEditor and remoteEditor
     */
    updateView() {
        const baseEditor = this._baseEditorWidget.cm;
        const remoteEditor = this._remoteEditorWidget.cm;
        this.clearHighlighting(remoteEditor, this._model.additions, this._chunks, DIFF_OP.DIFF_INSERT);
        this.clearHighlighting(baseEditor, this._model.deletions, this._chunks, DIFF_OP.DIFF_DELETE);
        this.updateHighlighting(remoteEditor, this._model.additions, this._chunks, DIFF_OP.DIFF_INSERT);
        this.updateHighlighting(baseEditor, this._model.deletions, this._chunks, DIFF_OP.DIFF_DELETE);
    }
    /**
     * Update the chunks once a version has been picked
     */
    syncModel() {
        if (!this.modelInvalid()) {
            return;
        }
        let editor = this.remoteEditorWidget.cm;
        let updatedLineChunks = this._model.getLineChunks();
        let updatedChunks = (0,_chunking__WEBPACK_IMPORTED_MODULE_6__.lineToNormalChunks)(updatedLineChunks);
        if (this._model.remote === editor.state.doc.toString()) {
            // Nothing to do except update chunks
            this._lineChunks = updatedLineChunks;
            this._chunks = updatedChunks;
            return;
        }
        let cursor = editor.state.selection.main.head;
        let newLines = (0,_util__WEBPACK_IMPORTED_MODULE_8__.splitLines)(this._model.remote);
        editor.dispatch({
            changes: {
                from: 0,
                to: editor.state.doc.length,
                insert: newLines.slice(0, newLines.length).join(''),
            },
        }, { selection: { anchor: cursor } });
        this._lineChunks = updatedLineChunks;
        this._chunks = updatedChunks;
    }
    /**
     * Add a gap DOM element between 2 editors
     */
    buildGap() {
        let lock = (this._lockButton = elt('div', undefined, 'cm-merge-scrolllock'));
        lock.title = this._trans.__('Toggle locked scrolling');
        this.setScrollLock(this._lockScroll);
        lock.addEventListener('click', event => {
            this.setScrollLock(!this._lockScroll);
        });
        let gap = elt('div', [lock], 'cm-merge-gap');
        this._gap = gap;
        return this._gap;
    }
    /**
     * Whether to lock scroll or not.
     *
     * @param val Scroll lock value
     */
    setScrollLock(val) {
        this._lockScroll = val;
        if (this._lockButton) {
            this._lockButton.innerHTML = val
                ? '\u21db\u21da'
                : '\u21db&nbsp;&nbsp;\u21da';
        }
        // Force scroll synchronization in case it was not synchronize
        window.requestAnimationFrame(() => {
            this._remoteEditorWidget.cm.scrollDOM.scrollLeft =
                this._baseEditorWidget.cm.scrollDOM.scrollLeft;
            this._remoteEditorWidget.cm.scrollDOM.scrollTop =
                this._baseEditorWidget.cm.scrollDOM.scrollTop;
        });
    }
    modelInvalid() {
        return (this._model instanceof _merge_model__WEBPACK_IMPORTED_MODULE_4__.DecisionStringDiffModel && this._model.invalid);
    }
    /**
     * Synchronize the scrolling between editors.
     * srcEditor refers to the source editor from which the scrolling is done and listened
     * destEditor is the destination editor whose scrolling is synchronized with the one of srcEditor.
     */
    syncScroll() {
        if (this.modelInvalid()) {
            return;
        }
        const srcScroller = this._baseEditorWidget.cm.scrollDOM;
        const destScroller = this._remoteEditorWidget.cm.scrollDOM;
        srcScroller.addEventListener('scroll', event => {
            if (!this._lockScroll) {
                return;
            }
            window.requestAnimationFrame(function () {
                destScroller.scrollLeft = srcScroller.scrollLeft;
                destScroller.scrollTop = srcScroller.scrollTop;
            });
        }, { passive: true });
        destScroller.addEventListener('scroll', event => {
            if (!this._lockScroll) {
                return;
            }
            window.requestAnimationFrame(function () {
                srcScroller.scrollLeft = destScroller.scrollLeft;
                srcScroller.scrollTop = destScroller.scrollTop;
            });
        }, { passive: true });
    }
    /**
     * The decorationKey is used to have access to the correct css class associated to a given decoration type
     */
    getDecorationKey(sources) {
        let s = this._type;
        let res = s;
        if (this._type === 'merge') {
            s = sources[0].action;
            res = s + 'Merge';
            if (sources.length > 1) {
                for (let si of sources.slice(1)) {
                    if (si.action !== s) {
                        res = 'mixedMerge';
                        break;
                    }
                }
            }
        }
        return res;
    }
    getConflictState(sources) {
        let conflict = false;
        if (sources.length > 0) {
            for (let s of sources) {
                if (s.decision.conflict) {
                    conflict = true;
                    break;
                }
            }
        }
        return conflict;
    }
    /**
     * Create effects related to gutter markers
     */
    createGutterEffects(editor, chunk, from, type, block = false) {
        let effects = [];
        let gutterEffect = addGutterMarkerEffect.of({
            from: from,
            on: true,
            type: type,
            block: block,
        });
        effects.push(gutterEffect);
        effects.push(addLineChunkMappingEffect.of({
            line: (0,_diff_range__WEBPACK_IMPORTED_MODULE_5__.offsetToPos)(editor.state.doc, from).line,
            chunk: chunk,
            type: type,
        }));
        return effects;
    }
    /**
     * Build line background effects and gutter markers effects
     */
    buildLineEffects(editor, chunkArray) {
        let effects = [];
        let isbaseEditor = editor === this._baseEditorWidget.cm;
        for (let chunk of chunkArray) {
            let decorationKey = this.getDecorationKey(chunk.sources);
            let conflict = this.getConflictState(chunk.sources);
            let chunkFirstLine;
            let chunkLastLine;
            if (isbaseEditor) {
                chunkFirstLine = chunk.baseFrom;
                chunkLastLine = chunk.baseTo;
            }
            else {
                chunkFirstLine = chunk.remoteFrom;
                chunkLastLine = chunk.remoteTo;
            }
            for (let i = chunkFirstLine; i < chunkLastLine; i++) {
                let pos = { line: i, column: 0 };
                let startingOffset = (0,_diff_range__WEBPACK_IMPORTED_MODULE_5__.posToOffset)(editor.state.doc, pos);
                effects.push(addHighlightEffect.of({
                    from: startingOffset,
                    to: startingOffset,
                    highlightType: 'chunk',
                    decorationKey: decorationKey,
                }));
                if (conflict) {
                    effects.push(addHighlightEffect.of({
                        from: startingOffset,
                        to: startingOffset,
                        highlightType: 'conflict',
                        decorationKey: decorationKey,
                    }));
                }
                if (i === chunkFirstLine) {
                    effects.push(addHighlightEffect.of({
                        from: startingOffset,
                        to: startingOffset,
                        highlightType: 'start',
                        decorationKey: decorationKey,
                    }));
                    if (!decorationKey.includes('Merge')) {
                        // For all editors except merge editor, add a picker button
                        effects = effects.concat(this.createGutterEffects(editor, chunk, startingOffset, 'picker'));
                    }
                    else if (editor === this._baseEditorWidget.cm) {
                        for (let s of chunk.sources) {
                            if (s.decision.action === 'custom' &&
                                !(0,_util__WEBPACK_IMPORTED_MODULE_8__.hasEntries)(s.decision.localDiff) &&
                                !(0,_util__WEBPACK_IMPORTED_MODULE_8__.hasEntries)(s.decision.remoteDiff)) {
                                // We have a custom decision, add picker on base only!
                                effects = effects.concat(this.createGutterEffects(editor, chunk, startingOffset, 'picker'));
                            }
                        }
                    }
                    else if (conflict && editor === this.remoteEditorWidget.cm) {
                        effects = effects.concat(this.createGutterEffects(editor, chunk, startingOffset, 'conflict'));
                    }
                }
                if (i === chunkLastLine - 1) {
                    effects.push(addHighlightEffect.of({
                        from: startingOffset,
                        to: startingOffset,
                        highlightType: 'end',
                        decorationKey: decorationKey,
                    }));
                }
            }
            if (chunkFirstLine === chunkLastLine) {
                // When the chunk is empty, make sure a horizontal line shows up
                const startingOffset = (0,_diff_range__WEBPACK_IMPORTED_MODULE_5__.posToOffset)(editor.state.doc, {
                    line: chunkFirstLine,
                    column: 0,
                });
                effects.push(addHighlightEffect.of({
                    from: startingOffset,
                    to: startingOffset,
                    highlightType: 'endEmpty',
                    decorationKey: decorationKey,
                }));
                if (!decorationKey.includes('Merge')) {
                    effects = effects.concat(this.createGutterEffects(editor, chunk, startingOffset, 'picker', true));
                }
                else if (conflict) {
                    // Add conflict markers on editor, if conflicted
                    effects = effects.concat(this.createGutterEffects(editor, chunk, startingOffset, 'conflict', true));
                }
            }
        }
        return effects;
    }
    /**
     * Remove line background effects and gutter markers effects
     */
    clearLineEffects(editor, chunkArray) {
        let effects = [];
        for (let chunk of chunkArray) {
            let sources = chunk.sources;
            let decorationKey = this.getDecorationKey(sources);
            for (let highlightType of lineHighlightTypeList) {
                effects.push(removeHighlightEffect.of({
                    highlightType: highlightType,
                    decorationKey: decorationKey,
                }));
            }
        }
        if (editor !== this._baseEditorWidget.cm) {
            effects.push(removeGutterMarkerEffect.of({ type: 'all' }));
            effects.push(removeLineChunkMappingEffect.of({ type: 'picker' }));
            effects.push(removeLineChunkMappingEffect.of({ type: 'conflict' }));
        }
        return effects;
    }
    /**
     * Build character highlighting effects
     */
    buildCharacterHighlighting(editor, diffRanges, markType) {
        const effects = [];
        const sources = [];
        if (markType === DIFF_OP.DIFF_INSERT || markType === DIFF_OP.DIFF_DELETE) {
            const highlightType = markType === DIFF_OP.DIFF_DELETE ? 'deleted' : 'inserted';
            for (let r of diffRanges) {
                if (r.source !== undefined) {
                    sources.push(r.source);
                }
                const startingOffset = (0,_diff_range__WEBPACK_IMPORTED_MODULE_5__.posToOffset)(editor.state.doc, {
                    line: r.from.line,
                    column: r.from.column,
                });
                const endingOffset = (0,_diff_range__WEBPACK_IMPORTED_MODULE_5__.posToOffset)(editor.state.doc, {
                    line: r.to.line,
                    column: r.to.column,
                });
                effects.push(addHighlightEffect.of({
                    from: startingOffset,
                    to: endingOffset,
                    highlightType: highlightType,
                    decorationKey: this.getDecorationKey(sources),
                }));
            }
        }
        return effects;
    }
    /**
    Clear character highlighting effects
    */
    clearCharacterHighlighting(editor, diffRanges, markType) {
        let effects = [];
        let sources = [];
        if (markType === DIFF_OP.DIFF_INSERT || markType === DIFF_OP.DIFF_DELETE) {
            let highlightType = markType === DIFF_OP.DIFF_DELETE ? 'deleted' : 'inserted';
            for (let r of diffRanges) {
                if (r.source !== undefined) {
                    sources.push(r.source);
                }
                let decorationKey = this.getDecorationKey(sources);
                effects.push(removeHighlightEffect.of({
                    highlightType: highlightType,
                    decorationKey: decorationKey,
                }));
            }
        }
        return effects;
    }
    /**
    Build line effects (highlight and gutters) and character highlighting effects and dispatch them
     */
    updateHighlighting(editor, diffRanges, chunkArray, type) {
        const LineHighlightEffects = this.buildLineEffects(editor, chunkArray);
        const MarkHighlightEffects = this.buildCharacterHighlighting(editor, diffRanges, type);
        const effects = LineHighlightEffects.concat(MarkHighlightEffects);
        editor.dispatch({ effects });
    }
    /**
    Clear line effects (highlight and gutters) and character highlighting effects and dispatch them
     */
    clearHighlighting(editor, diffRanges, chunkArray, type) {
        const clearLineEffects = this.clearLineEffects(editor, chunkArray);
        const clearCharacterHighlightEffects = this.clearCharacterHighlighting(editor, diffRanges, type);
        const effects = clearLineEffects.concat(clearCharacterHighlightEffects);
        editor.dispatch({ effects });
    }
    get remoteEditorWidget() {
        return this._remoteEditorWidget;
    }
    get baseEditorWidget() {
        return this._baseEditorWidget;
    }
    get chunks() {
        return this._chunks;
    }
    get lineChunks() {
        return this._lineChunks;
    }
    get model() {
        return this._model;
    }
}
/**
 * From a line in base, find the matching line in another editor by chunks.
 */
function getMatchingEditLine(baseLine, chunks) {
    let offset = 0;
    // Start values correspond to either the start of the chunk,
    // or the start of a preceding unmodified part before the chunk.
    // It is the difference between these two that is interesting.
    for (let i = 0; i < chunks.length; i++) {
        let chunk = chunks[i];
        if (chunk.baseTo > baseLine && chunk.baseFrom <= baseLine) {
            return 0;
        }
        if (chunk.baseFrom > baseLine) {
            break;
        }
        offset = chunk.remoteTo - chunk.baseTo;
    }
    return baseLine + offset;
}
/**
 * From a line in base, find the matching line in another editor by line chunks
 *
 */
function getMatchingEditLineLC(toMatch, chunks) {
    const editLine = toMatch.baseFrom;
    // Initialize with the last chunk in case we don't hit one of the
    // two escape conditions in the for loop.
    let previous = chunks[chunks.length - 1];
    for (let i = 0; i < chunks.length; ++i) {
        const chunk = chunks[i];
        if (chunk.baseFrom === editLine) {
            // Chunk is part of the chunk list
            return chunk.remoteTo;
        }
        if (chunk.baseFrom > editLine) {
            // Remaining chunks are after the one we are interested
            previous = chunks[i - 1];
            break;
        }
    }
    // toMatch is not in chunks list, add lines delta from the last chunk
    return toMatch.baseTo + (previous ? previous.remoteTo - previous.baseTo : 0);
}
/**
 * Find which line numbers align with each other, in the
 * set of DiffViews. The returned array is of the format:
 *
 * [ aligned line #1:[Edit line number, (DiffView#1 line number, DiffView#2 line number,) ...],
 *   aligned line #2 ..., etc.]
 */
function findAlignedLines(dvs) {
    let linesToAlign = [];
    let ignored = [];
    // First fill directly from first DiffView
    let dv = dvs[0];
    let others = dvs.slice(1);
    for (let i = 0; i < dv.lineChunks.length; i++) {
        let chunk = dv.lineChunks[i];
        let lines = [chunk.baseTo, chunk.remoteTo];
        for (const o of others) {
            lines.push(getMatchingEditLineLC(chunk, o.lineChunks));
        }
        if (linesToAlign.length > 0 &&
            linesToAlign[linesToAlign.length - 1][0] === lines[0]) {
            let last = linesToAlign[linesToAlign.length - 1];
            for (let j = 0; j < lines.length; ++j) {
                last[j] = Math.max(last[j], lines[j]);
            }
        }
        else {
            if (linesToAlign.length > 0) {
                let prev = linesToAlign[linesToAlign.length - 1];
                let diff = lines[0] - prev[0];
                // Skip this chunk if it does not required spacers
                for (let j = 1; j < lines.length; ++j) {
                    if (diff !== lines[j] - prev[j]) {
                        diff = null;
                        break;
                    }
                }
                if (diff === null) {
                    linesToAlign.push(lines);
                }
                else {
                    ignored.push(lines[0]);
                    continue;
                }
            }
            else {
                linesToAlign.push(lines);
            }
        }
    }
    // Then fill any chunks from remaining DiffView, which are not already added
    for (let o = 0; o < others.length; o++) {
        for (let i = 0; i < others[o].lineChunks.length; i++) {
            let chunk = others[o].lineChunks[i];
            // Check against existing matches to see if already consumed:
            let j = 0;
            for (; j < linesToAlign.length; j++) {
                let align = linesToAlign[j];
                if ((0,_util__WEBPACK_IMPORTED_MODULE_8__.valueIn)(chunk.baseTo, ignored)) {
                    // Chunk already consumed, continue to next chunk
                    j = -1;
                    break;
                }
                else if (align[0] >= chunk.baseTo) {
                    // New chunk, which should be inserted in pos j,
                    // such that linesToAlign are sorted on edit line
                    break;
                }
            }
            if (j > -1) {
                let lines = [chunk.baseTo, getMatchingEditLineLC(chunk, dv.lineChunks)];
                for (let k = 0; k < others.length; k++) {
                    if (k === o) {
                        lines.push(chunk.remoteTo);
                    }
                    else {
                        lines.push(getMatchingEditLineLC(chunk, others[k].lineChunks));
                    }
                }
                if (linesToAlign.length > j && linesToAlign[j][0] === chunk.baseTo) {
                    let last = linesToAlign[j];
                    for (let k = 0; k < lines.length; ++k) {
                        last[k] = Math.max(last[k], lines[k]);
                    }
                }
                else {
                    linesToAlign.splice(j, 0, lines);
                }
            }
        }
    }
    return linesToAlign;
}
// Merge view, containing 1 or 2 diff views.
class MergeView extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__.Panel {
    constructor(options) {
        super();
        this._collapseIdentical = 2;
        this._showBase = true;
        this._measuring = -1;
        this._trans = (options.translator ?? _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__.nullTranslator).load('nbdime');
        let remote = options.remote;
        let local = options.local || null;
        let merged = options.merged || null;
        let left = (this._left = null);
        let right = (this._right = null);
        let merge = (this._merge = null);
        // Set to -1 to deactivate
        if (typeof options.collapseIdentical !== 'undefined') {
            this._collapseIdentical =
                typeof options.collapseIdentical === 'number'
                    ? Math.max(-1, options.collapseIdentical)
                    : options.collapseIdentical
                        ? 2
                        : -1;
        }
        let panes = 0;
        let main = options.remote || options.merged;
        if (!main) {
            throw new Error('Either remote or merged model needs to be specified!');
        }
        const value = main.base !== null ? main.base : main.remote ?? '';
        // Whether merge view should be readonly
        let readOnly = options.config?.readOnly ?? false;
        options.config = {
            ...options.config,
            lineNumbers: options.config?.lineNumbers !== false,
            // For all others:
            readOnly: true,
        };
        if (merged) {
            // Turn off linewrapping for merge view by default, keep for diff
            options.config.lineWrap = options.config.lineWrap ?? false;
        }
        this._aligning = true;
        /**
         * Listener extension to track for changes in the editorView
         */
        const listener = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.updateListener.of(update => {
            if (this._measuring < 0 &&
                /*update.heightChanged || */ update.viewportChanged &&
                !update.transactions.some(tr => tr.effects.some(e => e.is(replacePaddingWidgetEffect)))) {
                this.alignViews();
            }
        });
        /**
         * MergeControlGutter to set the gutter in a given editor and the mousedown events for picker markers
         */
        const mergeControlGutter = [
            gutterMarkerField,
            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.gutter)({
                class: 'cm-gutter',
                markers: view => {
                    return view.state.field(gutterMarkerField).update({
                        filter: (_from, _to, value) => !value.block,
                    });
                },
                widgetMarker: (view, widget, block) => {
                    if (!(widget instanceof PaddingWidget)) {
                        return null;
                    }
                    const markers = view.state.field(gutterMarkerField).update({
                        filter: (from, _to, value) => value.block && block.from === from,
                    });
                    if (markers.size > 1) {
                        throw Error('More than one block gutter widget matched');
                    }
                    if (markers.size === 1) {
                        const cursor = markers.iter();
                        return cursor.value;
                    }
                    return null;
                },
                initialSpacer: () => pickerMarker,
                domEventHandlers: {
                    mouseup: (editor, line, event) => {
                        if (event.button === 0) {
                            this.onGutterClick(editor, line);
                            return true;
                        }
                        return false;
                    },
                },
            }),
        ];
        /*
         * Different cases possible:
         *   - Local and merged supplied: Merge:
         *     - Always use left, right and merge panes
         *     - Use base if `showBase` not set to false
         *   - Only remote supplied: Diff:
         *     - No change: Use ony base editor
         *     - Entire content added/deleted: Use only base editor,
         *       but with different classes
         *     - Partial changes: Use base + right editor
         */
        const inMergeView = !!merged;
        const additionalExtensions = inMergeView
            ? [listener, mergeControlGutter, getCommonEditorExtensions(inMergeView)]
            : getCommonEditorExtensions(inMergeView);
        additionalExtensions.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.phrases.of({
            '($ unchanged lines)': this._trans.__('($ unchanged lines)'),
        }));
        const singlePane = !merged && (remote?.unchanged || remote?.added || remote?.deleted);
        if (
        // no collapse
        this._collapseIdentical >= 0 &&
            // not displaying a single editor
            !singlePane) {
            additionalExtensions.push(CollapsedRangesField);
        }
        this._base = new _editor__WEBPACK_IMPORTED_MODULE_7__.EditorWidget({
            ...options,
            extensions: [options.extensions ?? [], additionalExtensions],
            value,
        });
        this.addClass('jp-Mergeview-root');
        // START MERGE CASE
        if (merged) {
            this.addClass('cm-merge-grid-panel');
            const showBase = (this._showBase = options.showBase !== false);
            let leftWidget;
            if (!local || local.remote === null) {
                // Local value was deleted
                left = this._left = null;
                leftWidget = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__.Widget({
                    node: elt('div', this._trans.__('Value missing'), 'jp-mod-missing'),
                });
            }
            else {
                left = this._left = new DiffView({
                    model: local,
                    type: 'left',
                    options: {
                        ...options,
                        // Copy configuration
                        config: { ...options.config },
                        extensions: [options.extensions ?? [], additionalExtensions],
                    },
                    lockScroll: showBase,
                    translator: options.translator,
                });
                leftWidget = left.remoteEditorWidget;
            }
            this.addWidget(leftWidget);
            leftWidget.addClass('cm-merge-pane');
            leftWidget.addClass('cm-merge-left-editor');
            if (showBase) {
                this.addWidget(this._base);
                this._base.addClass('cm-merge-pane');
                this._base.addClass('cm-central-editor');
            }
            let rightWidget;
            if (!remote || remote.remote === null) {
                // Remote value was deleted
                right = this._right = null;
                rightWidget = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__.Widget({
                    node: elt('div', this._trans.__('Value missing'), 'jp-mod-missing'),
                });
            }
            else {
                right = this._right = new DiffView({
                    model: remote,
                    type: 'right',
                    options: {
                        ...options,
                        // Copy configuration
                        config: { ...options.config },
                        extensions: [options.extensions ?? [], additionalExtensions],
                    },
                    lockScroll: showBase,
                    translator: options.translator,
                });
                rightWidget = right.remoteEditorWidget;
            }
            this.addWidget(rightWidget);
            rightWidget.addClass('cm-merge-pane');
            rightWidget.addClass('cm-merge-right-editor');
            merge = this._merge = new DiffView({
                model: merged,
                type: 'merge',
                options: {
                    ...options,
                    // Copy configuration
                    config: { ...options.config, readOnly },
                    extensions: [options.extensions ?? [], additionalExtensions],
                },
                lockScroll: showBase,
                translator: options.translator,
            });
            let mergeWidget = merge.remoteEditorWidget;
            if (showBase) {
                this.addWidget(mergeWidget);
            }
            else {
                this.insertWidget(1, mergeWidget);
                // We add scroll synchronization between left, right and merge here
                // as the base editor is not inserted and the diff view scroll synchronization does not work
                function addScroll(srcScroller, destScroller) {
                    srcScroller.addEventListener('scroll', () => {
                        window.requestAnimationFrame(function () {
                            destScroller.scrollLeft = srcScroller.scrollLeft;
                            destScroller.scrollTop = srcScroller.scrollTop;
                        });
                    }, { passive: true });
                    destScroller.addEventListener('scroll', () => {
                        window.requestAnimationFrame(function () {
                            srcScroller.scrollLeft = destScroller.scrollLeft;
                            srcScroller.scrollTop = destScroller.scrollTop;
                        });
                    }, { passive: true });
                }
                if (this.left) {
                    addScroll(this.merge.remoteEditorWidget.cm.scrollDOM, this.left.remoteEditorWidget.cm.scrollDOM);
                }
                if (this.right) {
                    addScroll(this.merge.remoteEditorWidget.cm.scrollDOM, this.right.remoteEditorWidget.cm.scrollDOM);
                }
            }
            mergeWidget.addClass('cm-merge-pane');
            mergeWidget.addClass('cm-merge-editor');
            //END MERGE CASE
            panes = 3 + (showBase ? 1 : 0);
            // START DIFF CASE
        }
        else if (remote) {
            if (remote.unchanged || remote.added || remote.deleted) {
                panes = 1;
                this.addWidget(this._base);
                if (remote.unchanged) {
                    this._base.addClass('cm-merge-pane-unchanged');
                }
                else if (remote.added) {
                    this._base.addClass('cm-merge-pane-added');
                }
                else if (remote.deleted) {
                    this._base.addClass('cm-merge-pane-deleted');
                }
                this._base.addClass('cm-merge-pane');
            }
            else {
                panes = 2;
                this.addWidget(this._base);
                this._base.addClass('cm-merge-pane');
                this._base.addClass('cm-diff-left-editor');
                right = this._right = new DiffView({
                    model: remote,
                    type: 'right',
                    options: {
                        ...options,
                        // Copy configuration
                        config: { ...options.config },
                        extensions: [options.extensions ?? [], additionalExtensions],
                    },
                    translator: options.translator,
                });
                let rightWidget = right.remoteEditorWidget;
                rightWidget.addClass('cm-merge-pane');
                rightWidget.addClass('cm-diff-right-editor');
                this.addWidget(new _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__.Widget({ node: right.buildGap() }));
                this.addWidget(rightWidget);
            }
        }
        this.addClass('cm-merge-' + panes + 'pane');
        for (let dv of [left, right, merge]) {
            if (dv) {
                dv.init(this._base);
            }
        }
        if (this._collapseIdentical >= 0) {
            this.collapseIdenticalStretches();
        }
        this._aligning = false;
        if (this._diffViews.length > 0) {
            this.scheduleAlignViews();
        }
    }
    /**
     * Align the matching lines of the different editors
     */
    alignViews() {
        const lineHeight = this._showBase
            ? this._base.cm.defaultLineHeight
            : this._diffViews[0].remoteEditorWidget.cm.defaultLineHeight;
        if (this._aligning) {
            return;
        }
        this._aligning = true;
        // Find matching lines
        const linesToAlign = findAlignedLines(this._diffViews);
        // Function modifying DOM to perform alignment:
        const editors = [
            this.base.cm,
            ...this._diffViews.map(dv => dv.remoteEditorWidget.cm),
        ];
        const builders = [];
        for (let i = 0; i < editors.length; i++) {
            builders.push(new _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSetBuilder());
        }
        const sumDeltas = new Array(editors.length).fill(0);
        const nLines = editors.map(editor => editor.state.doc.lines);
        for (const alignment_ of linesToAlign) {
            const alignment = this._showBase ? alignment_.slice(0, 3) : alignment_;
            const lastLine = Math.max(...alignment);
            const lineDeltas = alignment.map((line, i) => lastLine - line - sumDeltas[i]);
            // If some paddings will be before the current line, it means all other editors
            // must add a padding.
            const minDelta = this._showBase
                ? Math.min(...lineDeltas)
                : Math.min(...lineDeltas.slice(1));
            const correctedDeltas = lineDeltas.map(line => line - minDelta);
            correctedDeltas.forEach((delta, i) => {
                // Don't compute anything for the base editor if it is hidden
                if (!this._showBase && i === 0) {
                    return;
                }
                // Alignments are zero-based
                let line = alignment[i];
                if (delta > 0 && line < nLines[i]) {
                    sumDeltas[i] += delta;
                    // This method include the correction from zero-based lines to one-based lines
                    const offset = (0,_diff_range__WEBPACK_IMPORTED_MODULE_5__.posToOffset)(editors[i].state.doc, {
                        line,
                        column: 0,
                    });
                    builders[i].add(offset, offset, _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.widget({
                        widget: new PaddingWidget(delta * lineHeight),
                        block: true,
                        side: -1,
                    }));
                }
            });
        }
        // Padding at the last line of the editor
        const totalHeight = nLines.map((line, i) => line + sumDeltas[i]);
        const maxHeight = Math.max(...totalHeight);
        totalHeight.slice(0, this._showBase ? 3 : 4).forEach((line, i) => {
            if (maxHeight > line) {
                const end = editors[i].state.doc.length;
                const delta = maxHeight - line;
                sumDeltas[i] += delta;
                builders[i].add(end, end, _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.widget({
                    widget: new PaddingWidget(delta * lineHeight),
                    block: true,
                    side: 1,
                }));
            }
        });
        // Don't insert spacers on merge if base is shown
        for (let i = 0; i <
            (this._showBase && editors.length > 2
                ? editors.length - 1
                : editors.length); i++) {
            // Don't update spacers on base if it is hidden.
            if (i === 0 && !this._showBase) {
                continue;
            }
            const decoSet = builders[i].finish();
            if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSet.eq([decoSet], [editors[i].state.field(paddingWidgetField)])) {
                editors[i].dispatch({
                    effects: replacePaddingWidgetEffect.of(decoSet),
                });
            }
        }
        this._aligning = false;
    }
    /**
     * Used to schedule the call of alignViews
     */
    scheduleAlignViews() {
        if (this._measuring < 0) {
            this._measuring = window.requestAnimationFrame(() => {
                this._measuring = -1;
                this.alignViews();
            });
        }
    }
    getMergedValue() {
        if (!this.merge) {
            throw new Error('No merged value; missing "merged" view');
        }
        return this.merge.remoteEditorWidget.doc.toString();
    }
    collapseIdenticalStretches() {
        const margin = this._collapseIdentical;
        if (margin < 0) {
            return;
        }
        // Build an array of line that are not part of a chunks
        const baseEditor = this.base.cm;
        const clear = new Array(baseEditor.state.doc.lines).fill(true);
        // Collapsers per editor
        const builders = [new _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSetBuilder()];
        if (this.left) {
            builders.push(new _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSetBuilder());
            unclearNearChunks(this.left, margin, clear);
        }
        if (this.right) {
            builders.push(new _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSetBuilder());
            unclearNearChunks(this.right, margin, clear);
        }
        if (this.merge) {
            builders.push(new _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.RangeSetBuilder());
            unclearNearChunks(this.merge, margin, clear);
        }
        for (let i = 0; i < clear.length; i++) {
            if (clear[i]) {
                // Lines are 1-based
                const line = i + 1;
                let size = 1;
                for (; i < clear.length - 1 && clear[i + 1]; i++, size++) {
                    // Just finding size of identical stretch
                }
                if (size > margin) {
                    // Store the corresponding collapser positions
                    const editors = [
                        { line: line, cm: baseEditor },
                    ]; // Collapser in the reference editor
                    if (this.left) {
                        editors.push({
                            line: getMatchingEditLine(line, this.left.chunks),
                            cm: this.left.remoteEditorWidget.cm,
                        });
                    }
                    if (this.right) {
                        editors.push({
                            line: getMatchingEditLine(line, this.right.chunks),
                            cm: this.right.remoteEditorWidget.cm,
                        });
                    }
                    if (this.merge) {
                        editors.push({
                            line: getMatchingEditLine(line, this.merge.chunks),
                            cm: this.merge.remoteEditorWidget.cm,
                        });
                    }
                    // Create collapser for this strech
                    editors.forEach((editor, idx) => {
                        const from = editor.cm.state.doc.line(editor.line).from;
                        const to = editor.cm.state.doc.line(editor.line + size - 1).to;
                        builders[idx].add(from, to, _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.replace({
                            widget: new CollapseWidget(size, editors),
                            block: true,
                        }));
                    });
                }
            }
        }
        const editors = [
            baseEditor,
            ...this._diffViews.map(dv => dv.remoteEditorWidget.cm),
        ];
        builders.forEach((builder, idx) => {
            const decorationSet = builder.finish();
            editors[idx].dispatch({
                effects: setCollapsersEffect.of(decorationSet),
            });
        });
    }
    /**
     * Actions and updates performed when a gutter marker is clicked
     */
    onGutterClick(editor, line) {
        let effects = [];
        let offset = line.from;
        let gutterMarkerline = (0,_diff_range__WEBPACK_IMPORTED_MODULE_5__.offsetToPos)(editor.state.doc, offset).line;
        let isPicker = editor != this.merge?.remoteEditorWidget.cm;
        if (isPicker) {
            let pickerLineChunksMapping = editor.state.field(pickerLineChunkMappingField);
            let chunk = pickerLineChunksMapping.get(gutterMarkerline);
            if (!(editor == this._base.cm)) {
                for (let source of chunk.sources) {
                    source.decision.action = source.action;
                }
            }
            else if (this.merge && editor === this._base.cm) {
                for (let source of chunk.sources) {
                    source.decision.action = 'base';
                }
            }
            for (let i = chunk.sources.length - 1; i >= 0; --i) {
                let source = chunk.sources[i];
                if (this.merge && (0,_util__WEBPACK_IMPORTED_MODULE_8__.hasEntries)(source.decision.customDiff)) {
                    // Custom diffs are cleared on pick,
                    // as there is no way to re-pick them
                    source.decision.customDiff = [];
                }
            }
            if (chunk.sources.length === 0) {
                // All decisions empty, remove picker
                // In these cases, there should only be one picker, on base
                // so simply remove the one we have here
            }
            effects.push(addGutterMarkerEffect.of({
                from: line.from,
                on: false,
                type: 'picker',
                block: false,
            }));
        }
        else {
            // conflict picker
            let conflictLineChunksMapping = editor.state.field(conflictMarkerLineChunkMappingField);
            let chunk = conflictLineChunksMapping.get(gutterMarkerline);
            for (let source of chunk.sources) {
                if (editor !== this._base.cm) {
                    source.decision.conflict = false;
                }
            }
        }
        editor.dispatch({ effects: effects });
        this.updateDiffModels();
        this.updateDiffViews();
        this.alignViews();
        return true;
    }
    /**
     * Update of the models of the diffViews by calling syncModel that updates the chunks
     */
    updateDiffModels() {
        for (let dv of this._diffViews) {
            if (dv.model instanceof _merge_model__WEBPACK_IMPORTED_MODULE_4__.DecisionStringDiffModel) {
                dv.model.invalidate();
            }
            dv.syncModel();
        }
    }
    /**
     * Update of the views of the diffViews by calling updateView
     * Before updating the diffViews, baseEditor needs to be cleared from its pickers
     */
    updateDiffViews() {
        this.clearBaseEditorPickers();
        for (let dv of this._diffViews) {
            dv.updateView();
        }
    }
    /**
     * Clear the pickers of the baseEditor
     * The baseEditor is indeed cumulating pickers from different diffViews
     * Since this editor is common to the 3 diffviews
     */
    clearBaseEditorPickers() {
        let effects = [];
        effects.push(removeGutterMarkerEffect.of({ type: 'all' }));
        effects.push(removeLineChunkMappingEffect.of({ type: 'picker' }));
        this._base.cm.dispatch({ effects });
    }
    get left() {
        return this._left;
    }
    get right() {
        return this._right;
    }
    get merge() {
        return this._merge;
    }
    get base() {
        return this._base;
    }
    get _diffViews() {
        return [this.left, this.right, this.merge].filter(dv => dv !== null);
    }
}
/**
 To create DOM element with defined properties
 */
function elt(tag, content, className, style) {
    let e = document.createElement(tag);
    if (className) {
        e.className = className;
    }
    if (style) {
        e.style.cssText = style;
    }
    if (typeof content === 'string') {
        e.appendChild(document.createTextNode(content));
    }
    else if (content) {
        for (let i = 0; i < content.length; ++i) {
            e.appendChild(content[i]);
        }
    }
    return e;
}
function unclearNearChunks(dv, margin, clear) {
    for (let i = 0; i < dv.chunks.length; i++) {
        const chunk = dv.chunks[i];
        for (let l = chunk.baseFrom - margin; l < chunk.baseTo + margin; l++) {
            const pos = l;
            if (pos >= 0 && pos < clear.length) {
                clear[pos] = false;
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/common/util.js":
/*!************************************************!*\
  !*** ./node_modules/nbdime/lib/common/util.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   accumulateLengths: () => (/* binding */ accumulateLengths),
/* harmony export */   arraysEqual: () => (/* binding */ arraysEqual),
/* harmony export */   buildSelect: () => (/* binding */ buildSelect),
/* harmony export */   deepCopy: () => (/* binding */ deepCopy),
/* harmony export */   findSharedPrefix: () => (/* binding */ findSharedPrefix),
/* harmony export */   hasEntries: () => (/* binding */ hasEntries),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   isPrefixArray: () => (/* binding */ isPrefixArray),
/* harmony export */   repeatString: () => (/* binding */ repeatString),
/* harmony export */   shallowCopy: () => (/* binding */ shallowCopy),
/* harmony export */   sortByKey: () => (/* binding */ sortByKey),
/* harmony export */   splitLines: () => (/* binding */ splitLines),
/* harmony export */   stableSort: () => (/* binding */ stableSort),
/* harmony export */   unique: () => (/* binding */ unique),
/* harmony export */   valueIn: () => (/* binding */ valueIn)
/* harmony export */ });
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * Check whether a value is in an array.
 */
function valueIn(value, array) {
    return array.indexOf(value) >= 0;
}
/**
 * Check whether array is null or empty, and type guards agains null
 */
function hasEntries(array) {
    return array !== null && array.length !== 0;
}
/**
 * Splits a multinline string into an array of lines
 *
 * @export
 * @param {string} multiline
 * @returns {string[]}
 */
function splitLines(multiline) {
    // Split lines (retaining newlines)
    // We use !postfix, as we also match empty string,
    // so we are guaranteed to get at elast one match
    return multiline.match(/^.*(\r\n|\r|\n|$)/gm);
}
function deepCopy(obj) {
    if (typeof obj !== 'object') {
        if (valueIn(typeof obj, ['string', 'number', 'boolean'])) {
            return obj;
        }
        throw new TypeError('Cannot deepcopy non-object');
    }
    if (obj === null) {
        return null;
    }
    else if (Array.isArray(obj)) {
        let l = obj.length;
        let o = new Array(l);
        for (let i = 0; i < l; i++) {
            o[i] = deepCopy(obj[i]);
        }
        return o;
    }
    else {
        let a = obj;
        let r = {};
        if (a.prototype !== undefined) {
            r.prototype = a.prototype;
        }
        for (let k in obj) {
            r[k] = deepCopy(a[k]);
        }
        return r;
    }
}
/**
 * Shallow copy routine for objects
 */
function shallowCopy(original) {
    // First create an empty object with
    // same prototype of our original source
    let clone = Object.create(Object.getPrototypeOf(original));
    for (let k in original) {
        // Don't copy function
        let ok = original[k];
        if (ok !== null &&
            ok !== undefined &&
            ok.hasOwnProperty('constructor') &&
            ok.constructor === Function) {
            continue;
        }
        let pDesc = Object.getOwnPropertyDescriptor(original, k);
        // Don't copy properties with getter
        if (!pDesc || pDesc.get) {
            continue;
        }
        // copy each property into the clone
        Object.defineProperty(clone, k, pDesc);
    }
    return clone;
}
/**
 * Do a shallow, element-wise equality comparison on two arrays.
 */
function arraysEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (a === null || b === null) {
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Find the shared common starting sequence in two arrays
 */
function findSharedPrefix(a, b) {
    if (a === null || b === null) {
        return null;
    }
    if (a === b) {
        // Only checking for instance equality
        return a.slice();
    }
    let i = 0;
    for (; i < Math.min(a.length, b.length); ++i) {
        if (a[i] !== b[i]) {
            break;
        }
    }
    return a.slice(0, i);
}
/**
 * Check whether `parent` is contained within the start of `child`
 *
 * Note on terminology: Parent is here the shortest array, as it will
 * be the parent in a tree-view of values, e.g. a path. In other words, parent
 * is a subsequence of child.
 */
function isPrefixArray(parent, child) {
    if (parent === child) {
        return true;
    }
    if (parent === null || parent.length === 0) {
        return true;
    }
    if (child === null || parent.length > child.length) {
        return false;
    }
    for (let i = 0; i < parent.length; ++i) {
        if (parent[i] !== child[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Sort array by attribute `key` (i.e. compare by array[0][key] < array[1][key]). Stable.
 */
function sortByKey(array, key) {
    return stableSort(array, function (a, b) {
        let x = a[key];
        let y = b[key];
        return x < y ? -1 : x > y ? 1 : 0;
    });
}
/**
 * Utility function to repeat a string
 */
function repeatString(str, count) {
    if (count < 1) {
        return '';
    }
    let result = '';
    let pattern = str.valueOf();
    while (count > 1) {
        if (count & 1) {
            result += pattern;
        }
        (count >>= 1), (pattern += pattern);
    }
    return result + pattern;
}
/**
 * Calculate the cumulative sum of string lengths for an array of strings
 *
 * Example:
 *   For the arary ['ab', '123', 'y', '\t\nfoo'], the output would be
 *   [2, 5, 6, 11]
 */
function accumulateLengths(arr) {
    let ret = [];
    arr.reduce(function (a, b, i) {
        return (ret[i] = a + b.length);
    }, 0);
    return ret;
}
/**
 * Filter for Array.filter to only have unique values
 */
function unique(value, index, self) {
    return self.indexOf(value) === index;
}
/**
 * Return the intersection of two arrays (with no duplicates)
 */
function intersection(a, b) {
    let ret = [];
    // Loop over longest, so that indexOf works on shortest
    [a, b] = a.length > b.length ? [a, b] : [b, a];
    for (let ia of a) {
        if (b.indexOf(ia) !== -1) {
            ret.push(ia);
        }
    }
    return ret;
}
/**
 * Similar to Array.sort, but guaranteed to keep order stable
 * when compare function returns 0
 */
function stableSort(arr, compare) {
    let sorters = [];
    for (let i = 0; i < arr.length; ++i) {
        sorters.push({ index: i, key: arr[i] });
    }
    sorters = sorters.sort((a, b) => {
        return compare(a.key, b.key) || a.index - b.index;
    });
    let out = new Array(arr.length);
    for (let i = 0; i < arr.length; ++i) {
        out[i] = arr[sorters[i].index];
    }
    return out;
}
/**
 * Create or populate a select element with string options
 */
function buildSelect(options, select) {
    if (select === undefined) {
        select = document.createElement('select');
    }
    for (let option of options) {
        let opt = document.createElement('option');
        opt.text = option;
        select.appendChild(opt);
    }
    return select;
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/diffentries.js":
/*!*****************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/diffentries.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   opAdd: () => (/* binding */ opAdd),
/* harmony export */   opAddRange: () => (/* binding */ opAddRange),
/* harmony export */   opPatch: () => (/* binding */ opPatch),
/* harmony export */   opRemove: () => (/* binding */ opRemove),
/* harmony export */   opRemoveRange: () => (/* binding */ opRemoveRange),
/* harmony export */   opReplace: () => (/* binding */ opReplace),
/* harmony export */   validateObjectOp: () => (/* binding */ validateObjectOp),
/* harmony export */   validateSequenceOp: () => (/* binding */ validateSequenceOp)
/* harmony export */ });
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/** Create a replacement diff entry */
function opReplace(key, value) {
    return { op: 'replace', key: key, value: value };
}
/** Create an addition diff entry */
function opAdd(key, value) {
    return { op: 'add', key: key, value: value };
}
/** Create a removal diff entry */
function opRemove(key) {
    return { op: 'remove', key: key };
}
/** Create a removal diff entry */
function opAddRange(key, valuelist) {
    return { op: 'addrange', key: key, valuelist: valuelist };
}
/** Create a range removal diff entry */
function opRemoveRange(key, length) {
    return { op: 'removerange', key: key, length: length };
}
/** Create a range removal diff entry */
function opPatch(key, diff) {
    return { op: 'patch', key: key, diff: diff };
}
/**
 * Validate that a diff operation is valid to apply on a given base sequence
 */
function validateSequenceOp(base, entry) {
    if (typeof entry.key !== 'number') {
        console.warn('Invalid patch details', base, entry);
        throw new TypeError(`Invalid patch sequence op: Key is not a number: ${entry.key}`);
    }
    let index = entry.key;
    if (entry.op === 'addrange') {
        if (index < 0 || index > base.length || isNaN(index)) {
            throw new RangeError('Invalid add range diff op: Key out of range: ' + index);
        }
    }
    else if (entry.op === 'removerange') {
        if (index < 0 || index >= base.length || isNaN(index)) {
            throw new RangeError('Invalid remove range diff op: Key out of range: ' + index);
        }
        let skip = entry.length;
        if (index + skip > base.length || isNaN(index)) {
            throw new RangeError('Invalid remove range diff op: Range too long!');
        }
    }
    else if (entry.op === 'patch') {
        if (index < 0 || index >= base.length || isNaN(index)) {
            throw new RangeError('Invalid patch diff op: Key out of range: ' + index);
        }
    }
    else {
        throw new Error('Invalid op: ' + entry.op);
    }
}
/**
 * Validate that a diff operation is valid to apply on a given base object
 */
function validateObjectOp(base, entry, keys) {
    let op = entry.op;
    if (typeof entry.key !== 'string') {
        console.warn('Invalid patch details', base, entry, keys);
        throw new TypeError(`Invalid patch object op: Key is not a string: ${entry.key}`);
    }
    let key = entry.key;
    if (op === 'add') {
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(key, keys)) {
            throw new Error('Invalid add key diff op: Key already present: ' + key);
        }
    }
    else if (op === 'remove') {
        if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(key, keys)) {
            throw new Error('Invalid remove key diff op: Missing key: ' + key);
        }
    }
    else if (op === 'replace') {
        if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(key, keys)) {
            throw new Error('Invalid replace key diff op: Missing key: ' + key);
        }
    }
    else if (op === 'patch') {
        if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(key, keys)) {
            throw new Error('Invalid patch key diff op: Missing key: ' + key);
        }
    }
    else {
        throw new Error('Invalid op: ' + op);
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/model/cell.js":
/*!****************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/model/cell.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellDiffModel: () => (/* binding */ CellDiffModel),
/* harmony export */   createAddedCellDiffModel: () => (/* binding */ createAddedCellDiffModel),
/* harmony export */   createDeletedCellDiffModel: () => (/* binding */ createDeletedCellDiffModel),
/* harmony export */   createPatchedCellDiffModel: () => (/* binding */ createPatchedCellDiffModel),
/* harmony export */   createUnchangedCellDiffModel: () => (/* binding */ createUnchangedCellDiffModel)
/* harmony export */ });
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/nbformat */ "webpack/sharing/consume/default/@jupyterlab/nbformat");
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/exceptions */ "./node_modules/nbdime/lib/common/exceptions.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ "./node_modules/nbdime/lib/diff/util.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string */ "./node_modules/nbdime/lib/diff/model/string.js");
/* harmony import */ var _output__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./output */ "./node_modules/nbdime/lib/diff/model/output.js");
/* harmony import */ var _immutable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./immutable */ "./node_modules/nbdime/lib/diff/model/immutable.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







/**
 * Diff model for individual Notebook Cells
 */
class CellDiffModel {
    constructor(source, metadata, outputs, executionCount, cellType, cellId) {
        this.source = source;
        this.metadata = metadata;
        this.outputs = outputs;
        this.executionCount = executionCount;
        this.cellType = cellType;
        this.cellId = cellId;
        if (outputs === null && cellType === 'code') {
            throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_1__.NotifyUserError('Invalid code cell, missing outputs!');
        }
        this.metadata.collapsible = true;
        this.metadata.collapsibleHeader = 'Metadata changed';
        this.metadata.startCollapsed = true;
    }
    /**
     * Whether the cell has remained unchanged
     */
    get unchanged() {
        let unchanged = this.source.unchanged;
        unchanged = unchanged && (this.metadata ? this.metadata.unchanged : true);
        if (this.outputs) {
            for (let o of this.outputs) {
                unchanged = unchanged && o.unchanged;
            }
        }
        if (this.executionCount) {
            // TODO: Ignore if option 'ignore minor' set?
            unchanged = unchanged && this.executionCount.unchanged;
        }
        return unchanged;
    }
    /**
     * Whether the cell has been added to the notebook (new cell)
     */
    get added() {
        return this.source.added;
    }
    /**
     * Whether the cell has been deleted/removed from the notebook
     */
    get deleted() {
        return this.source.deleted;
    }
    /**
     * Chunked outputs
     */
    getChunkedOutputs() {
        if (this.outputs === null) {
            return null;
        }
        const chunks = [];
        if (this.added || this.deleted) {
            // Should not chunk outputs for added/deleted cells
            // simply make one element chunks:
            for (let o of this.outputs) {
                chunks.push([o]);
            }
        }
        else {
            let currentChunk = [];
            for (let o of this.outputs) {
                if (o.added || o.deleted) {
                    currentChunk.push(o);
                }
                else {
                    if (currentChunk.length) {
                        chunks.push(currentChunk);
                    }
                    chunks.push([o]);
                    currentChunk = [];
                }
            }
            if (currentChunk.length) {
                chunks.push(currentChunk);
            }
        }
        return chunks;
    }
}
function createPatchedCellDiffModel(base, diff, nbMimetype) {
    let source = null;
    let metadata = null;
    let outputs = null;
    let executionCount = null;
    let subDiff = (0,_util__WEBPACK_IMPORTED_MODULE_2__.getSubDiffByKey)(diff, 'source');
    if (subDiff) {
        source = (0,_string__WEBPACK_IMPORTED_MODULE_3__.createPatchStringDiffModel)(base.source, subDiff);
    }
    else {
        source = (0,_string__WEBPACK_IMPORTED_MODULE_3__.createDirectStringDiffModel)(base.source, base.source);
    }
    (0,_string__WEBPACK_IMPORTED_MODULE_3__.setMimetypeFromCellType)(source, base, nbMimetype);
    subDiff = (0,_util__WEBPACK_IMPORTED_MODULE_2__.getSubDiffByKey)(diff, 'metadata');
    metadata = subDiff
        ? (0,_string__WEBPACK_IMPORTED_MODULE_3__.createPatchStringDiffModel)(base.metadata, subDiff)
        : (0,_string__WEBPACK_IMPORTED_MODULE_3__.createDirectStringDiffModel)(base.metadata, base.metadata);
    if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isCode(base)) {
        let outputsBase = base.outputs;
        let outputsDiff = (0,_util__WEBPACK_IMPORTED_MODULE_2__.getSubDiffByKey)(diff, 'outputs');
        if (outputsDiff) {
            // Outputs patched
            outputs = (0,_output__WEBPACK_IMPORTED_MODULE_4__.makeOutputModels)(outputsBase, null, outputsDiff);
        }
        else {
            // Outputs unchanged
            outputs = (0,_output__WEBPACK_IMPORTED_MODULE_4__.makeOutputModels)(outputsBase, outputsBase);
        }
        let execBase = base.execution_count;
        let execDiff = (0,_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(diff, 'execution_count');
        // Pass base as remote, which means fall back to unchanged if no diff:
        executionCount = (0,_immutable__WEBPACK_IMPORTED_MODULE_5__.createImmutableModel)(execBase, execBase, execDiff);
    }
    let idBase = base.id;
    let idDiff = (0,_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(diff, 'id');
    const idModel = (0,_immutable__WEBPACK_IMPORTED_MODULE_5__.createImmutableModel)(idBase, idBase, idDiff);
    return new CellDiffModel(source, metadata, outputs, executionCount, base.cell_type, idModel);
}
function createUnchangedCellDiffModel(base, nbMimetype) {
    let source = (0,_string__WEBPACK_IMPORTED_MODULE_3__.createDirectStringDiffModel)(base.source, base.source);
    (0,_string__WEBPACK_IMPORTED_MODULE_3__.setMimetypeFromCellType)(source, base, nbMimetype);
    let metadata = (0,_string__WEBPACK_IMPORTED_MODULE_3__.createDirectStringDiffModel)(base.metadata, base.metadata);
    let outputs = null;
    let executionCount = null;
    if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isCode(base)) {
        outputs = (0,_output__WEBPACK_IMPORTED_MODULE_4__.makeOutputModels)(base.outputs, base.outputs);
        let execBase = base.execution_count;
        executionCount = (0,_immutable__WEBPACK_IMPORTED_MODULE_5__.createImmutableModel)(execBase, execBase);
    }
    else {
        // markdown or raw cell
    }
    let idBase = base.id;
    const idModel = (0,_immutable__WEBPACK_IMPORTED_MODULE_5__.createImmutableModel)(idBase, idBase);
    return new CellDiffModel(source, metadata, outputs, executionCount, base.cell_type, idModel);
}
function createAddedCellDiffModel(remote, nbMimetype) {
    let source = (0,_string__WEBPACK_IMPORTED_MODULE_3__.createDirectStringDiffModel)(null, remote.source);
    (0,_string__WEBPACK_IMPORTED_MODULE_3__.setMimetypeFromCellType)(source, remote, nbMimetype);
    let metadata = (0,_string__WEBPACK_IMPORTED_MODULE_3__.createDirectStringDiffModel)(null, remote.metadata);
    let outputs = null;
    let executionCount = null;
    if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isCode(remote)) {
        outputs = (0,_output__WEBPACK_IMPORTED_MODULE_4__.makeOutputModels)(null, remote.outputs);
        executionCount = (0,_immutable__WEBPACK_IMPORTED_MODULE_5__.createImmutableModel)(null, remote.execution_count);
    }
    let idRemote = remote.id;
    const idModel = (0,_immutable__WEBPACK_IMPORTED_MODULE_5__.createImmutableModel)(null, idRemote);
    return new CellDiffModel(source, metadata, outputs, executionCount, remote.cell_type, idModel);
}
function createDeletedCellDiffModel(base, nbMimetype) {
    let source = (0,_string__WEBPACK_IMPORTED_MODULE_3__.createDirectStringDiffModel)(base.source, null);
    (0,_string__WEBPACK_IMPORTED_MODULE_3__.setMimetypeFromCellType)(source, base, nbMimetype);
    let metadata = (0,_string__WEBPACK_IMPORTED_MODULE_3__.createDirectStringDiffModel)(base.metadata, null);
    let outputs = null;
    let executionCount = null;
    if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isCode(base)) {
        outputs = (0,_output__WEBPACK_IMPORTED_MODULE_4__.makeOutputModels)(base.outputs, null);
        let execBase = base.execution_count;
        executionCount = (0,_immutable__WEBPACK_IMPORTED_MODULE_5__.createImmutableModel)(execBase, null);
    }
    let idBase = base.id;
    const idModel = (0,_immutable__WEBPACK_IMPORTED_MODULE_5__.createImmutableModel)(idBase, null);
    return new CellDiffModel(source, metadata, outputs, executionCount, base.cell_type, idModel);
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/model/common.js":
/*!******************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/model/common.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/***/ }),

/***/ "./node_modules/nbdime/lib/diff/model/immutable.js":
/*!*********************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/model/immutable.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImmutableDiffModel: () => (/* binding */ ImmutableDiffModel),
/* harmony export */   createImmutableModel: () => (/* binding */ createImmutableModel)
/* harmony export */ });
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * Standard implementation of the IStringDiffModel interface.
 */
class ImmutableDiffModel {
    /**
     * ImmutableDiffModel constructor.
     *
     * `collapsible` and `collapsed` both defaults to false.
     */
    constructor(base, remote, collapsible, header, collapsed) {
        this.base = base;
        this.remote = remote;
        this.collapsible = collapsible === true;
        if (this.collapsible) {
            this.collapsibleHeader = header ? header : '';
            this.startCollapsed = collapsed === true;
        }
    }
    get unchanged() {
        return this.base === this.remote;
    }
    get added() {
        return this.base === undefined;
    }
    get deleted() {
        return this.remote === undefined;
    }
}
/**
 * Create an ImmutableDiffModel from a base value, a remote value, and a single diff entry.
 *
 * Note: The requirement of a single diff entry means it will not support
 * an add/replace pair on the same key, as this should instead be represented
 * by a 'replace' op.
 *
 * @export
 * @param {(ImmutableValue | undefined)} base : The base value
 * @param {(IDiffImmutableObjectEntry | null)} diff : The diff entry, or null if unchanged
 * @returns {ImmutableDiffModel}
 */
function createImmutableModel(base, remote, diff) {
    if (!diff) {
        return new ImmutableDiffModel(base, remote);
    }
    else if (diff.op === 'add') {
        if (base !== undefined) {
            throw new Error('Invalid diff op on immutable value');
        }
        return new ImmutableDiffModel(base, diff.value);
    }
    else if (diff.op === 'remove') {
        if (base === undefined) {
            throw new Error('Invalid diff op on immutable value');
        }
        return new ImmutableDiffModel(base, undefined);
    }
    else {
        // diff.op === 'replace'
        if (base === undefined) {
            throw new Error('Invalid diff op on immutable value');
        }
        return new ImmutableDiffModel(base, diff.value);
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/model/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/model/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellDiffModel: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.CellDiffModel),
/* harmony export */   ImmutableDiffModel: () => (/* reexport safe */ _immutable__WEBPACK_IMPORTED_MODULE_2__.ImmutableDiffModel),
/* harmony export */   NotebookDiffModel: () => (/* reexport safe */ _notebook__WEBPACK_IMPORTED_MODULE_3__.NotebookDiffModel),
/* harmony export */   OutputDiffModel: () => (/* reexport safe */ _output__WEBPACK_IMPORTED_MODULE_4__.OutputDiffModel),
/* harmony export */   RenderableDiffModel: () => (/* reexport safe */ _renderable__WEBPACK_IMPORTED_MODULE_5__.RenderableDiffModel),
/* harmony export */   StringDiffModel: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_6__.StringDiffModel),
/* harmony export */   createAddedCellDiffModel: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.createAddedCellDiffModel),
/* harmony export */   createDeletedCellDiffModel: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.createDeletedCellDiffModel),
/* harmony export */   createDirectStringDiffModel: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_6__.createDirectStringDiffModel),
/* harmony export */   createImmutableModel: () => (/* reexport safe */ _immutable__WEBPACK_IMPORTED_MODULE_2__.createImmutableModel),
/* harmony export */   createPatchStringDiffModel: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_6__.createPatchStringDiffModel),
/* harmony export */   createPatchedCellDiffModel: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.createPatchedCellDiffModel),
/* harmony export */   createUnchangedCellDiffModel: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.createUnchangedCellDiffModel),
/* harmony export */   makeOutputModels: () => (/* reexport safe */ _output__WEBPACK_IMPORTED_MODULE_4__.makeOutputModels),
/* harmony export */   setMimetypeFromCellType: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_6__.setMimetypeFromCellType)
/* harmony export */ });
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ "./node_modules/nbdime/lib/diff/model/cell.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/diff/model/common.js");
/* harmony import */ var _immutable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./immutable */ "./node_modules/nbdime/lib/diff/model/immutable.js");
/* harmony import */ var _notebook__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notebook */ "./node_modules/nbdime/lib/diff/model/notebook.js");
/* harmony import */ var _output__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./output */ "./node_modules/nbdime/lib/diff/model/output.js");
/* harmony import */ var _renderable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderable */ "./node_modules/nbdime/lib/diff/model/renderable.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string */ "./node_modules/nbdime/lib/diff/model/string.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.









/***/ }),

/***/ "./node_modules/nbdime/lib/diff/model/notebook.js":
/*!********************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/model/notebook.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotebookDiffModel: () => (/* binding */ NotebookDiffModel)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/nbdime/lib/diff/util.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string */ "./node_modules/nbdime/lib/diff/model/string.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cell */ "./node_modules/nbdime/lib/diff/model/cell.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * Diff model for a Jupyter Notebook
 */
class NotebookDiffModel {
    /**
     * Create a new NotebookDiffModel from a base notebook and a list of diffs.
     *
     * The base as well as the diff entries are normally supplied by the nbdime
     * server.
     */
    constructor(base, diff) {
        // Process global notebook metadata field
        let metaDiff = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getSubDiffByKey)(diff, 'metadata');
        if (base.metadata && metaDiff) {
            this.metadata = (0,_string__WEBPACK_IMPORTED_MODULE_1__.createPatchStringDiffModel)(base.metadata, metaDiff);
        }
        else {
            this.metadata = null;
        }
        if (this.metadata) {
            this.metadata.collapsible = true;
            this.metadata.collapsibleHeader = 'Notebook metadata changed';
            this.metadata.startCollapsed = true;
        }
        // The notebook metadata MIME type is used for determining the MIME type
        // of source cells, so store it easily accessible:
        let mimetype;
        try {
            mimetype = base.metadata.language_info.mimetype;
        }
        catch (e) {
            // missing metadata (probably old notebook)
        }
        this.mimetype = mimetype || 'text/python';
        // Build cell diff models. Follows similar logic to patching code:
        this.cells = [];
        this.chunkedCells = [];
        let take = 0;
        let skip = 0;
        let previousChunkIndex = -1;
        let currentChunk = [];
        for (let e of (0,_util__WEBPACK_IMPORTED_MODULE_0__.getSubDiffByKey)(diff, 'cells') || []) {
            let index = e.key;
            // diff is sorted on index, so take any preceding cells as unchanged:
            for (let i = take; i < index; i++) {
                let cell = (0,_cell__WEBPACK_IMPORTED_MODULE_2__.createUnchangedCellDiffModel)(base.cells[i], this.mimetype);
                this.cells.push(cell);
                this.chunkedCells.push([cell]);
            }
            if (index !== previousChunkIndex) {
                currentChunk = [];
                this.chunkedCells.push(currentChunk);
                previousChunkIndex = index;
            }
            // Process according to diff type:
            if (e.op === 'addrange') {
                // One or more inserted/added cells:
                for (let ei of e.valuelist) {
                    let cell = (0,_cell__WEBPACK_IMPORTED_MODULE_2__.createAddedCellDiffModel)(ei, this.mimetype);
                    this.cells.push(cell);
                    currentChunk.push(cell);
                }
                skip = 0;
            }
            else if (e.op === 'removerange') {
                // One or more removed/deleted cells:
                skip = e.length;
                for (let i = index; i < index + skip; i++) {
                    let cell = (0,_cell__WEBPACK_IMPORTED_MODULE_2__.createDeletedCellDiffModel)(base.cells[i], this.mimetype);
                    this.cells.push(cell);
                    currentChunk.push(cell);
                }
            }
            else if (e.op === 'patch') {
                // Ensure patches gets their own chunk, even if they share index:
                if (currentChunk.length > 0) {
                    currentChunk = [];
                    this.chunkedCells.push(currentChunk);
                }
                // A cell has changed:
                let cell = (0,_cell__WEBPACK_IMPORTED_MODULE_2__.createPatchedCellDiffModel)(base.cells[index], e.diff, this.mimetype);
                this.cells.push(cell);
                currentChunk.push(cell);
                skip = 1;
            }
            // Skip the specified number of elements, but never decrement take.
            // Note that take can pass index in diffs with repeated +/- on the
            // same index, i.e. [op_remove(index), op_add(index, value)]
            take = Math.max(take, index + skip);
        }
        // Take unchanged values at end
        for (let i = take; i < base.cells.length; i++) {
            let cell = (0,_cell__WEBPACK_IMPORTED_MODULE_2__.createUnchangedCellDiffModel)(base.cells[i], this.mimetype);
            this.cells.push(cell);
            this.chunkedCells.push([cell]);
        }
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/model/output.js":
/*!******************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/model/output.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutputDiffModel: () => (/* binding */ OutputDiffModel),
/* harmony export */   makeOutputModels: () => (/* binding */ makeOutputModels)
/* harmony export */ });
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/nbformat */ "webpack/sharing/consume/default/@jupyterlab/nbformat");
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/exceptions */ "./node_modules/nbdime/lib/common/exceptions.js");
/* harmony import */ var _renderable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderable */ "./node_modules/nbdime/lib/diff/model/renderable.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




const TEXT_MIMETYPES = [
    'text/plain',
    'application/vnd.jupyter.stdout',
    'application/vnd.jupyter.stderr',
];
/**
 * Diff model for single cell output entries.
 *
 * Can converted to a StringDiffModel via the method `stringify()`, which also
 * takes an optional argument `key` which specifies a subpath of the IOutput to
 * make the model from.
 */
class OutputDiffModel extends _renderable__WEBPACK_IMPORTED_MODULE_2__.RenderableDiffModel {
    /**
     * Checks whether the given mimetype is present in the output's mimebundle.
     * If so, it returns the path/key to that mimetype's data. If not present,
     * it returns null.
     *
     * See also: innerMimeType
     */
    hasMimeType(mimetype) {
        let outputs = this.base || this.remote;
        if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isStream(outputs) && TEXT_MIMETYPES.indexOf(mimetype) !== -1) {
            return 'text';
        }
        else if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isError(outputs)) {
            return 'traceback';
        }
        else if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isExecuteResult(outputs) ||
            _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isDisplayData(outputs)) {
            let data = outputs.data;
            if (mimetype in data) {
                return ['data', mimetype];
            }
        }
        return null;
    }
    /**
     * Returns the expected MIME type of the IOutput subpath specified by `key`,
     * as determined by the notebook format specification.
     *
     * Throws an error for unknown keys.
     *
     * See also: hasMimeType
     */
    innerMimeType(key) {
        let t = (this.base || this.remote).output_type;
        if ((t === 'stream' && key === 'text') ||
            (t === 'error' && key === 'traceback')) {
            // TODO: 'application/vnd.jupyter.console-text'?
            return 'text/plain';
        }
        else if ((t === 'execute_result' || t === 'display_data') &&
            Array.isArray(key)) {
            return key[1];
        }
        throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_1__.NotifyUserError('Unknown MIME type for key: ' + key);
    }
    /**
     * Can be converted to a StringDiffModel via the method `stringify()`, which also
     * takes an optional argument `key` which specifies a subpath of the IOutput to
     * make the model from.
     */
    stringify(key) {
        let model = super.stringify(key);
        if (key) {
            model.mimetype = this.innerMimeType(key);
        }
        return model;
    }
}
/**
 * Function used to create a list of models for a list diff
 *
 * - If base and remote are both non-null and equal, it returns
 *   a list of models representing unchanged entries.
 * - If base and a diff is given, it ignores remote and returns
 *   a list of models representing the diff.
 * - If base is null, it returns a list of models representing
 *   added entries.
 * - If remote is null, it returns a list of models representing
 *   deleted entries.
 */
function makeOutputModels(base, remote, diff) {
    let models = [];
    if (remote === null && !diff) {
        if (base === null) {
            throw new Error('Either base or remote need to be specififed!');
        }
        // Cell deleted
        for (let o of base) {
            models.push(new OutputDiffModel(o, null));
        }
    }
    else if (base === null) {
        if (remote === null) {
            throw new Error('Either base or remote need to be specififed!');
        }
        // Cell added
        for (let o of remote) {
            models.push(new OutputDiffModel(null, o));
        }
    }
    else if (remote === base) {
        // All entries unchanged
        for (let o of base) {
            models.push(new OutputDiffModel(o, o));
        }
    }
    else if (diff) {
        // Entries patched, remote will be null
        let consumed = 0;
        let skip = 0;
        for (let d of diff) {
            let index = d.key;
            for (let o of base.slice(consumed, index)) {
                // Add unchanged entries
                models.push(new OutputDiffModel(o, o));
            }
            if (d.op === 'addrange') {
                // Entries added
                for (let o of d.valuelist) {
                    models.push(new OutputDiffModel(null, o));
                }
                skip = 0;
            }
            else if (d.op === 'removerange') {
                // Entries removed
                let len = d.length;
                for (let i = index; i < index + len; i++) {
                    models.push(new OutputDiffModel(base[i], null));
                }
                skip = len;
            }
            else if (d.op === 'patch') {
                // Entry changed
                models.push(new OutputDiffModel(base[index], null, d.diff));
                skip = 1;
            }
            else {
                throw new Error('Invalid diff operation: ' + d);
            }
            consumed = Math.max(consumed, index + skip);
        }
        for (let o of base.slice(consumed)) {
            // Add unchanged entries
            models.push(new OutputDiffModel(o, o));
        }
    }
    else {
        throw new Error('Invalid arguments to makeOutputModels()');
    }
    return models;
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/model/renderable.js":
/*!**********************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/model/renderable.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderableDiffModel: () => (/* binding */ RenderableDiffModel)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ "./node_modules/nbdime/lib/diff/util.js");
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../patch */ "./node_modules/nbdime/lib/patch/index.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string */ "./node_modules/nbdime/lib/diff/model/string.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/**
 * Diff model for a renderable object (something that has an internal MimeBundle)
 *
 * Can be converted to a StringDiffModel via the method `stringify()`, which also
 * takes an optional argument `key` which specifies a subpath of the IOutput to
 * make the model from.
 */
class RenderableDiffModel {
    constructor(base, remote, diff) {
        this.trustedChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        if (!remote && !base) {
            throw new Error('Either remote or base value need to be given');
        }
        this.base = base;
        if (!remote && diff) {
            this.remote = (0,_patch__WEBPACK_IMPORTED_MODULE_3__.patch)(base, diff);
        }
        else {
            this.remote = remote;
        }
        this.diff = diff || null;
        this.collapsible = false;
    }
    get unchanged() {
        return JSON.stringify(this.base) === JSON.stringify(this.remote);
    }
    get added() {
        return this.base === null;
    }
    get deleted() {
        return this.remote === null;
    }
    /**
     * Convert to a StringDiffModel.
     *
     * Takes an optional argument `key` which specifies a subpath of the MimeBundle to
     * make the model from.
     */
    stringify(key) {
        let getMemberByPath = function (obj, key, f) {
            if (!obj) {
                return obj;
            }
            if (Array.isArray(key)) {
                const tail = key.length > 2 ? key.slice(1) : key[1];
                if (f) {
                    return getMemberByPath(f(obj, key[0]), tail, f);
                }
                return getMemberByPath(obj[key[0]], tail, f);
            }
            else if (f) {
                return f(obj, key);
            }
            return obj[key];
        };
        const baseCopy = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(this.base);
        let base = key ? getMemberByPath(baseCopy, key) : baseCopy;
        const remoteCopy = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(this.remote);
        let remote = key ? getMemberByPath(remoteCopy, key) : remoteCopy;
        let diff = this.diff && key
            ? getMemberByPath(this.diff, key, _util__WEBPACK_IMPORTED_MODULE_2__.getSubDiffByKey)
            : this.diff;
        let model = null;
        if (this.unchanged || this.added || this.deleted || !diff) {
            model = (0,_string__WEBPACK_IMPORTED_MODULE_4__.createDirectStringDiffModel)(base, remote);
        }
        else {
            model = (0,_string__WEBPACK_IMPORTED_MODULE_4__.createPatchStringDiffModel)(base, diff);
        }
        model.mimetype = key ? this.innerMimeType(key) : 'application/json';
        model.collapsible = this.collapsible;
        model.collapsibleHeader = this.collapsibleHeader;
        model.startCollapsed = this.startCollapsed;
        return model;
    }
    /**
     * Whether outputs are trusted
     */
    get trusted() {
        return this._trusted;
    }
    set trusted(value) {
        if (this._trusted !== value) {
            this._trusted = value;
            this.trustedChanged.emit(value);
        }
    }
    /**
     * The present values of model.base/remote
     */
    get contents() {
        let ret = [];
        if (this.base) {
            ret.push(this.base);
        }
        if (this.remote && this.remote !== this.base) {
            ret.push(this.remote);
        }
        return ret;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/model/string.js":
/*!******************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/model/string.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringDiffModel: () => (/* binding */ StringDiffModel),
/* harmony export */   createDirectStringDiffModel: () => (/* binding */ createDirectStringDiffModel),
/* harmony export */   createPatchStringDiffModel: () => (/* binding */ createPatchStringDiffModel),
/* harmony export */   setMimetypeFromCellType: () => (/* binding */ setMimetypeFromCellType)
/* harmony export */ });
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/nbformat */ "webpack/sharing/consume/default/@jupyterlab/nbformat");
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../range */ "./node_modules/nbdime/lib/diff/range.js");
/* harmony import */ var _chunking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chunking */ "./node_modules/nbdime/lib/chunking/index.js");
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../patch */ "./node_modules/nbdime/lib/patch/index.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/**
 * Standard implementation of the IStringDiffModel interface.
 */
class StringDiffModel {
    /**
     * StringDiffModel constructor.
     *
     * Will translate additions and deletions from absolute
     * coordinates, into {line, ch} based coordinates.
     * Both should be sorted on the `from` position before passing.
     *
     * Collapsible and collapsed both defaults to false.
     */
    constructor(base, remote, additions, deletions, collapsible, header, collapsed) {
        this.base = base;
        this._remote = remote;
        if (base === null) {
            console.assert(deletions.length === 0);
            this.deletions = [];
        }
        else {
            this.deletions = (0,_range__WEBPACK_IMPORTED_MODULE_2__.raw2Pos)(deletions, base);
        }
        if (remote === null) {
            console.assert(additions.length === 0);
            this.additions = [];
        }
        else {
            this.additions = (0,_range__WEBPACK_IMPORTED_MODULE_2__.raw2Pos)(additions, remote);
        }
        this.collapsible = collapsible === true;
        if (this.collapsible) {
            this.collapsibleHeader = header ? header : '';
            this.startCollapsed = collapsed === true;
        }
    }
    iterateDiffs() {
        return new StringDiffModel.DiffIter(this);
    }
    /**
     * Chunk additions/deletions into line-based chunks
     */
    getLineChunks() {
        let chunker = new _chunking__WEBPACK_IMPORTED_MODULE_3__.LineChunker();
        let i = this.iterateDiffs();
        for (let v = i.next(); v !== undefined; v = i.next()) {
            chunker.addDiff(v.range, v.isAddition);
        }
        return chunker.chunks;
    }
    get remote() {
        return this._remote;
    }
    set remote(value) {
        this._remote = value;
    }
    get unchanged() {
        return this.base === this.remote;
    }
    get added() {
        return this.base === null;
    }
    get deleted() {
        return this.remote === null;
    }
    get additions() {
        return this._additions;
    }
    set additions(value) {
        this._additions = value;
    }
    get deletions() {
        return this._deletions;
    }
    set deletions(value) {
        this._deletions = value;
    }
}
(function (StringDiffModel) {
    class DiffIter {
        constructor(model) {
            this.editOffset = 0;
            this.done = false;
            this.ia = 0;
            this.id = 0;
            this.hintTakeDeletion = false;
            this.model = model;
        }
        next() {
            // Figure out which element to take next
            let isAddition = null;
            let range = null;
            let additions = this.model.additions;
            let deletions = this.model.deletions;
            let hintTakeDeletion = this.hintTakeDeletion;
            this.hintTakeDeletion = false;
            if (this.ia < this.model.additions.length) {
                if (this.id < deletions.length) {
                    let ra = additions[this.ia];
                    let rd = deletions[this.id];
                    if (ra.from.line === rd.from.line - this.editOffset &&
                        ra.from.column === rd.from.column) {
                        // An addition and deletion start at seemingly same location
                        // Take addition, and flag to ensure deletion gets taken next
                        if (hintTakeDeletion) {
                            isAddition = false;
                        }
                        else {
                            this.hintTakeDeletion = true;
                            isAddition = true;
                        }
                    }
                    else if (ra.from.line < rd.from.line - this.editOffset ||
                        (ra.from.line === rd.from.line - this.editOffset &&
                            ra.from.column < rd.from.column)) {
                        // TODO: Character editOffset should also be used
                        isAddition = true;
                    }
                    else {
                        isAddition = false;
                    }
                }
                else {
                    // No more deletions
                    isAddition = true;
                }
            }
            else if (this.id < deletions.length) {
                // No more additions
                isAddition = false;
            }
            else {
                // Out of ranges!
                this.done = true;
                return undefined;
            }
            if (isAddition) {
                range = additions[this.ia++];
            }
            else {
                range = deletions[this.id++];
            }
            let linediff = range.to.line - range.from.line;
            if (range.endsOnNewline) {
                linediff += 1;
            }
            this.editOffset += isAddition ? -linediff : linediff;
            return { range: range, isAddition: isAddition };
        }
    }
    StringDiffModel.DiffIter = DiffIter;
    class SyncedDiffIter {
        static cmp(a, b, offsetA, offsetB) {
            if (a === undefined && b === undefined) {
                return 0;
            }
            else if (a === undefined) {
                return 1;
            }
            else if (b === undefined) {
                return -1;
            }
            let lineA = a.range.from.line + (a.isAddition ? offsetA : 0);
            let lineB = b.range.from.line + (b.isAddition ? offsetB : 0);
            if (lineA < lineB || a.range.from.column < b.range.from.column) {
                return -1;
            }
            else if (lineA > lineB || a.range.from.column > b.range.from.column) {
                return 1;
            }
            else {
                return 0;
            }
        }
        constructor(models) {
            this.currentOffset = 0;
            this.models = [];
            this.iterators = [];
            this.values = [];
            this.offsets = [];
            // Set up iterator and dummy chunkers for other models
            for (let m of models) {
                if (m === null) {
                    continue;
                }
                this.models.push(m);
                let it = m.iterateDiffs();
                this.iterators.push(it);
                this.offsets.push(0);
                this.values.push(it.next());
            }
        }
        next() {
            // Compare in base index to see which diff is next
            let i = 0;
            for (let j = 1; j < this.values.length; ++j) {
                if (0 >
                    SyncedDiffIter.cmp(this.values[j], this.values[i], this.iterators[j].editOffset, this.iterators[i].editOffset)) {
                    i = j;
                }
            }
            this.i = i;
            let ret = this.values[i];
            // Store the edit offset before taking next value
            this.currentOffset = this.offsets[i];
            this.offsets[i] = this.iterators[i].editOffset;
            // Check if complete
            if (ret !== undefined) {
                this.values[i] = this.iterators[i].next();
            }
            return ret;
        }
        currentModel() {
            return this.models[this.i];
        }
    }
    StringDiffModel.SyncedDiffIter = SyncedDiffIter;
})(StringDiffModel || (StringDiffModel = {}));
/**
 * Creates a StringDiffModel based on a patch operation.
 *
 * If base is not a string, it is assumed to be a JSON object/array,
 * and it will be stringified according to JSON stringification
 * rules.
 */
function createPatchStringDiffModel(base, diff) {
    console.assert(!!diff, 'Patch model needs diff.');
    const baseCopy = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepCopy(base);
    let baseStr = (0,_patch__WEBPACK_IMPORTED_MODULE_4__.stringifyAndBlankNull)(baseCopy);
    let out = (0,_patch__WEBPACK_IMPORTED_MODULE_4__.patchStringified)(baseCopy, diff);
    return new StringDiffModel(baseStr, out.remote, out.additions, out.deletions);
}
/**
 * Factory for creating cell diff models for added, removed or unchanged content.
 *
 * If base is null, it will be treated as added, if remote is null it will be
 * treated as removed. Otherwise base and remote should be equal, represeting
 * unchanged content.
 */
function createDirectStringDiffModel(base, remote) {
    let baseStr = (0,_patch__WEBPACK_IMPORTED_MODULE_4__.stringifyAndBlankNull)(base);
    let remoteStr = (0,_patch__WEBPACK_IMPORTED_MODULE_4__.stringifyAndBlankNull)(remote);
    let additions = [];
    let deletions = [];
    if (base === null && remote === null) {
        throw new Error('Invalid arguments to createDirectStringDiffModel(). ' +
            'Both base and remote cannot be equal!');
    }
    else if (base === null) {
        // Added cell
        baseStr = null;
        additions.push(new _range__WEBPACK_IMPORTED_MODULE_2__.DiffRangeRaw(0, remoteStr.length, undefined));
    }
    else if (remote === null) {
        // Deleted cell
        remoteStr = null;
        deletions.push(new _range__WEBPACK_IMPORTED_MODULE_2__.DiffRangeRaw(0, baseStr.length, undefined));
    }
    else if (remoteStr !== baseStr) {
        throw new Error('Invalid arguments to createDirectStringDiffModel(). ' +
            'Either base or remote should be null, or they should be equal!');
    }
    return new StringDiffModel(baseStr, remoteStr, additions, deletions);
}
/**
 * Assign MIME type to an IStringDiffModel based on the cell type.
 *
 * The parameter nbMimetype is the MIME type set for the entire notebook, and is
 * used as the MIME type for code cells.
 */
function setMimetypeFromCellType(model, cell, nbMimetype) {
    if (cell.cell_type === 'code') {
        model.mimetype = nbMimetype;
    }
    else if (cell.cell_type === 'markdown') {
        model.mimetype = 'text/markdown';
    }
    else if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isRaw(cell)) {
        model.mimetype = cell.metadata.format || 'text/plain';
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/range.js":
/*!***********************************************!*\
  !*** ./node_modules/nbdime/lib/diff/range.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DiffRangePos: () => (/* binding */ DiffRangePos),
/* harmony export */   DiffRangeRaw: () => (/* binding */ DiffRangeRaw),
/* harmony export */   offsetToPos: () => (/* binding */ offsetToPos),
/* harmony export */   posToOffset: () => (/* binding */ posToOffset),
/* harmony export */   raw2Pos: () => (/* binding */ raw2Pos)
/* harmony export */ });
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * Represents a range in a diff (typically in a string), in absolute indices (1D)
 */
class DiffRangeRaw {
    /**
     * Create a new range [from, to = from + length)
     */
    constructor(from, length, source) {
        this.from = from;
        this.to = from + length;
        this.source = source;
    }
    /**
     * Change both `from` and `to` fields by the given offset
     */
    offset(offset) {
        this.from += offset;
        this.to += offset;
    }
}
/**
 * Class representing a string (diff) range in the format of
 * CodeMirror.Positions. Mainly makes sense for string diffs.
 *
 * The class also has fields to ease chunking of diffs without reparsing the
 * text.
 */
class DiffRangePos {
    /**
     * Create a diff range. The `ch` field of the `to` position is defined as
     * non-inclusive, i.e., it follows the syntax of String.slice().
     */
    constructor(from, to, chunkStartLine, endsOnNewline) {
        this.from = from;
        this.to = to;
        this.chunkStartLine = chunkStartLine === true;
        this.endsOnNewline = endsOnNewline === true;
    }
}
/**
 * Utility function to find the line number of a given string index,
 * given the positions of all newlines.
 */
function findLineNumber(nlPos, index) {
    if (nlPos.length === 0) {
        return 0;
    }
    let lineNo = null;
    nlPos.some(function (el, i) {
        if (el >= index) {
            lineNo = i;
            return true;
        }
        return false;
    });
    if (lineNo === null) {
        return nlPos.length;
    }
    return lineNo;
}
function posToOffset(doc, pos) {
    return doc.line(pos.line + 1).from + pos.column;
}
function offsetToPos(doc, offset) {
    let line = doc.lineAt(offset);
    return { line: line.number - 1, column: offset - line.from };
}
/**
 * Function to convert an array of DiffRangeRaw to DiffRangePos. The
 * `text` parameter is the text in which the ranges exist.
 */
function raw2Pos(raws, text) {
    // Find all newline's indices in text
    let adIdx = [];
    let i = -1;
    while (-1 !== (i = text.indexOf('\n', i + 1))) {
        adIdx.push(i);
    }
    let result = [];
    // Find line numbers from raw index
    for (let r of raws) {
        // First `from` position:
        let line = findLineNumber(adIdx, r.from);
        let lineStartIdx = line > 0 ? adIdx[line - 1] + 1 : 0;
        let from = {
            line: line,
            column: r.from - lineStartIdx,
        };
        // Then `to` position:
        line = findLineNumber(adIdx, r.to - 1); // `to` is non-inclusive
        lineStartIdx = line > 0 ? adIdx[line - 1] + 1 : 0;
        let to = { line: line, column: r.to - lineStartIdx };
        // Finally, add some chunking hints:
        let startsOnNewLine = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(r.from, adIdx);
        let endsOnNewline = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(r.to - 1, adIdx); // non-inclusive
        let firstLineNew = from.column === 0 &&
            (from.line !== to.line || endsOnNewline || r.to === text.length);
        let chunkFirstLine = firstLineNew ||
            !startsOnNewLine ||
            // Neither preceding nor following character is a newline
            (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(r.from - 1, adIdx) && !(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(r.to, adIdx));
        let pos = new DiffRangePos(from, to, chunkFirstLine, endsOnNewline);
        pos.source = r.source;
        result.push(pos);
    }
    return result;
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/util.js":
/*!**********************************************!*\
  !*** ./node_modules/nbdime/lib/diff/util.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JSON_INDENT: () => (/* binding */ JSON_INDENT),
/* harmony export */   flattenStringDiff: () => (/* binding */ flattenStringDiff),
/* harmony export */   getDiffEntryByKey: () => (/* binding */ getDiffEntryByKey),
/* harmony export */   getSubDiffByKey: () => (/* binding */ getSubDiffByKey),
/* harmony export */   stripSource: () => (/* binding */ stripSource)
/* harmony export */ });
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _diffentries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diffentries */ "./node_modules/nbdime/lib/diff/diffentries.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The indentation to use for JSON stringify.
 */
const JSON_INDENT = '  ';
/**
 * Search the list of diffs for an entry with the given key.
 *
 * Returns the first found entry, or null if not entry was found.
 */
function getSubDiffByKey(diff, key) {
    if (!diff) {
        return null;
    }
    for (let i = 0; i < diff.length; ++i) {
        if (diff[i].key === key) {
            return diff[i].diff || null;
        }
    }
    return null;
}
/**
 * Search the list of diffs for an entry with the given key.
 *
 * Returns the first found entry, or null if not entry was found.
 */
function getDiffEntryByKey(diff, key) {
    if (!diff) {
        return null;
    }
    for (let i = 0; i < diff.length; ++i) {
        if (diff[i].key === key) {
            return diff[i];
        }
    }
    return null;
}
function validateStringDiff(base, entry, lineToChar) {
    // First valdiate line ops:
    (0,_diffentries__WEBPACK_IMPORTED_MODULE_1__.validateSequenceOp)(base, entry);
    if (entry.op === 'patch') {
        let line = base[entry.key];
        let diff = entry.diff;
        if (diff !== null) {
            for (let d of diff) {
                (0,_diffentries__WEBPACK_IMPORTED_MODULE_1__.validateSequenceOp)(line, d);
            }
        }
    }
}
/**
 * Remove the merge source indicator from a diff (returns a copy).
 */
function stripSource(diff) {
    if (!diff) {
        return null;
    }
    let ret = [];
    for (let e of diff) {
        if (e.op === 'patch') {
            ret.push({
                key: e.key,
                op: e.op,
                diff: stripSource(e.diff),
            });
        }
        else {
            let d = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.shallowCopy)(e);
            delete d.source;
            ret.push(d);
        }
    }
    return ret;
}
/**
 * Translates a diff of strings split by str.splitlines() to a diff of the
 * joined multiline string
 */
function flattenStringDiff(val, diff) {
    if (typeof val === 'string') {
        val = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.splitLines)(val);
    }
    let lineToChar = [0].concat((0,_common_util__WEBPACK_IMPORTED_MODULE_0__.accumulateLengths)(val));
    let flattened = [];
    for (let e of diff) {
        // Frist validate op:
        validateStringDiff(val, e, lineToChar);
        let lineOffset = lineToChar[e.key];
        if (e.op === 'patch') {
            let pdiff = e.diff;
            if (pdiff !== null) {
                for (let p of pdiff) {
                    let d = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.shallowCopy)(p);
                    d.key += lineOffset;
                    flattened.push(d);
                }
            }
        }
        else {
            // Other ops simply have keys which refer to lines
            let d = null;
            if (e.op === 'addrange') {
                d = (0,_diffentries__WEBPACK_IMPORTED_MODULE_1__.opAddRange)(lineOffset, e.valuelist.join(''));
            }
            else {
                // e.op === 'removerange'
                let idx = e.key + e.length;
                d = (0,_diffentries__WEBPACK_IMPORTED_MODULE_1__.opRemoveRange)(lineOffset, lineToChar[idx] - lineOffset);
            }
            d.source = e.source;
            flattened.push(d);
        }
    }
    // Finally, sort on key (leaving equal items in original order)
    // This is done since the original diffs are sorted deeper first!
    return (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.sortByKey)(flattened, 'key');
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/widget/cell.js":
/*!*****************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/widget/cell.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CELLDIFF_CLASS: () => (/* binding */ CELLDIFF_CLASS),
/* harmony export */   CellDiffWidget: () => (/* binding */ CellDiffWidget),
/* harmony export */   OUTPUTS_DIFF_CLASS: () => (/* binding */ OUTPUTS_DIFF_CLASS)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/rendermime */ "webpack/sharing/consume/default/@jupyterlab/rendermime");
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_basepanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/basepanel */ "./node_modules/nbdime/lib/common/basepanel.js");
/* harmony import */ var _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/collapsiblepanel */ "./node_modules/nbdime/lib/common/collapsiblepanel.js");
/* harmony import */ var _common_mergeview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/mergeview */ "./node_modules/nbdime/lib/common/mergeview.js");
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../upstreaming/flexpanel */ "./node_modules/nbdime/lib/upstreaming/flexpanel.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../model */ "./node_modules/nbdime/lib/diff/model/index.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/diff/widget/common.js");
/* harmony import */ var _output__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./output */ "./node_modules/nbdime/lib/diff/widget/output.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.











/**
 * The class name added to the prompt area of cell.
 */
const PROMPT_CLASS = 'jp-InputPrompt';
const CELLDIFF_CLASS = 'jp-Cell-diff';
const OUTPUTS_DIFF_CLASS = 'jp-Diff-outputsContainer';
const EXECUTION_COUNT_CLASS = 'jp-Cellrow-header-executionCount';
const CELL_ID_CLASS = 'jp-Cellrow-header-cellId';
const HEADER_ROW_CLASS = 'jp-Cellrow-header';
const SOURCE_ROW_CLASS = 'jp-Cellrow-source';
const METADATA_ROW_CLASS = 'jp-Cellrow-metadata';
const OUTPUTS_ROW_CLASS = 'jp-Cellrow-outputs';
/**
 * CellDiffWidget for cell changes
 */
class CellDiffWidget extends _common_basepanel__WEBPACK_IMPORTED_MODULE_2__.DiffPanel {
    /**
     *
     */
    constructor({ rendermime, mimetype, ...others }) {
        super(others);
        this.addClass(CELLDIFF_CLASS);
        this._rendermime = rendermime;
        this._trans = this._translator.load('nbdime');
        this.mimetype = mimetype;
        this.init();
    }
    init() {
        let model = this.model;
        // Add 'cell added/deleted' notifiers, as appropriate
        let CURR_DIFF_CLASSES = _common__WEBPACK_IMPORTED_MODULE_8__.DIFF_CLASSES.slice(); // copy
        if (model.added) {
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.ADDED_DIFF_CLASS);
            CURR_DIFF_CLASSES = _common__WEBPACK_IMPORTED_MODULE_8__.DIFF_CLASSES.slice(1, 2);
        }
        else if (model.deleted) {
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.DELETED_DIFF_CLASS);
            CURR_DIFF_CLASSES = _common__WEBPACK_IMPORTED_MODULE_8__.DIFF_CLASSES.slice(0, 1);
        }
        else if (model.unchanged) {
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.UNCHANGED_DIFF_CLASS);
        }
        else {
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.TWOWAY_DIFF_CLASS);
        }
        // Add inputs and outputs, on a row-by-row basis
        let sourceView = CellDiffWidget.createView({
            model: model.source,
            parent: model,
            editorClasses: CURR_DIFF_CLASSES,
            rendermime: this._rendermime,
            editorFactory: this._editorFactory,
            translator: this._translator,
            ...this._viewOptions,
        });
        sourceView.addClass(SOURCE_ROW_CLASS);
        if (model.executionCount || model.cellId) {
            const createWidget = (text) => {
                let w = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget();
                w.node.innerText = text;
                return w;
            };
            const header = CellDiffWidget.createHeader();
            _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_6__.FlexPanel.setGrow(header, 1);
            sourceView.insertWidget(0, header);
            const prompts = model.executionCount
                ? CellDiffWidget.createPrompts(model.executionCount, model)
                : { base: null, remote: null };
            const ids = model.cellId
                ? CellDiffWidget.createIdentifiers(model.cellId, model)
                : { base: null, remote: null };
            const views = ['base', 'remote'];
            for (let side of views) {
                const prompt = prompts[side];
                const id = ids[side];
                if (model.executionCount && prompt !== null) {
                    let w = createWidget(prompt);
                    w.addClass(PROMPT_CLASS);
                    w.addClass(EXECUTION_COUNT_CLASS);
                    header.addWidget(w);
                }
                if (model.cellId && id !== null) {
                    let w = createWidget(`Cell ID: ${id}`);
                    w.addClass(CELL_ID_CLASS);
                    _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_6__.FlexPanel.setGrow(w, 1);
                    header.addWidget(w);
                }
            }
        }
        this.addWidget(sourceView);
        if (!model.metadata.unchanged) {
            let metadataView = CellDiffWidget.createView({
                model: model.metadata,
                parent: model,
                editorClasses: CURR_DIFF_CLASSES,
                rendermime: this._rendermime,
                editorFactory: this._editorFactory,
                translator: this._translator,
                ...this._viewOptions,
            });
            metadataView.addClass(METADATA_ROW_CLASS);
            this.addWidget(metadataView);
        }
        const chunks = model.getChunkedOutputs();
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_5__.hasEntries)(chunks)) {
            let container = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
            container.addClass(OUTPUTS_DIFF_CLASS);
            let changed = false;
            for (let chunk of chunks) {
                if (chunk.length === 1) {
                    let o = chunk[0];
                    let outputsWidget = CellDiffWidget.createView({
                        model: o,
                        parent: model,
                        editorClasses: CURR_DIFF_CLASSES,
                        rendermime: this._rendermime,
                        editorFactory: this._editorFactory,
                        translator: this._translator,
                        ...this._viewOptions,
                    });
                    container.addWidget(outputsWidget);
                    changed = changed || !o.unchanged || o.added || o.deleted;
                }
                else {
                    // Create add/remove chunk wrappers
                    let chunkPanel = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
                    chunkPanel.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.CHUNK_PANEL_CLASS);
                    let addedPanel = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
                    addedPanel.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.ADDED_CHUNK_PANEL_CLASS);
                    let removedPanel = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
                    removedPanel.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.REMOVED_CHUNK_PANEL_CLASS);
                    for (let o of chunk) {
                        let target = o.deleted ? removedPanel : addedPanel;
                        let outputsWidget = CellDiffWidget.createView({
                            model: o,
                            parent: model,
                            editorClasses: CURR_DIFF_CLASSES,
                            rendermime: this._rendermime,
                            editorFactory: this._editorFactory,
                            translator: this._translator,
                            ...this._viewOptions,
                        });
                        target.addWidget(outputsWidget);
                        changed = changed || !o.unchanged || o.added || o.deleted;
                    }
                    chunkPanel.addWidget(addedPanel);
                    chunkPanel.addWidget(removedPanel);
                    container.addWidget(chunkPanel);
                }
            }
            if (model.added || model.deleted) {
                container.addClass(OUTPUTS_ROW_CLASS);
                this.addWidget(container);
            }
            else {
                let collapsed = !changed;
                let header = changed
                    ? this._trans.__('Outputs changed')
                    : this._trans.__('Outputs unchanged');
                let collapser = new _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_3__.CollapsiblePanel(container, header, collapsed);
                collapser.addClass(OUTPUTS_ROW_CLASS);
                this.addWidget(collapser);
            }
        }
    }
    static createHeader() {
        let container = new _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_6__.FlexPanel({ direction: 'left-to-right' });
        container.addClass(HEADER_ROW_CLASS);
        return container;
    }
    static createPrompts(model, parent) {
        const prompts = {
            base: null,
            remote: null,
        };
        if (!parent.added) {
            let base = model.base;
            prompts.base = `In [${base || ' '}]:`;
        }
        if (!parent.unchanged && !parent.deleted) {
            let remote = model.remote;
            prompts.remote = `In [${remote || ' '}]:`;
        }
        return prompts;
    }
    static createIdentifiers(model, parent) {
        return {
            base: model.base,
            remote: model.remote,
        };
    }
    /**
     * Create a new sub-view.
     */
    static createView({ model, parent, editorClasses, rendermime, editorFactory, translator, ...viewOptions }) {
        let view;
        if (model instanceof _model__WEBPACK_IMPORTED_MODULE_7__.StringDiffModel) {
            let inner = null;
            if (model.unchanged && parent.cellType === 'markdown') {
                let mimeModel = new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__.MimeModel({
                    data: { 'text/markdown': model.base },
                });
                let mimeType = rendermime.preferredMimeType(mimeModel.data, 'ensure');
                if (!mimeType) {
                    throw new Error('No renderer for output');
                }
                let renderer = rendermime.createRenderer(mimeType);
                renderer.renderModel(mimeModel);
                inner = renderer;
            }
            else {
                inner = (0,_common_mergeview__WEBPACK_IMPORTED_MODULE_4__.createNbdimeMergeView)({
                    remote: model,
                    factory: editorFactory,
                    translator,
                    ...viewOptions,
                });
            }
            if (model.collapsible) {
                view = new _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_3__.CollapsiblePanel(inner, model.collapsibleHeader, model.startCollapsed);
            }
            else {
                view = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
                view.addWidget(inner);
            }
        }
        else if (model instanceof _model__WEBPACK_IMPORTED_MODULE_7__.OutputDiffModel) {
            view = new _output__WEBPACK_IMPORTED_MODULE_9__.OutputPanel({
                model,
                parent,
                editorClasses,
                rendermime,
                editorFactory,
                translator,
            });
            if (model.added) {
                view.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.ADDED_DIFF_CLASS);
            }
            else if (model.deleted) {
                view.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.DELETED_DIFF_CLASS);
            }
            else if (model.unchanged) {
                view.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.UNCHANGED_DIFF_CLASS);
            }
            else {
                view.addClass(_common__WEBPACK_IMPORTED_MODULE_8__.TWOWAY_DIFF_CLASS);
            }
        }
        else {
            throw new Error('Unrecognized model type.');
        }
        return view;
    }
    /**
     * Get the model for the widget.
     *
     * #### Notes
     * This is a read-only property.
     */
    get model() {
        return this._model;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/widget/common.js":
/*!*******************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/widget/common.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ADDED_CHUNK_PANEL_CLASS: () => (/* binding */ ADDED_CHUNK_PANEL_CLASS),
/* harmony export */   ADDED_DIFF_CLASS: () => (/* binding */ ADDED_DIFF_CLASS),
/* harmony export */   ADD_DEL_LABEL_CLASS: () => (/* binding */ ADD_DEL_LABEL_CLASS),
/* harmony export */   CHUNK_PANEL_CLASS: () => (/* binding */ CHUNK_PANEL_CLASS),
/* harmony export */   DELETED_DIFF_CLASS: () => (/* binding */ DELETED_DIFF_CLASS),
/* harmony export */   DIFF_CLASSES: () => (/* binding */ DIFF_CLASSES),
/* harmony export */   REMOVED_CHUNK_PANEL_CLASS: () => (/* binding */ REMOVED_CHUNK_PANEL_CLASS),
/* harmony export */   TWOWAY_DIFF_CLASS: () => (/* binding */ TWOWAY_DIFF_CLASS),
/* harmony export */   UNCHANGED_DIFF_CLASS: () => (/* binding */ UNCHANGED_DIFF_CLASS)
/* harmony export */ });
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

const TWOWAY_DIFF_CLASS = 'jp-Diff-twoway';
const ADDED_DIFF_CLASS = 'jp-Diff-added';
const DELETED_DIFF_CLASS = 'jp-Diff-deleted';
const UNCHANGED_DIFF_CLASS = 'jp-Diff-unchanged';
const DIFF_CLASSES = ['jp-Diff-base', 'jp-Diff-remote'];
const CHUNK_PANEL_CLASS = 'jp-Diff-addremchunk';
const ADDED_CHUNK_PANEL_CLASS = 'jp-Diff-addedchunk';
const REMOVED_CHUNK_PANEL_CLASS = 'jp-Diff-removedchunk';
const ADD_DEL_LABEL_CLASS = 'jp-Diff-label';


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/widget/index.js":
/*!******************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/widget/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CELLDIFF_CLASS: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.CELLDIFF_CLASS),
/* harmony export */   CellDiffWidget: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.CellDiffWidget),
/* harmony export */   MetadataDiffWidget: () => (/* reexport safe */ _metadata__WEBPACK_IMPORTED_MODULE_2__.MetadataDiffWidget),
/* harmony export */   NotebookDiffWidget: () => (/* reexport safe */ _notebook__WEBPACK_IMPORTED_MODULE_1__.NotebookDiffWidget),
/* harmony export */   OUTPUTS_DIFF_CLASS: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.OUTPUTS_DIFF_CLASS)
/* harmony export */ });
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ "./node_modules/nbdime/lib/diff/widget/cell.js");
/* harmony import */ var _notebook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notebook */ "./node_modules/nbdime/lib/diff/widget/notebook.js");
/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metadata */ "./node_modules/nbdime/lib/diff/widget/metadata.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





/***/ }),

/***/ "./node_modules/nbdime/lib/diff/widget/metadata.js":
/*!*********************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/widget/metadata.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MetadataDiffWidget: () => (/* binding */ MetadataDiffWidget)
/* harmony export */ });
/* harmony import */ var _common_basepanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/basepanel */ "./node_modules/nbdime/lib/common/basepanel.js");
/* harmony import */ var _common_mergeview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/mergeview */ "./node_modules/nbdime/lib/common/mergeview.js");
/* harmony import */ var _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/collapsiblepanel */ "./node_modules/nbdime/lib/common/collapsiblepanel.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/diff/widget/common.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





const ROOT_METADATA_CLASS = 'jp-Metadata-diff';
/**
 * MetadataWidget for changes to Notebook-level metadata
 */
class MetadataDiffWidget extends _common_basepanel__WEBPACK_IMPORTED_MODULE_0__.DiffPanel {
    constructor(options) {
        super(options);
        console.assert(!this._model.added && !this._model.deleted);
        this.addClass(ROOT_METADATA_CLASS);
        this.init();
    }
    init() {
        let model = this._model;
        if (!model.unchanged) {
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_3__.TWOWAY_DIFF_CLASS);
            let view = (0,_common_mergeview__WEBPACK_IMPORTED_MODULE_1__.createNbdimeMergeView)({
                remote: model,
                factory: this._editorFactory,
                translator: this._translator,
                ...this._viewOptions,
            });
            if (model.collapsible) {
                view = new _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_2__.CollapsiblePanel(view, model.collapsibleHeader, model.startCollapsed);
            }
            this.addWidget(view);
        }
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/widget/notebook.js":
/*!*********************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/widget/notebook.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotebookDiffWidget: () => (/* binding */ NotebookDiffWidget)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cell */ "./node_modules/nbdime/lib/diff/widget/cell.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/diff/widget/common.js");
/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metadata */ "./node_modules/nbdime/lib/diff/widget/metadata.js");
/* harmony import */ var _common_basepanel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/basepanel */ "./node_modules/nbdime/lib/common/basepanel.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






const NBDIFF_CLASS = 'jp-Notebook-diff';
/**
 * NotebookDiffWidget
 */
class NotebookDiffWidget extends _common_basepanel__WEBPACK_IMPORTED_MODULE_4__.DiffPanel {
    constructor({ rendermime, ...others }) {
        super(others);
        this._rendermime = rendermime;
        this.addClass(NBDIFF_CLASS);
    }
    /**
     * Start adding sub-widgets.
     *
     * Separated from constructor to allow 'live' adding of widgets
     */
    init() {
        let model = this._model;
        let rendermime = this._rendermime;
        let work = Promise.resolve();
        work = work.then(() => {
            if (model.metadata) {
                this.addWidget(new _metadata__WEBPACK_IMPORTED_MODULE_3__.MetadataDiffWidget({
                    model: model.metadata,
                    editorFactory: this._editorFactory,
                    translator: this._translator,
                    ...this._viewOptions,
                }));
            }
        });
        for (let chunk of model.chunkedCells) {
            work = work.then(() => {
                return new Promise(resolve => {
                    if (chunk.length === 1 && !(chunk[0].added || chunk[0].deleted)) {
                        this.addWidget(new _cell__WEBPACK_IMPORTED_MODULE_1__.CellDiffWidget({
                            model: chunk[0],
                            rendermime,
                            mimetype: model.mimetype,
                            editorFactory: this._editorFactory,
                            translator: this._translator,
                            ...this._viewOptions,
                        }));
                    }
                    else {
                        let chunkPanel = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
                        chunkPanel.addClass(_common__WEBPACK_IMPORTED_MODULE_2__.CHUNK_PANEL_CLASS);
                        let addedPanel = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
                        addedPanel.addClass(_common__WEBPACK_IMPORTED_MODULE_2__.ADDED_CHUNK_PANEL_CLASS);
                        let removedPanel = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
                        removedPanel.addClass(_common__WEBPACK_IMPORTED_MODULE_2__.REMOVED_CHUNK_PANEL_CLASS);
                        for (let cell of chunk) {
                            let target = cell.deleted ? removedPanel : addedPanel;
                            target.addWidget(new _cell__WEBPACK_IMPORTED_MODULE_1__.CellDiffWidget({
                                model: cell,
                                rendermime,
                                mimetype: model.mimetype,
                                editorFactory: this._editorFactory,
                                translator: this._translator,
                                ...this._viewOptions,
                            }));
                        }
                        chunkPanel.addWidget(addedPanel);
                        chunkPanel.addWidget(removedPanel);
                        this.addWidget(chunkPanel);
                    }
                    // This limits us to drawing 60 cells per second, which shouldn't
                    // be a problem...
                    requestAnimationFrame(() => {
                        resolve();
                    });
                });
            });
        }
        return work;
    }
    /**
     * Get the model for the widget.
     *
     * #### Notes
     * This is a read-only property.
     */
    get model() {
        return this._model;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/widget/output.js":
/*!*******************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/widget/output.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutputPanel: () => (/* binding */ OutputPanel),
/* harmony export */   RenderableOutputView: () => (/* binding */ RenderableOutputView)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/rendermime */ "webpack/sharing/consume/default/@jupyterlab/rendermime");
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_basepanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/basepanel */ "./node_modules/nbdime/lib/common/basepanel.js");
/* harmony import */ var _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/collapsiblepanel */ "./node_modules/nbdime/lib/common/collapsiblepanel.js");
/* harmony import */ var _common_mergeview__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/mergeview */ "./node_modules/nbdime/lib/common/mergeview.js");
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/diff/widget/common.js");
/* harmony import */ var _renderable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderable */ "./node_modules/nbdime/lib/diff/widget/renderable.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.










/**
 * Class for output panel
 */
const OUTPUT_PANEL_CLASS = 'jp-Diff-outputPanel';
/**
 * Class for a single rendered output view
 */
const RENDERED_OUTPUT_CLASS = 'jp-Diff-renderedOutput';
/**
 * Output is untrusted, and can benefit from being trusted
 */
const UNTRUSTED_CLASS = 'jp-Diff-trustCandidate';
/**
 * Menu with actions for outputs
 */
const HOVER_MENU_CLASS = 'jp-Diff-outputMenu';
/**
 * Menu button to trust output content
 */
const TRUST_BUTTON_CLASS = 'jp-Diff-trustOutputButton';
/**
 * Menu button for showing output as text instead of rendered
 */
const SOURCE_BUTTON_CLASS = 'jp-Diff-showOutputSourceButton';
/**
 * Class for outputs which data is base64
 */
const DATA_IS_BASE64_CLASS = 'jp-diff-base64Output';
/**
 * Class of dropdown for selecting mimetype to show
 */
const MIMETYPE_SELECT_CLASS = 'jp-Diff-outputMimetypeSelect';
/**
 * A list of outputs that are sanitizable.
 */
const sanitizable = ['text/html'];
let _base64 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
function isBase64(data, minLength = 64) {
    return (data !== null &&
        data.length > minLength &&
        _base64.test(data.replace('\n', '')));
}
/**
 * A panel responsible for rendering an output diff
 */
class OutputPanel extends _common_basepanel__WEBPACK_IMPORTED_MODULE_3__.DiffPanel {
    /**
     *
     */
    constructor({ parent: parentModel, editorClasses, rendermime, ...others }) {
        super(others);
        this._mimetype = null;
        this.forceText = false;
        this.rendermime = rendermime;
        this._trans = this._translator.load('nbdime');
        this.editorClasses = editorClasses;
        this._model.trustedChanged.connect((sender, trusted) => {
            this.trustedChanged(trusted);
        });
        if (OutputPanel.isTrustSignificant(this._model, this.rendermime)) {
            this.addClass(UNTRUSTED_CLASS);
        }
        if (this._model.added) {
            if (!parentModel.added) {
                // Implies this is added output
                let addSpacer = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget();
                addSpacer.node.textContent = this._trans.__('Output added');
                addSpacer.addClass(_common__WEBPACK_IMPORTED_MODULE_7__.ADD_DEL_LABEL_CLASS);
                this.addWidget(addSpacer);
            }
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_7__.ADDED_DIFF_CLASS);
        }
        else if (this._model.deleted) {
            if (!parentModel.deleted) {
                // Implies this is deleted output
                let delSpacer = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget();
                delSpacer.node.textContent = this._trans.__('Output deleted');
                delSpacer.addClass(_common__WEBPACK_IMPORTED_MODULE_7__.ADD_DEL_LABEL_CLASS);
                this.addWidget(delSpacer);
            }
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_7__.DELETED_DIFF_CLASS);
        }
        else if (this._model.unchanged) {
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_7__.UNCHANGED_DIFF_CLASS);
        }
        else {
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_7__.TWOWAY_DIFF_CLASS);
        }
        let view = this.createView();
        this.initContainer(view);
        this.createHoverMenu();
        this.addClass(OUTPUT_PANEL_CLASS);
    }
    /**
     * Add view to panel, possibly wrapped
     */
    initContainer(view) {
        if (this._model.collapsible) {
            this.container = new _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_4__.CollapsiblePanel(view, this._model.collapsibleHeader, this._model.startCollapsed);
        }
        else {
            this.container = this;
            this.container.addWidget(view);
        }
        this.view = view;
    }
    /**
     * Replace a view with a new one
     */
    replaceView(view) {
        let old = this.view;
        let i = this.container.widgets.indexOf(old);
        this.container.insertWidget(i, view);
        old.parent = null;
        this.view = view;
    }
    /**
     * Create a text or rendered view of the output diff model
     */
    createView(forceText = false) {
        let view = null;
        let model = this._model;
        let rendermime = this.rendermime;
        // Take one of three actions, depending on output types
        // 1) Renderable types: Side-by-side comparison.
        // 2) Text-type output: Show a MergeView with text diff.
        // 3) Unknown types: Stringified JSON diff.
        let renderable = RenderableOutputView.canRender(model, rendermime);
        if (renderable && !forceText) {
            // 1.
            let rov = new RenderableOutputView(model, this.editorClasses, rendermime, this.selectedMimetype);
            view = rov;
        }
        else {
            // 2. or 3.
            view = this.createOutputTextView();
        }
        return view;
    }
    /**
     * Create text view of output
     */
    createOutputTextView() {
        // Take one of three actions, depending on output types
        // 1) N/A here, see method createView above
        // 2) Known, non-binary MIME: Show a MergeView with text diff.
        // 3) Unknown types: Stringified JSON diff.
        let view;
        let model = this._model;
        // Find highest order MIME-type supported by rendermime
        let key = null;
        if (this.selectedMimetype === null) {
            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.find)(this.rendermime.mimeTypes, mt => {
                key = model.hasMimeType(mt);
                return key !== null;
            });
        }
        else {
            key = model.hasMimeType(this.selectedMimetype);
        }
        if (key) {
            let stringModel = model.stringify(key);
            let aValue = stringModel.base || stringModel.remote;
            if (!isBase64(aValue)) {
                // 2.
                view = (0,_common_mergeview__WEBPACK_IMPORTED_MODULE_5__.createNbdimeMergeView)({
                    remote: stringModel,
                    factory: this._editorFactory,
                    translator: this._translator,
                    ...this._viewOptions,
                });
            }
        }
        if (!view) {
            // 3.
            view = (0,_common_mergeview__WEBPACK_IMPORTED_MODULE_5__.createNbdimeMergeView)({
                remote: model.stringify(),
                factory: this._editorFactory,
                translator: this._translator,
                ...this._viewOptions,
            });
        }
        return view;
    }
    /**
     * Creates a menu that is shown when hovering over the output.
     *
     * Stored in this.menu.
     */
    createHoverMenu() {
        this.menu = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel();
        this.menu.addClass(HOVER_MENU_CLASS);
        this.container.addWidget(this.menu);
        // Add rendered/source toggle:
        let btnSource = document.createElement('button');
        let sourceText = [this._trans.__('Show source'), this._trans.__('Render')];
        btnSource.textContent = sourceText[0];
        btnSource.onclick = (ev) => {
            this.forceText = !this.forceText;
            btnSource.textContent = sourceText[this.forceText ? 1 : 0];
            this.updateView();
        };
        let w = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget({ node: btnSource });
        w.addClass(SOURCE_BUTTON_CLASS);
        this.menu.addWidget(w);
        // Add trust button:
        let btnTrust = document.createElement('button');
        btnTrust.textContent = this._trans.__('Trust');
        btnTrust.onclick = (ev) => {
            // Triggers change event:
            this._model.trusted = !this._model.trusted;
        };
        w = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget({ node: btnTrust });
        w.addClass(TRUST_BUTTON_CLASS);
        this.menu.addWidget(w);
        // Add mimetype select:
        let mimetypes = [];
        for (let output of this._model.contents) {
            let bundle = _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__.OutputModel.getData(output);
            mimetypes = mimetypes.concat(Object.keys(bundle));
        }
        mimetypes = mimetypes.filter(_common_util__WEBPACK_IMPORTED_MODULE_6__.unique);
        if (mimetypes.length > 1) {
            let cboMimetype = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.buildSelect)(mimetypes);
            let selectedMimetype = this.selectedMimetype;
            if (selectedMimetype) {
                cboMimetype.selectedIndex = mimetypes.indexOf(selectedMimetype);
            }
            cboMimetype.onchange = (ev) => {
                this.selectedMimetype = mimetypes[cboMimetype.selectedIndex];
            };
            w = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget({ node: cboMimetype });
            w.addClass(MIMETYPE_SELECT_CLASS);
            this.menu.addWidget(w);
        }
        else if (mimetypes.length === 1) {
            let mtLabel = document.createElement('span');
            mtLabel.innerText = mimetypes[0];
            w = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget({ node: mtLabel });
            // w.addClass(MIMETYPE_SELECT_CLASS);
            this.menu.addWidget(w);
        }
    }
    /**
     * Update trusted status
     */
    trustedChanged(trusted) {
        this.updateView();
        if (trusted) {
            this.removeClass(UNTRUSTED_CLASS);
        }
        else if (OutputPanel.isTrustSignificant(this._model, this.rendermime)) {
            this.addClass(UNTRUSTED_CLASS);
        }
    }
    /**
     * Update view
     */
    updateView() {
        let model = this._model;
        if (this.view instanceof RenderableOutputView) {
            // Previosuly rendered
            if (!this.forceText &&
                RenderableOutputView.canRender(model, this.rendermime)) {
                // Can still render
                this.view.updateView(this.selectedMimetype, model.trusted);
            }
            else {
                // Can no longer render
                let view = this.createView(this.forceText);
                this.replaceView(view);
            }
        }
        else {
            // Previously text output
            // Here, we replace the view irregardles of old vs new type
            let view = this.createView(this.forceText);
            this.replaceView(view);
        }
    }
    get selectedMimetype() {
        if (this._mimetype !== null) {
            return this._mimetype;
        }
        let data = _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__.OutputModel.getData(this._model.base || this._model.remote);
        let mt = this.rendermime.preferredMimeType(data, this._model.trusted ? 'any' : 'ensure');
        return mt === undefined ? null : mt;
    }
    set selectedMimetype(value) {
        if (this._mimetype !== value) {
            this._mimetype = value;
            this.updateView();
        }
    }
    /**
     * Whether trust can affect the output rendering.
     */
    static isTrustSignificant(model, rendermime) {
        if (model.trusted) {
            return false;
        }
        let toTest = [];
        if (model.base) {
            toTest.push(model.base);
        }
        if (model.remote && model.remote !== model.base) {
            toTest.push(model.remote);
        }
        for (let o of toTest) {
            let untrustedModel = new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__.OutputModel({ value: o, trusted: false });
            let modelMimeTypes = Object.keys(untrustedModel.data);
            let rendererMimeTypes = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.toArray)(rendermime.mimeTypes);
            let candidates = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.intersection)(modelMimeTypes, rendererMimeTypes);
            for (let mimeType of candidates) {
                let factory = rendermime.getFactory(mimeType);
                if (factory &&
                    (!factory.safe || sanitizable.indexOf(mimeType) !== -1)) {
                    return true;
                }
            }
        }
        return false;
    }
}
/**
 * Widget for an output with renderable MIME data.
 */
class RenderableOutputView extends _renderable__WEBPACK_IMPORTED_MODULE_8__.RenderableDiffView {
    constructor(model, editorClass, rendermime, mimetype) {
        super(model, editorClass, rendermime, mimetype);
    }
    /**
     * Create a widget which renders the given cell output
     */
    createSubView(output, trusted) {
        let panel = new RenderedOutputWidget(this.rendermime);
        panel.updateView(output, trusted, this.mimetype);
        return panel;
    }
    /**
     * Update trusted status
     */
    updateView(mimeType, trusted) {
        let i = 0;
        let model = this.model;
        this.mimetype = mimeType;
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(this.layout.widgets, (w) => {
            if (w instanceof RenderedOutputWidget) {
                let output = null;
                if (i === 0 && model.base) {
                    // Use base data
                    output = model.base;
                }
                else if (model.remote) {
                    output = model.remote;
                }
                if (output) {
                    w.updateView(output, trusted, mimeType);
                }
                ++i;
            }
        });
    }
    /**
     * Checks if a cell output can be rendered (either safe/trusted or
     * sanitizable)
     */
    static canRender(model, rendermime) {
        let toTest = model.contents;
        for (let o of toTest) {
            let bundle = _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__.OutputModel.getData(o);
            let mimetype = rendermime.preferredMimeType(bundle, model.trusted ? 'any' : 'ensure');
            if (!mimetype) {
                return false;
            }
        }
        return true;
    }
}
class RenderedOutputWidget extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Panel {
    /**
     *
     */
    constructor(rendermime) {
        super();
        this.rendermime = rendermime;
    }
    updateView(output, trusted, mimetype) {
        let old = this.renderer;
        this.renderer = this.createRenderer(output, trusted, mimetype);
        if (old !== undefined) {
            old.dispose();
        }
        this.addWidget(this.renderer);
    }
    createRenderer(output, trusted, mimetype) {
        let model = new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__.OutputModel({ value: output, trusted });
        let widget = this.rendermime.createRenderer(mimetype);
        widget.renderModel(model);
        widget.addClass(RENDERED_OUTPUT_CLASS);
        let bundle = _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__.OutputModel.getData(output);
        if (isBase64(bundle[mimetype])) {
            widget.addClass(DATA_IS_BASE64_CLASS);
        }
        return widget;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/diff/widget/renderable.js":
/*!***********************************************************!*\
  !*** ./node_modules/nbdime/lib/diff/widget/renderable.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderableDiffView: () => (/* binding */ RenderableDiffView)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * Widget for outputs with renderable MIME data.
 */
class RenderableDiffView extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {
    constructor(model, editorClass, rendermime, mimetype) {
        super();
        this.rendermime = rendermime;
        this.model = model;
        this.mimetype = mimetype;
        let bdata = model.base;
        let rdata = model.remote;
        this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.PanelLayout();
        let ci = 0;
        if (bdata) {
            let widget = this.createSubView(bdata, model.trusted);
            this.layout.addWidget(widget);
            widget.addClass(editorClass[ci++]);
        }
        if (rdata && rdata !== bdata) {
            let widget = this.createSubView(rdata, model.trusted);
            this.layout.addWidget(widget);
            widget.addClass(editorClass[ci++]);
        }
    }
    get layout() {
        return super.layout;
    }
    set layout(value) {
        super.layout = value;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/decisions.js":
/*!****************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/decisions.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MergeDecision: () => (/* binding */ MergeDecision),
/* harmony export */   addSorted: () => (/* binding */ addSorted),
/* harmony export */   applyDecisions: () => (/* binding */ applyDecisions),
/* harmony export */   buildDiffs: () => (/* binding */ buildDiffs),
/* harmony export */   decisionPathSortKey: () => (/* binding */ decisionPathSortKey),
/* harmony export */   decisionSortKey: () => (/* binding */ decisionSortKey),
/* harmony export */   filterDecisions: () => (/* binding */ filterDecisions),
/* harmony export */   popPath: () => (/* binding */ popPath),
/* harmony export */   pushPatchDecision: () => (/* binding */ pushPatchDecision),
/* harmony export */   pushPath: () => (/* binding */ pushPath),
/* harmony export */   resolveCommonPaths: () => (/* binding */ resolveCommonPaths)
/* harmony export */ });
/* harmony import */ var _diff_diffentries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../diff/diffentries */ "./node_modules/nbdime/lib/diff/diffentries.js");
/* harmony import */ var _diff_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../diff/util */ "./node_modules/nbdime/lib/diff/util.js");
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../patch */ "./node_modules/nbdime/lib/patch/index.js");
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// This code is based on the CodeMirror mergeview.js source:
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE





function validateAction(action) {
    if ((0,_common_util__WEBPACK_IMPORTED_MODULE_3__.valueIn)(action, [
        'base',
        'local',
        'remote',
        'local_then_remote',
        'remote_then_local',
        'custom',
        'clear',
        'clear_parent',
        'either',
    ])) {
        return action;
    }
    throw new Error('Invalid merge decision action: ' + action);
}
/**
 * Take the value, or take default if value is undefined
 */
function valueOrDefault(value, defaultValue) {
    return value === undefined ? defaultValue : value;
}
class MergeDecision {
    constructor(obj, localDiff = null, remoteDiff = null, action = 'base', conflict = false, customDiff = null, similarInsert = null) {
        this.level = 0;
        if (obj instanceof Array) {
            this._path = obj;
        }
        else if (obj instanceof MergeDecision) {
            this._path = obj.absolutePath.slice();
            localDiff = obj.localDiff;
            remoteDiff = obj.remoteDiff;
            action = obj.action;
            conflict = obj.conflict;
            customDiff = obj.customDiff;
            similarInsert = obj.similarInsert;
            this.level = obj.level;
        }
        else {
            this._path = valueOrDefault(obj.common_path, []);
            localDiff = valueOrDefault(obj.local_diff, localDiff);
            remoteDiff = valueOrDefault(obj.remote_diff, remoteDiff);
            action = validateAction(valueOrDefault(obj.action, action));
            conflict = valueOrDefault(obj.conflict, conflict);
            customDiff = valueOrDefault(obj.custom_diff, customDiff);
            similarInsert = valueOrDefault(obj.similar_insert, similarInsert);
        }
        this.localDiff = localDiff;
        this.remoteDiff = remoteDiff;
        this.action = action;
        this.conflict = conflict;
        this.customDiff = customDiff;
        this.similarInsert = similarInsert;
    }
    setValuesFrom(other) {
        this._path = other.absolutePath.slice();
        this.localDiff = other.localDiff;
        this.remoteDiff = other.remoteDiff;
        this.action = other.action;
        this.conflict = other.conflict;
        this.customDiff = other.customDiff;
        this.similarInsert = other.similarInsert;
        this.level = other.level;
    }
    get localPath() {
        return this._path.slice(this.level);
    }
    get absolutePath() {
        return this._path;
    }
    set absolutePath(value) {
        this._path = value;
    }
    pushPath(key) {
        this._path.push(key);
    }
    get diffs() {
        let diffs = [this.localDiff, this.remoteDiff];
        if (this.customDiff) {
            diffs.push(this.customDiff);
        }
        return diffs;
    }
    set diffs(value) {
        this.localDiff = value[0];
        this.remoteDiff = value[1];
        if (value.length > 2) {
            this.customDiff = value[2];
        }
    }
    serialize() {
        return {
            common_path: this.absolutePath.slice(),
            local_diff: (0,_diff_util__WEBPACK_IMPORTED_MODULE_1__.stripSource)(this.localDiff),
            remote_diff: (0,_diff_util__WEBPACK_IMPORTED_MODULE_1__.stripSource)(this.remoteDiff),
            action: this.action,
            conflict: this.conflict,
            custom_diff: (0,_diff_util__WEBPACK_IMPORTED_MODULE_1__.stripSource)(this.customDiff),
        };
    }
}
/**
 * Compare to DecisionPath's for sorting.
 *
 * The rules are that deeper paths sort before other paths
 * with the same prefix, as they correspond to patch ops,
 * which will not affect the indexing of following decisions
 * on lists.
 *
 * @param {DecisionPath} a The first decision path
 * @param {DecisionPath} b The second decision path
 * @returns {number} Returns a negative number if a should
 *  sort first, positive number if b should sort first, or
 *  zero if the are identical.
 */
function decisionPathSortKey(a, b) {
    if (a.length === b.length) {
        // Equally deep, sort on keys
        for (let lvl = 0; lvl < a.length; ++lvl) {
            if (a[lvl] === b[lvl]) {
                // Keys are equal, try a deeper level
                continue;
            }
            // Keys differ on this level!
            return a[lvl] < b[lvl] ? -1 : 1;
        }
        // Paths are identical
        return 0;
    }
    else {
        // Sort deeper paths first
        return b.length - a.length;
    }
}
/**
 * Compare the paths of two decisions for sorting.
 *
 * This is a thin wrapper around decisionPathSortKey
 *
 * @export
 * @param {MergeDecision} a The first decision
 * @param {MergeDecision} b The second decision
 * @returns {number}  Returns a negative number if a should
 *  sort first, positive number if b should sort first, or
 *  zero if the are identical.
 */
function decisionSortKey(a, b) {
    return decisionPathSortKey(a.absolutePath, b.absolutePath);
}
/**
 * Adds a decision to an existing, sorted collection of merge decisions
 *
 * Ensures that the location of the newly added decision
 * will comply with the format specification
 *
 * @export
 * @param {MergeDecision[]} decisions
 * @param {MergeDecision} toAdd
 * @param {(number | string)} [firstKey]
 * @returns {void}
 */
function addSorted(decisions, toAdd, firstKey) {
    let idx = 0;
    for (; idx < decisions.length; ++idx) {
        let c = decisionPathSortKey(decisions[idx].absolutePath, toAdd.absolutePath);
        if (c > 0) {
            decisions.splice(idx, 0, toAdd);
            return;
        }
        else if (firstKey !== undefined && c === 0) {
            let key = null;
            for (let diff of decisions[idx].diffs) {
                if (!diff) {
                    continue;
                }
                for (let d of diff) {
                    if (!key || d.key < key) {
                        key = d.key;
                    }
                }
            }
            if (firstKey === key) {
                throw new Error("Shouldn't have multiple decisions with diff on same key");
            }
            else if (key === null || firstKey < key) {
                decisions.splice(idx, 0, toAdd);
                return;
            }
        }
    }
    decisions.push(toAdd);
}
function popPath(diffs, popInner) {
    if (diffs.length < 1) {
        return null;
    }
    // Find first non-null, non-empty diff list:
    let i = 0;
    for (let di of diffs) {
        if (di !== null && di.length > 0) {
            break;
        }
        i++;
    }
    // Assert that we have at least one non-null diff:
    if (i === diffs.length) {
        console.log('Empty merge decision (no diffs)!');
        return null;
    }
    // Check if ops and keys are equal for all non-null diffs
    let d = diffs[i];
    let op = d[0].op;
    let key = d[0].key;
    for (let di of diffs) {
        if (di && di.length > 0) {
            // Note that while diff lists can have 2 entries, they should never cause
            // a pop, as they will have a difference in op.
            for (let dj of di) {
                if (dj.op !== op || dj.key !== key) {
                    return null;
                }
            }
        }
    }
    // Inspect patch op further along:
    if (op === 'patch') {
        // Only pop if sub-diff has length 1 (unless popInner is true)
        if (popInner !== true) {
            for (let di of diffs) {
                if (di &&
                    di.length > 0 &&
                    (di.length !== 1 ||
                        !di[0].diff ||
                        di[0].diff.length !== 1)) {
                    return null;
                }
            }
        }
        let retDiffs = [];
        for (let di of diffs) {
            if (di && di.length > 0) {
                retDiffs.push(di[0].diff);
            }
            else {
                retDiffs.push(null);
            }
        }
        return { diffs: retDiffs, key: key };
    }
    return null;
}
function pushPath(diffs, prefix) {
    for (let key of prefix.reverse()) {
        diffs = [(0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opPatch)(key, diffs)];
    }
    return diffs;
}
/**
 * Expand the `common_path` field of the merge decisions for optimized
 * processing. Modifies the merge decisions in-place.
 */
function resolveCommonPaths(decisions) {
    for (let md of decisions) {
        let diffs = md.diffs;
        let path = md.absolutePath || [];
        let popped = popPath(diffs, true);
        while (popped) {
            path.push(popped.key);
            diffs = popped.diffs;
            popped = popPath(diffs, true);
        }
        md.absolutePath = path;
        md.diffs = diffs;
    }
}
/**
 * Make a new 'cleared' value of the right type.
 */
function makeClearedValue(value) {
    if (value instanceof Array) {
        // Clearing e.g. an outputs list means setting it to an empty array
        return [];
    }
    else if (typeof value === 'string') {
        // Clearing e.g. a source string means setting it to an empty string
        return '';
    }
    else if (value === null || (0,_common_util__WEBPACK_IMPORTED_MODULE_3__.valueIn)(typeof value, ['number', 'boolean'])) {
        // Clearing anything else (atomic values) means setting it to null
        return null;
    }
    else {
        // Clearing e.g. a metadata dict means setting it to an empty Object
        return {};
    }
}
function _resolvePathInObject(obj, path) {
    for (let key of path) {
        obj = obj[key]; // Should throw if key missing
    }
    return obj;
}
function _combineDiffs(a, b) {
    if (a && b) {
        return a.concat(b);
    }
    else if (a) {
        return a.slice();
    }
    else if (b) {
        return b.slice();
    }
    else {
        return [];
    }
}
function resolveAction(base, decision) {
    let a = decision.action;
    if (a === 'base') {
        return []; // no-op
    }
    else if (a === 'local' || a === 'either') {
        return decision.localDiff ? decision.localDiff.slice() : [];
    }
    else if (a === 'remote') {
        return decision.remoteDiff ? decision.remoteDiff.slice() : [];
    }
    else if (a === 'custom') {
        return decision.customDiff ? decision.customDiff.slice() : [];
    }
    else if (a === 'local_then_remote') {
        return _combineDiffs(decision.localDiff, decision.remoteDiff);
    }
    else if (a === 'remote_then_local') {
        return _combineDiffs(decision.remoteDiff, decision.localDiff);
    }
    else if (a === 'clear') {
        let key = null;
        if (typeof base !== 'object') {
            throw new TypeError("Can only use `'clear'` action on objects/dicts");
        }
        for (let d of _combineDiffs(decision.localDiff, decision.remoteDiff)) {
            if (key) {
                if (key !== d.key) {
                    throw new Error('Cannot combine diffs with different keys');
                }
            }
            else {
                key = d.key;
            }
        }
        if (key) {
            let d = (0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opReplace)(key, makeClearedValue(base[key]));
            d.source = { decision, action: 'custom' };
            return [d];
        }
        else {
            return [];
        }
    }
    else if (a === 'clear_parent') {
        if (Array.isArray(base)) {
            let d = (0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opRemoveRange)(0, base.length);
            d.source = { decision, action: 'custom' };
            return [d];
        }
        else if (typeof base === 'string') {
            let len = (0,_common_util__WEBPACK_IMPORTED_MODULE_3__.splitLines)(base).length;
            let d = (0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opRemoveRange)(0, len);
            d.source = { decision, action: 'custom' };
            return [d];
        }
        else {
            // Ideally we would do a opReplace on the parent, but this is not
            // easily combined with this method, so simply remove all keys
            let diff = [];
            for (let key of base) {
                let d = (0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opRemove)(key);
                d.source = { decision, action: 'custom' };
                diff.push(d);
            }
            return diff;
        }
    }
    else {
        throw new Error('The action "' + a + '" is not defined');
    }
}
/**
 * Prevent paths from pointing to specific string lines.
 *
 * Check if path points to a specific line in a string, if so, split off index.
 *
 * Returns a tuple of path and any line key.
 */
function splitDiffStringPath(base, path) {
    for (let i = 0; i < path.length; ++i) {
        if (typeof base === 'string') {
            return [path.slice(0, i), path.slice(i)];
        }
        base = base[path[i]];
    }
    return [path, null];
}
function applyDecisions(base, decisions) {
    let merged = (0,_common_util__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(base);
    let prevPath = null;
    let parent = null;
    let lastKey = null;
    let resolved = null;
    let diffs = [];
    // clear_parent actions should override other decisions on same obj, so
    // we need to track it
    let clearParent = false;
    for (let md of decisions) {
        let spl = splitDiffStringPath(merged, md.localPath);
        let path = spl[0];
        let line = spl[1];
        // We patch all decisions with the same path in one op
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_3__.arraysEqual)(path, prevPath)) {
            if (clearParent) {
                // Another entry will clear the parent, so all other decisions
                // should be dropped
            }
            else {
                if (md.action === 'clear_parent') {
                    clearParent = true;
                    diffs = []; // Clear any exisiting decsions!
                }
                let ad = resolveAction(resolved, md);
                if (line) {
                    ad = pushPath(ad, line);
                }
                diffs = diffs.concat(ad);
            }
        }
        else {
            // Different path, start a new collection
            if (prevPath !== null) {
                // First, apply previous diffs
                if (parent === null) {
                    // Operations on root create new merged object
                    merged = (0,_patch__WEBPACK_IMPORTED_MODULE_2__.patch)(resolved, diffs);
                }
                else {
                    // If not, overwrite entry in parent (which is an entry in merged).
                    // This is ok, as no paths should point to subobjects of the patched
                    // object.
                    parent[lastKey] = (0,_patch__WEBPACK_IMPORTED_MODULE_2__.patch)(resolved, diffs);
                }
            }
            prevPath = path.slice();
            // Resolve path in base and output
            resolved = merged;
            parent = null;
            lastKey = null;
            for (let key of path) {
                parent = resolved;
                resolved = resolved[key]; // Should throw if key missing
                lastKey = key;
            }
            diffs = resolveAction(resolved, md);
            if (line) {
                diffs = pushPath(diffs, line);
            }
            clearParent = md.action === 'clear_parent';
        }
    }
    // Apply the last collection of diffs, if present (same as above)
    if (prevPath !== null) {
        if (parent === null) {
            merged = (0,_patch__WEBPACK_IMPORTED_MODULE_2__.patch)(resolved, diffs);
        }
        else {
            parent[lastKey] = (0,_patch__WEBPACK_IMPORTED_MODULE_2__.patch)(resolved, diffs);
        }
    }
    return merged;
}
/**
 * Merge a tree of diffs at varying path levels to one diff at their shared root
 *
 * Relies on the format specification about decision ordering to help
 * simplify the process (deeper paths should come before its parent paths).
 * This is realized by the `sortedPaths` argument.
 */
function _mergeTree(tree, sortedPaths) {
    let trunk = [];
    let root = null;
    for (let i = 0; i < sortedPaths.length; ++i) {
        let path = tree[sortedPaths[i]].path;
        let subdiffs = tree[sortedPaths[i]].diff;
        trunk = trunk.concat(subdiffs);
        let nextPath;
        if (i === sortedPaths.length - 1) {
            nextPath = root;
        }
        else {
            nextPath = tree[sortedPaths[i + 1]].path;
        }
        // First, check if path is subpath of nextPath:
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_3__.isPrefixArray)(nextPath, path)) {
            // We can simply promote existing diffs to next path
            if (nextPath !== null) {
                trunk = pushPath(trunk, path.slice(nextPath.length));
                root = nextPath;
            }
        }
        else {
            // We have started on a new trunk
            // Collect branches on the new trunk, and merge the trunks
            let newTrunk = _mergeTree(tree, sortedPaths.slice(i + 1));
            nextPath = tree[sortedPaths[sortedPaths.length - 1]].path;
            let prefix = (0,_common_util__WEBPACK_IMPORTED_MODULE_3__.findSharedPrefix)(path, nextPath);
            let pl = prefix ? prefix.length : 0;
            trunk = pushPath(trunk, path.slice(pl)).concat(pushPath(newTrunk, nextPath.slice(pl)));
            break; // Recursion will exhaust sortedPaths
        }
    }
    return trunk;
}
/**
 * Builds a diff for direct application on base. The `which` argument either
 * selects the 'local', 'remote' or 'merged' diffs.
 */
function buildDiffs(base, decisions, which) {
    let tree = {};
    let sortedPaths = [];
    let local = which === 'local';
    let merged = which === 'merged';
    if (!local && !merged) {
        console.assert(which === 'remote');
    }
    for (let md of decisions) {
        let subdiffs = null;
        let spl = splitDiffStringPath(base, md.localPath);
        let path = spl[0];
        let line = spl[1];
        if (merged) {
            let sub = _resolvePathInObject(base, path);
            subdiffs = resolveAction(sub, md);
        }
        else {
            subdiffs = local ? md.localDiff : md.remoteDiff;
            if (subdiffs === null) {
                continue;
            }
        }
        let strPath = '/' + path.join('/');
        if (tree.hasOwnProperty(strPath)) {
            // Existing tree entry, simply add diffs to it
            if (line) {
                let matchDiff = (0,_diff_util__WEBPACK_IMPORTED_MODULE_1__.getSubDiffByKey)(tree[strPath].diff, line[0]);
                if (matchDiff) {
                    matchDiff.push.apply(matchDiff, subdiffs);
                }
                else {
                    subdiffs = pushPath(subdiffs, line);
                    tree[strPath].diff.push(subdiffs[0]);
                }
            }
            else {
                tree[strPath].diff = tree[strPath].diff.concat(subdiffs);
            }
        }
        else {
            // Make new entry in tree
            if (line) {
                subdiffs = pushPath(subdiffs, line);
            }
            tree[strPath] = { diff: subdiffs, path: path };
            sortedPaths.push(strPath);
        }
    }
    if (Object.keys(tree).length === 0) {
        return null;
    }
    if (!tree.hasOwnProperty('/')) {
        tree['/'] = { diff: [], path: [] };
        sortedPaths.push('/');
    }
    // Tree is constructed, now join all branches at diverging points (joints)
    return _mergeTree(tree, sortedPaths);
}
/**
 * Move a path prefix in a merge decision from `common_path` to the diffs.
 *
 * This is done by wrapping the diffs in nested patch ops.
 */
function pushPatchDecision(decision, prefix) {
    let dec = new MergeDecision(decision);
    // We need to start with inner most key to nest correctly, so reverse:
    for (let key of prefix.slice().reverse()) {
        if (dec.absolutePath.length === 0) {
            throw new Error('Cannot remove key from empty decision path: ' + key + ', ' + dec);
        }
        let popped = dec.absolutePath.pop();
        if (popped !== key) {
            // Pop and assert
            throw Error("Cannot push a patch that doesn't correspond to " +
                'a key in the decision path! Key: ' +
                key +
                '; Remaining path: ' +
                dec.absolutePath.concat([popped]));
        }
        let ld = dec.localDiff && dec.localDiff.length > 0;
        let rd = dec.remoteDiff && dec.remoteDiff.length > 0;
        let cd = dec.customDiff && dec.customDiff.length > 0;
        dec.localDiff = ld ? [(0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opPatch)(key, dec.localDiff)] : null;
        dec.remoteDiff = rd ? [(0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opPatch)(key, dec.remoteDiff)] : null;
        dec.customDiff = cd ? [(0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_0__.opPatch)(key, dec.customDiff)] : null;
    }
    return dec;
}
/**
 * Filter decisions based on matching (segment of) path
 *
 * Checks whether each decision's path start with `path`. If `skipLevels` is
 * given, the first levels of the decision's path is ignored for the comparison.
 *
 * Once matched, the matching decisions' levels are adjusted such that they
 * point to after the matching segment.
 *
 * Example:
 * Given a list of decisions with paths:
 *   /cells/0/outputs/0
 *   /cells/0/outputs/1
 *   /cells/2/outputs/1
 *   /cells/12/outputs/0/data
 *
 * If called with path `['cells']`:
 *   All decisions will be returned, with level set to 1
 * If called with path `['cells', 0]`:
 *   The first two will be returned, with level set to 2
 * If called with path `['outputs']`, and skipLevel = 2:
 *   All decisions will be returned, with level set to 3
 * If called with path `['outputs', 0]`, and skipLevel = 2:
 *   Decision 1 and 4 will be returned, with level set to 4
 *
 * Note that since the same decision instances are returned, this will modify
 * the level of the passed decisions.
 */
function filterDecisions(decisions, path, skipLevels, maxLength) {
    let ret = [];
    skipLevels = skipLevels || 0;
    for (let md of decisions) {
        if (maxLength !== undefined && md.absolutePath.length > maxLength) {
            continue;
        }
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_3__.isPrefixArray)(path, md.absolutePath.slice(skipLevels))) {
            md.level = skipLevels + path.length;
            ret.push(md);
        }
    }
    return ret;
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/model/cell.js":
/*!*****************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/model/cell.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellMergeModel: () => (/* binding */ CellMergeModel)
/* harmony export */ });
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/nbformat */ "webpack/sharing/consume/default/@jupyterlab/nbformat");
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _diff_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../diff/util */ "./node_modules/nbdime/lib/diff/util.js");
/* harmony import */ var _diff_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../diff/model */ "./node_modules/nbdime/lib/diff/model/index.js");
/* harmony import */ var _merge_decisions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../merge/decisions */ "./node_modules/nbdime/lib/merge/decisions.js");
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../patch */ "./node_modules/nbdime/lib/patch/index.js");
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _chunking__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../chunking */ "./node_modules/nbdime/lib/chunking/index.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/merge/model/common.js");
/* harmony import */ var _common_exceptions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/exceptions */ "./node_modules/nbdime/lib/common/exceptions.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.











/**
 * Create a cell diff model based on a set of merge
 * decisions that patch the cell.
 */
function createPatchedCellDecisionDiffModel(base, decisions, local, remote, mimetype) {
    for (let md of decisions) {
        if (md.localPath.length === 0) {
            let val = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.popPath)(md.diffs, true);
            if (val !== null) {
                md.diffs = val.diffs;
                md.pushPath(val.key);
            }
        }
    }
    let source = new _common__WEBPACK_IMPORTED_MODULE_8__.DecisionStringDiffModel(base.source, (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.filterDecisions)(decisions, ['source'], 2), [local ? local.source : null, remote ? remote.source : null]);
    (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.setMimetypeFromCellType)(source, base, mimetype);
    let metadata = new _common__WEBPACK_IMPORTED_MODULE_8__.DecisionStringDiffModel(base.metadata, (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.filterDecisions)(decisions, ['metadata'], 2), [local ? local.metadata : null, remote ? remote.metadata : null]);
    let outputs = null;
    let executionCount = null;
    if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isCode(base)) {
        if (base.outputs) {
            let outputBase = base.outputs;
            let outputDec = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.filterDecisions)(decisions, ['outputs'], 2);
            let mergedDiff = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.buildDiffs)(outputBase, outputDec, 'merged');
            let merged;
            if (mergedDiff && mergedDiff.length > 0) {
                merged = (0,_patch__WEBPACK_IMPORTED_MODULE_5__.patch)(outputBase, mergedDiff);
            }
            else {
                merged = outputBase;
            }
            outputs = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.makeOutputModels)(outputBase, merged, mergedDiff);
        }
        let execBase = base.execution_count;
        let cellDecs = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.filterDecisions)(decisions, ['cells'], 0, 2);
        for (let dec of cellDecs) {
            if ((0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.localDiff, 'execution_count') !== null ||
                (0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.remoteDiff, 'execution_count') !== null ||
                (0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.customDiff, 'execution_count') !== null) {
                dec.level = 2;
                let mergeExecDiff = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.buildDiffs)(base, [dec], 'merged');
                let execDiff = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(mergeExecDiff) ? mergeExecDiff[0] : null;
                // Pass base as remote, which means fall back to unchanged if no diff:
                executionCount = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createImmutableModel)(execBase, execBase, execDiff);
            }
        }
    }
    let idModel = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createImmutableModel)(base.id ? base.id : null, null);
    return new _diff_model__WEBPACK_IMPORTED_MODULE_3__.CellDiffModel(source, metadata, outputs, executionCount, base.cell_type, idModel);
}
/**
 * CellMergeModel
 */
class CellMergeModel extends _common__WEBPACK_IMPORTED_MODULE_8__.ObjectMergeModel {
    constructor(base, decisions, mimetype) {
        // TODO: Remove/extend allowlist once we support more
        super(base, [], mimetype, [
            'source',
            'metadata',
            'outputs',
            'execution_count',
            'id',
        ]);
        this.deleteCellChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._clearOutputs = false;
        this.clearOutputsChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this.onesided = false;
        this._deleteCell = false;
        this.processDecisions(decisions);
    }
    /**
     * Run time flag whether the user wants to delete the cell
     *
     * @type {boolean}
     */
    get deleteCell() {
        return this._deleteCell;
    }
    set deleteCell(value) {
        if (this._deleteCell !== value) {
            this._deleteCell = value;
            this.deleteCellChanged.emit(value);
        }
    }
    /**
     * Run time flag whether the user wants to clear the outputs of the cell
     *
     * @type {boolean}
     */
    get clearOutputs() {
        return this._clearOutputs;
    }
    set clearOutputs(value) {
        if (this._clearOutputs !== value) {
            this._clearOutputs = value;
            this.clearOutputsChanged.emit(value);
        }
    }
    /**
     * Whether source is the same in local and remote
     */
    get agreedSource() {
        return (!!this.local &&
            !!this.remote &&
            this.local.source.remote === this.remote.source.remote);
    }
    /**
     * Whether metadata is the same in local and remote
     */
    get agreedMetadata() {
        if (!this.local || !this.remote) {
            return false;
        }
        return this.local.metadata.remote === this.remote.metadata.remote;
    }
    /**
     * Whether outputs are the same in local and remote
     */
    get agreedOutputs() {
        if (!this.local || !this.remote) {
            return false;
        }
        let lo = this.local.outputs;
        let ro = this.remote.outputs;
        if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(lo) || !(0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(ro)) {
            return !(0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(lo) && !(0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(ro);
        }
        if (lo.length !== ro.length) {
            return false;
        }
        for (let i = 0; i < lo.length; ++i) {
            if (JSON.stringify(lo[i].remote) !== JSON.stringify(ro[i].remote)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Whether the cell ids are the same in local and remote
     */
    get agreedIds() {
        if (!this.local || !this.remote) {
            return false;
        }
        return this.local.cellId.remote === this.remote.cellId.remote;
    }
    /**
     * Whether cell is the same in local and remote
     */
    get agreedCell() {
        // TODO: Also check other fields?
        return (this.agreedSource &&
            this.agreedMetadata &&
            this.agreedOutputs &&
            this.agreedIds);
    }
    /**
     * Whether the cell has any conflicted decisions.
     */
    get conflicted() {
        for (let dec of this.decisions) {
            if (dec.conflict) {
                return true;
            }
        }
        return false;
    }
    /**
     * Whether the cell has any conflicted decisions on a specific key.
     */
    hasConflictsOn(key) {
        let decs = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.filterDecisions)(this.decisions, [key], 2);
        for (let dec of decs) {
            if (dec.conflict) {
                return true;
            }
        }
        return false;
    }
    /**
     * Whether the cell has any conflicted decisions on source.
     */
    get sourceConflicted() {
        return this.hasConflictsOn('source');
    }
    /**
     * Whether the cell has any conflicted decisions on metadata.
     */
    get metadataConflicted() {
        return this.hasConflictsOn('metadata');
    }
    /**
     * Whether the cell has any conflicted decisions.
     */
    get outputsConflicted() {
        return this.hasConflictsOn('outputs');
    }
    /**
     * Clear any conflicts on decisions on outputs
     */
    clearOutputConflicts() {
        let decs = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.filterDecisions)(this.decisions, ['outputs'], 2);
        for (let dec of decs) {
            dec.conflict = false;
        }
    }
    /**
     * Get the decision on `execution_count` field (should only be one).
     *
     * Returns null if no decision on `execution_count` was found.
     */
    getExecutionCountDecision() {
        let cellDecs = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.filterDecisions)(this.decisions, ['cells'], 0, 2);
        for (let dec of cellDecs) {
            if ((0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.localDiff, 'execution_count') !== null ||
                (0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.remoteDiff, 'execution_count') !== null ||
                (0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.customDiff, 'execution_count') !== null) {
                return dec;
            }
        }
        return null;
    }
    /**
     * Get the decision on `id` field (should only be one).
     *
     * Returns null if no decision on `id` was found.
     */
    getCellIdDecision() {
        let cellDecs = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.filterDecisions)(this.decisions, ['cells'], 0, 2);
        for (let dec of cellDecs) {
            if ((0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.localDiff, 'id') !== null ||
                (0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.remoteDiff, 'id') !== null ||
                (0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(dec.customDiff, 'id') !== null) {
                return dec;
            }
        }
        return null;
    }
    /**
     * Apply merge decisions to create the merged cell
     */
    serialize() {
        if (this.deleteCell) {
            return null;
        }
        if (this.base === null) {
            // Only possibility is that cell is added
            if (this.decisions.length > 1 || !this.merged.added) {
                throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_9__.NotifyUserError('Invalid cell decision');
            }
            let dec = this.decisions[0];
            // Either onesided or identical inserts, but possibly with
            // a custom diff on top!
            let d;
            if (dec.action === 'local' || dec.action === 'either') {
                if (!dec.localDiff) {
                    throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_9__.NotifyUserError('Invalid cell decision');
                }
                d = dec.localDiff[0];
            }
            else if (dec.action === 'remote') {
                if (!dec.remoteDiff) {
                    throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_9__.NotifyUserError('Invalid cell decision');
                }
                d = dec.remoteDiff[0];
            }
            else if (dec.action === 'custom') {
                if (!dec.customDiff) {
                    throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_9__.NotifyUserError('Invalid cell decision');
                }
                d = dec.customDiff[0];
            }
            else {
                throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_9__.NotifyUserError('Invalid cell decision');
            }
            if (d.op !== 'addrange') {
                throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_9__.NotifyUserError('Invalid cell decision');
            }
            return d.valuelist[0];
        }
        let decisions = [];
        for (let md of this.decisions) {
            let nmd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_4__.MergeDecision(md);
            nmd.level = 2;
            decisions.push(nmd);
        }
        let output = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.applyDecisions)(this.base, decisions);
        let src = output.source;
        if (Array.isArray(src)) {
            src = src.join('');
        }
        if (src !== this._merged.source.remote) {
            console.warn("Serialized outputs doesn't match model value! " +
                'Keeping the model value.');
            output.source = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.splitLines)(this._merged.source.remote);
        }
        if (this.clearOutputs && _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isCode(output)) {
            output.outputs = [];
        }
        return output;
    }
    processDecisions(decisions) {
        // First check for cell-level decisions:
        if (decisions.length === 1) {
            if ((0,_common_util__WEBPACK_IMPORTED_MODULE_6__.arraysEqual)(decisions[0].absolutePath, ['cells'])) {
                // We have a cell level decision
                let md = decisions[0];
                decisions = this.applyCellLevelDecision(md);
                if (decisions.length === 0) {
                    this.decisions.push(md);
                }
            }
        }
        for (let md of decisions) {
            md.level = 2;
            if (md.absolutePath.length < 2 || md.absolutePath[0] !== 'cells') {
                throw new Error('Not a valid path for a cell decision');
            }
            else if (md.absolutePath.length === 2 &&
                ((0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(md.localDiff) || (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(md.remoteDiff))) {
                // Have decision on /cells/X/.
                // Split the decision on subkey:
                // Nest diff as a patch on cell, which can be split by `splitPatch`:
                let splitDec = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.pushPatchDecision)(md, md.absolutePath.slice(1, 2));
                let localDiff = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(splitDec.localDiff)
                    ? splitDec.localDiff[0]
                    : null;
                let remoteDiff = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(splitDec.remoteDiff)
                    ? splitDec.remoteDiff[0]
                    : null;
                let subDecisions = this.splitPatch(splitDec, localDiff, remoteDiff);
                // Add all split decisions:
                for (let subdec of subDecisions) {
                    subdec.level = 2;
                    this.decisions.push(subdec);
                }
            }
            else {
                // Decision has path on subkey
                // Make local path relative to cell
                this.decisions.push(md);
            }
        }
    }
    /**
     * Apply a cell level decision to the model
     *
     * This creates the revelant kinds of models
     */
    applyCellLevelDecision(md) {
        let newDecisions = [];
        /* Possibilities:
         1. Insertion: base is null! Null diff of missing side (unchanged).
         2. Deletion: Null diff of present side (unchanged). Set deleteCell
            depending on action.
         3. Deletion vs patch: Same as 2., but split patch decision onto
            source/metadata/outputs.
         4. Identical ops (insertion or deletion)
         Cases that shouldn't happen:
         5. Insertion vs insertion: Shouldn't happen! Should have been split
            into two decisions with an insertion each before creating model.
         6. Patch vs patch: Shouldn't occur, as those should have been recursed
         */
        console.assert(!this.onesided, 'Cannot have multiple cell decisions on one cell!');
        this.onesided = true; // We set this to distinguish case 3 from normal
        if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(md.localDiff)) {
            // 1. or 2.:
            this._local = null;
            if (!md.remoteDiff || md.remoteDiff.length !== 1) {
                throw new Error('Merge decision does not conform to expectation: ' + md);
            }
            if (this.base === null) {
                // 1.
                let first = md.remoteDiff[0];
                if (first.op !== 'addrange') {
                    throw new Error('Merge decision does not conform to expectation: ' + md);
                }
                let v = first.valuelist[0];
                this._remote = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createAddedCellDiffModel)(v, this.mimetype);
                this._merged = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createAddedCellDiffModel)(v, this.mimetype);
            }
            else {
                // 2.
                this._remote = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                this._merged = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                this.deleteCell = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.valueIn)(md.action, ['remote', 'either']);
            }
        }
        else if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(md.remoteDiff)) {
            // 1. or 2.:
            this._remote = null;
            if (!md.localDiff || md.localDiff.length !== 1) {
                throw new Error('Merge decision does not conform to expectation: ' + md);
            }
            if (this.base === null) {
                // 1.
                let first = md.localDiff[0];
                if (first.op !== 'addrange') {
                    throw new Error('Merge decision does not conform to expectation: ' + md);
                }
                let v = first.valuelist[0];
                this._local = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createAddedCellDiffModel)(v, this.mimetype);
                this._merged = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createAddedCellDiffModel)(v, this.mimetype);
            }
            else {
                // 2.
                this._local = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                this._merged = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                this.deleteCell = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.valueIn)(md.action, ['local', 'either']);
            }
        }
        else {
            console.assert((0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(md.localDiff) && (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(md.remoteDiff));
            console.assert(md.localDiff.length === 1 && md.remoteDiff.length === 1);
            // 3. or 4.
            if (md.localDiff[0].op === md.remoteDiff[0].op) {
                // 4.
                if (this.base === null) {
                    // Identical insertions (this relies on preprocessing to ensure only
                    // one value in valuelist)
                    let v = md.localDiff[0].valuelist[0];
                    this._local = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createAddedCellDiffModel)(v, this.mimetype);
                    this._remote = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createAddedCellDiffModel)(v, this.mimetype);
                    this._merged = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createAddedCellDiffModel)(v, this.mimetype);
                }
                else {
                    // Identical delections
                    this._local = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                    this._remote = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                    this._merged = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                    this.deleteCell = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.valueIn)(md.action, ['local', 'remote', 'either']);
                }
            }
            else {
                // 3., by method of elimination
                let ops = [md.localDiff[0].op, md.remoteDiff[0].op];
                console.assert((0,_common_util__WEBPACK_IMPORTED_MODULE_6__.valueIn)('removerange', ops) && (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.valueIn)('patch', ops));
                if (this.base === null) {
                    throw new Error('Invalid merge decision, ' +
                        'cannot have null base for deleted cell: ' +
                        md);
                }
                if (ops[0] === 'removerange') {
                    this._local = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                    this.deleteCell = md.action === 'local';
                    // The patch op will be on cell level. Split it on sub keys!
                    newDecisions = newDecisions.concat(this.splitPatch(md, null, md.remoteDiff[0]));
                }
                else {
                    this._remote = (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createDeletedCellDiffModel)(this.base, this.mimetype);
                    this.deleteCell = md.action === 'remote';
                    // The patch op will be on cell level. Split it on sub keys!
                    newDecisions = newDecisions.concat(this.splitPatch(md, md.localDiff[0], null));
                }
                (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.resolveCommonPaths)(newDecisions);
            }
        }
        return newDecisions;
    }
    /**
     * Split a decision with a patch on one side into one decision
     * for each sub entry in the patch.
     */
    splitPatch(md, localPatch, remotePatch) {
        let local = !!localPatch && (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(localPatch.diff);
        let remote = !!remotePatch && (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(remotePatch.diff);
        if (!local && !remote) {
            return [];
        }
        let localDiff = local ? localPatch.diff : null;
        let remoteDiff = remote ? remotePatch.diff : null;
        let split = [];
        let keys = [];
        if (local) {
            for (let d of localDiff) {
                keys.push(d.key);
            }
        }
        if (remote) {
            for (let d of remoteDiff) {
                keys.push(d.key);
            }
        }
        keys = keys.filter(_common_util__WEBPACK_IMPORTED_MODULE_6__.unique);
        if (local && remote) {
            // Sanity check
            if (localPatch.key !== remotePatch.key) {
                throw new Error('Different keys of patch ops given to `splitPatch`.');
            }
        }
        let patchKey = local ? localPatch.key : remotePatch.key;
        for (let key of keys) {
            if (this._allowlist && !(0,_common_util__WEBPACK_IMPORTED_MODULE_6__.valueIn)(key, this._allowlist)) {
                throw new _common_exceptions__WEBPACK_IMPORTED_MODULE_9__.NotifyUserError('Currently not able to handle decisions on variable "' + key + '"');
            }
            let el = (0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(localDiff, key);
            let er = (0,_diff_util__WEBPACK_IMPORTED_MODULE_2__.getDiffEntryByKey)(remoteDiff, key);
            let onsesided = !(el && er);
            let action = md.action;
            // If one-sided, change 'base' actions to present side
            if (action === 'base' && onsesided) {
                action = el ? 'local' : 'remote';
            }
            // Create new action:
            split.push(new _merge_decisions__WEBPACK_IMPORTED_MODULE_4__.MergeDecision(md.absolutePath.concat([patchKey]), el ? [el] : null, er ? [er] : null, action, md.conflict));
        }
        let ret = this.splitOnSourceChunks(split);
        (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.resolveCommonPaths)(ret);
        return (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.stableSort)(ret, _merge_decisions__WEBPACK_IMPORTED_MODULE_4__.decisionSortKey);
    }
    /**
     * Split decisions on 'source' by chunks.
     *
     * This prevents one decision from contributing to more than one chunk.
     */
    splitOnSourceChunks(decisions) {
        let out = [];
        for (let i = 0; i < decisions.length; ++i) {
            let dec = decisions[i];
            if (dec.absolutePath[2] === 'source') {
                let base = this.base.source;
                if (!Array.isArray(base)) {
                    base = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.splitLines)(base);
                }
                dec.level = 3;
                let sub = (0,_chunking__WEBPACK_IMPORTED_MODULE_7__.splitMergeDecisionsOnChunks)(base, [dec]);
                (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_4__.resolveCommonPaths)(sub);
                out = out.concat((0,_common_util__WEBPACK_IMPORTED_MODULE_6__.stableSort)(sub, _merge_decisions__WEBPACK_IMPORTED_MODULE_4__.decisionSortKey));
            }
            else {
                out.push(dec);
            }
        }
        return out;
    }
    createDiffModel(diff) {
        if (this.base === null) {
            throw new Error('Cannot create a patched or unchanged diff model with null base!');
        }
        if (diff && diff.length > 0) {
            return (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createPatchedCellDiffModel)(this.base, diff, this.mimetype);
        }
        else {
            return (0,_diff_model__WEBPACK_IMPORTED_MODULE_3__.createUnchangedCellDiffModel)(this.base, this.mimetype);
        }
    }
    createMergedDiffModel() {
        if (this.base === null) {
            throw new Error('Cannot create a patched or unchanged merged diff model with null base!');
        }
        return createPatchedCellDecisionDiffModel(this.base, this.decisions, this.local, this.remote, this.mimetype);
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/model/common.js":
/*!*******************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/model/common.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DecisionStringDiffModel: () => (/* binding */ DecisionStringDiffModel),
/* harmony export */   ObjectMergeModel: () => (/* binding */ ObjectMergeModel)
/* harmony export */ });
/* harmony import */ var _diff_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../diff/range */ "./node_modules/nbdime/lib/diff/range.js");
/* harmony import */ var _diff_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../diff/model */ "./node_modules/nbdime/lib/diff/model/index.js");
/* harmony import */ var _merge_decisions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../merge/decisions */ "./node_modules/nbdime/lib/merge/decisions.js");
/* harmony import */ var _chunking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chunking */ "./node_modules/nbdime/lib/chunking/index.js");
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../patch */ "./node_modules/nbdime/lib/patch/index.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/**
 * A string diff model based on merge decisions.
 */
class DecisionStringDiffModel extends _diff_model__WEBPACK_IMPORTED_MODULE_1__.StringDiffModel {
    constructor(base, decisions, sourceModels, collapsible, header, collapsed) {
        // Set up initial parameters for super call
        let baseStr = (0,_patch__WEBPACK_IMPORTED_MODULE_4__.stringifyAndBlankNull)(base);
        super(baseStr, '', [], [], collapsible, header, collapsed);
        this.rawBase = base;
        this.decisions = decisions;
        this._outdated = true;
        this._sourceModels = sourceModels;
        this._update();
    }
    get additions() {
        if (this._outdated) {
            this._update();
        }
        return this._additions;
    }
    set additions(value) {
        this._additions = value;
    }
    get deletions() {
        if (this._outdated) {
            this._update();
        }
        return this._deletions;
    }
    set deletions(value) {
        this._deletions = value;
    }
    get remote() {
        if (this._outdated) {
            this._update();
        }
        return this._remote;
    }
    set remote(value) {
        this._remote = value;
    }
    invalidate() {
        this._outdated = true;
    }
    get invalid() {
        return this._outdated;
    }
    /**
     * Chunk additions/deletions into line-based chunks, while also producing
     * chunks from source models where the decision is a no-op (action 'base').
     */
    getLineChunks() {
        let models = [this];
        models = models.concat(this._sourceModels);
        let chunker = new _chunking__WEBPACK_IMPORTED_MODULE_3__.LineChunker();
        let iter = new _diff_model__WEBPACK_IMPORTED_MODULE_1__.StringDiffModel.SyncedDiffIter(models);
        for (let v = iter.next(); v !== undefined; v = iter.next()) {
            if (iter.currentModel() === this) {
                // Chunk diffs in own model normally
                // (they should already be present in own model)
                chunker.addDiff(v.range, v.isAddition);
            }
            else {
                // Skip ops in other models that are not no-ops
                if (!v.range.source || v.range.source.decision.action !== 'base') {
                    continue;
                }
                // Other model
                chunker.addGhost(v.range, v.isAddition, iter.currentOffset);
            }
        }
        return chunker.chunks;
    }
    _update() {
        this._outdated = false;
        let diff = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_2__.buildDiffs)(this.rawBase, this.decisions, 'merged');
        let out = (0,_patch__WEBPACK_IMPORTED_MODULE_4__.patchStringified)(this.rawBase, diff);
        this._additions = (0,_diff_range__WEBPACK_IMPORTED_MODULE_0__.raw2Pos)(out.additions, out.remote);
        this._deletions = (0,_diff_range__WEBPACK_IMPORTED_MODULE_0__.raw2Pos)(out.deletions, this.base || '');
        this._remote = out.remote;
    }
}
/**
 * Abstract base class for a merge model of objects of the type ObjectType,
 * which uses DiffModelType to model each side internally.
 *
 * Implementors need to define the abstract functions createDiffModel and
 * createMergedDiffModel.
 */
class ObjectMergeModel {
    /**
     *
     */
    constructor(base, decisions, mimetype, allowlist) {
        this._finalized = false;
        this.base = base;
        this.mimetype = mimetype;
        this._allowlist = allowlist || null;
        this.decisions = decisions;
    }
    /**
     * Apply merge decisions to create the merged cell
     */
    serialize() {
        if (this.base === null) {
            return null;
        }
        return (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_2__.applyDecisions)(this.base, this.decisions);
    }
    /**
     * Model of the local diff vs. base
     */
    get local() {
        if (this._local === undefined) {
            // We're builiding from decisions
            this._finalizeDecisions();
            let diff = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_2__.buildDiffs)(this.base, this.decisions, 'local');
            this._local = this.createDiffModel(diff);
        }
        return this._local;
    }
    /**
     * Model of the remote diff vs. base
     */
    get remote() {
        if (this._remote === undefined) {
            this._finalizeDecisions();
            let diff = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_2__.buildDiffs)(this.base, this.decisions, 'remote');
            this._remote = this.createDiffModel(diff);
        }
        return this._remote;
    }
    /**
     * Model of the diff of the merged cell vs. base
     */
    get merged() {
        if (this._merged === undefined) {
            this._finalizeDecisions();
            // Merge model needs access to local and remote models to also include
            // chunks from them
            this._merged = this.createMergedDiffModel();
        }
        return this._merged;
    }
    /**
     *
     */
    get subModels() {
        return [this.local, this.remote, this.merged];
    }
    /**
     * Prevent further changes to decisions, and label the diffs
     *
     * The labels are used for picking of decisions
     */
    _finalizeDecisions() {
        if (!this._finalized) {
            for (let md of this.decisions) {
                if (md.action === 'either') {
                    (0,_chunking__WEBPACK_IMPORTED_MODULE_3__.labelSource)(md.localDiff, { decision: md, action: 'either' });
                    (0,_chunking__WEBPACK_IMPORTED_MODULE_3__.labelSource)(md.remoteDiff, { decision: md, action: 'either' });
                }
                else {
                    (0,_chunking__WEBPACK_IMPORTED_MODULE_3__.labelSource)(md.localDiff, { decision: md, action: 'local' });
                    (0,_chunking__WEBPACK_IMPORTED_MODULE_3__.labelSource)(md.remoteDiff, { decision: md, action: 'remote' });
                }
                (0,_chunking__WEBPACK_IMPORTED_MODULE_3__.labelSource)(md.customDiff, { decision: md, action: 'custom' });
            }
            this._finalized = true;
        }
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/model/index.js":
/*!******************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/model/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellMergeModel: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.CellMergeModel),
/* harmony export */   DecisionStringDiffModel: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.DecisionStringDiffModel),
/* harmony export */   MetadataMergeModel: () => (/* reexport safe */ _metadata__WEBPACK_IMPORTED_MODULE_2__.MetadataMergeModel),
/* harmony export */   NotebookMergeModel: () => (/* reexport safe */ _notebook__WEBPACK_IMPORTED_MODULE_3__.NotebookMergeModel),
/* harmony export */   ObjectMergeModel: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.ObjectMergeModel)
/* harmony export */ });
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ "./node_modules/nbdime/lib/merge/model/cell.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/merge/model/common.js");
/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metadata */ "./node_modules/nbdime/lib/merge/model/metadata.js");
/* harmony import */ var _notebook__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notebook */ "./node_modules/nbdime/lib/merge/model/notebook.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/***/ }),

/***/ "./node_modules/nbdime/lib/merge/model/metadata.js":
/*!*********************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/model/metadata.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MetadataMergeModel: () => (/* binding */ MetadataMergeModel)
/* harmony export */ });
/* harmony import */ var _diff_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../diff/model */ "./node_modules/nbdime/lib/diff/model/index.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/merge/model/common.js");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * Model of a merge of metadata with decisions
 */
class MetadataMergeModel extends _common__WEBPACK_IMPORTED_MODULE_1__.ObjectMergeModel {
    constructor(base, decisions) {
        super(base, decisions, 'application/json');
    }
    serialize() {
        if (!this.merged || this.merged.remote === null) {
            throw new Error('Missing notebook metadata merge data.');
        }
        // This will check whether metadata is valid JSON.
        // Validation of compatibility vs notebook format
        // will happen on server side.
        return JSON.parse(this.merged.remote);
    }
    createDiffModel(diff) {
        if (diff && diff.length > 0) {
            return (0,_diff_model__WEBPACK_IMPORTED_MODULE_0__.createPatchStringDiffModel)(this.base, diff);
        }
        else {
            const baseCopy = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_2__.JSONExt.deepCopy(this.base);
            return (0,_diff_model__WEBPACK_IMPORTED_MODULE_0__.createDirectStringDiffModel)(baseCopy, baseCopy);
        }
    }
    createMergedDiffModel() {
        return new _common__WEBPACK_IMPORTED_MODULE_1__.DecisionStringDiffModel(this.base, this.decisions, [
            this.local,
            this.remote,
        ]);
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/model/notebook.js":
/*!*********************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/model/notebook.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotebookMergeModel: () => (/* binding */ NotebookMergeModel)
/* harmony export */ });
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _merge_decisions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../merge/decisions */ "./node_modules/nbdime/lib/merge/decisions.js");
/* harmony import */ var _chunking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../chunking */ "./node_modules/nbdime/lib/chunking/index.js");
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../patch */ "./node_modules/nbdime/lib/patch/index.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cell */ "./node_modules/nbdime/lib/merge/model/cell.js");
/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./metadata */ "./node_modules/nbdime/lib/merge/model/metadata.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







/**
 * Diff model for a Jupyter Notebook
 */
class NotebookMergeModel {
    static preprocessDecisions(rawMergeDecisions) {
        let mergeDecisions = [];
        for (let rmd of rawMergeDecisions) {
            mergeDecisions.push(new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(rmd));
        }
        mergeDecisions = splitCellChunks(mergeDecisions);
        mergeDecisions = splitCellRemovals(mergeDecisions);
        mergeDecisions = splitCellInsertions(mergeDecisions);
        mergeDecisions = splitCellListPatch(mergeDecisions);
        (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_1__.resolveCommonPaths)(mergeDecisions);
        for (let md of mergeDecisions) {
            if (md.action === 'either') {
                (0,_chunking__WEBPACK_IMPORTED_MODULE_2__.labelSource)(md.localDiff, { decision: md, action: 'either' });
                (0,_chunking__WEBPACK_IMPORTED_MODULE_2__.labelSource)(md.remoteDiff, { decision: md, action: 'either' });
            }
            else {
                (0,_chunking__WEBPACK_IMPORTED_MODULE_2__.labelSource)(md.localDiff, { decision: md, action: 'local' });
                (0,_chunking__WEBPACK_IMPORTED_MODULE_2__.labelSource)(md.remoteDiff, { decision: md, action: 'remote' });
            }
            (0,_chunking__WEBPACK_IMPORTED_MODULE_2__.labelSource)(md.customDiff, { decision: md, action: 'custom' });
        }
        return mergeDecisions;
    }
    /**
     * Create a new NotebookMergeModel from a base notebook and a list of
     * merge decisions.
     *
     * The base as well as the merge decisions are normally supplied by the
     * nbdime server.
     */
    constructor(base, rawMergeDecisions) {
        this.base = base;
        let ctor = this.constructor;
        let decisions = ctor.preprocessDecisions(rawMergeDecisions);
        // The notebook metadata MIME type is used for determining the MIME type
        // of source cells, so store it easily accessible:
        let mimetype;
        try {
            mimetype = base.metadata.language_info.mimetype;
        }
        catch (e) {
            // missing metadata(probably old notebook)
        }
        this.mimetype = mimetype || 'text/python';
        this.cells = this.buildCellList(decisions);
        let metadataDecs = (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_1__.filterDecisions)(decisions, ['metadata']);
        this.metadata = new _metadata__WEBPACK_IMPORTED_MODULE_5__.MetadataMergeModel(base.metadata, metadataDecs);
        this.unsavedChanges = false;
    }
    serialize() {
        let nb = {};
        // Simply copy all root-level fields except cells/metadata
        for (let key in this.base) {
            if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(key, ['cells', 'metadata'])) {
                nb[key] = this.base[key];
            }
        }
        // Serialize metadata
        nb['metadata'] = this.metadata.serialize();
        // Serialzie cell list
        let cells = [];
        for (let c of this.cells) {
            let s = c.serialize();
            if (s !== null) {
                cells.push(s);
            }
        }
        nb['cells'] = cells;
        // As long as base is a valid notebook, and sub-serialization is valid,
        // this output should be a valid notebook.
        return nb;
    }
    get decisions() {
        let ret = [];
        for (let c of this.cells) {
            ret = ret.concat(c.decisions);
        }
        ret = ret.concat(this.metadata.decisions);
        return ret;
    }
    get conflicts() {
        let ret = [];
        for (let md of this.decisions) {
            if (md.conflict) {
                ret.push(md);
            }
        }
        return ret;
    }
    /**
     * Correlate the different cells in the diff lists into a merge list
     */
    buildCellList(decisions) {
        // We have to check for merge decisions on the `cells` object in
        // order to check for added cells. This assumes that the common
        // paths of the merge decisions have been resolved. It also assumes that
        // no merge decision can have root as its common path.
        // Create arrays of base value and decisions to match base cell list
        let cellDecisions = [];
        for (let bc of this.base.cells) {
            // Create empty decisions array for now, add in below
            cellDecisions.push({ base: bc, decisions: [] });
        }
        let insertOffset = 0;
        // Assumes merge decisions come in order!
        for (let md of decisions) {
            let key = md.absolutePath;
            if (key.length < 1 || key[0] !== 'cells') {
                continue; // Only care about decisions on cells here
            }
            if ((0,_common_util__WEBPACK_IMPORTED_MODULE_0__.arraysEqual)(key, ['cells'])) {
                let idx = null;
                let insertion = false;
                for (let di of md.diffs) {
                    // Ensure diff has exactly one item:
                    if (!di || di.length === 0) {
                        continue;
                    }
                    // All keys should be the same since we run splitCellChunks first
                    idx = di[0].key;
                    if (di[0].op === 'addrange') {
                        // Insert entries into `cells` at idx
                        let offsetIdx = insertOffset + idx;
                        cellDecisions.splice(offsetIdx, 0, { base: null, decisions: [md] });
                        insertOffset += 1;
                        insertion = true; // flag to break outer loop
                        break;
                    }
                    // Only checking for insertions in this loop, since insertions can
                    // only be paired with other insertions.
                }
                if (insertion) {
                    continue;
                }
                // If we reach this point, it is not an insertion merge!
                if (idx === null) {
                    throw new Error('No index could be found for merge decision!');
                }
                let cds = cellDecisions[idx + insertOffset].decisions;
                cds.push(md);
            }
            else {
                // Has a path into a cell
                // Format specifies that these always comes before decisions that
                // change the order of cells, so index is straight forward!
                let idx = key[1];
                let cds = cellDecisions[idx].decisions;
                cds.push(md);
            }
        }
        let cells = [];
        for (let cellInfo of cellDecisions) {
            cells.push(new _cell__WEBPACK_IMPORTED_MODULE_4__.CellMergeModel(cellInfo.base, cellInfo.decisions, this.mimetype));
        }
        return cells;
    }
}
function isChunk(diff) {
    return !!diff && diff.length === 2 && diff[0].key === diff[1].key;
}
/**
 * The merge format allows for chunking of sequence diffs such that one or more
 * entries in the diff lists have 2 entries, where the first is always an
 * insertion (addrange). For cells, we split these decisions in two, for easier
 * visualization. Note: When several diff entries have 2 entries, the second
 * entries are identical.
 */
function splitCellChunks(mergeDecisions) {
    let output = [];
    for (let md of mergeDecisions) {
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_0__.arraysEqual)(md.absolutePath, ['cells'])) {
            if (md.localDiff && !md.remoteDiff) {
                for (let d of md.localDiff) {
                    let nmd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md);
                    nmd.localDiff = [d];
                    output.push(nmd);
                }
            }
            else if (md.remoteDiff && !md.localDiff) {
                for (let d of md.remoteDiff) {
                    let nmd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md);
                    nmd.absolutePath = md.absolutePath.slice();
                    nmd.remoteDiff = [d];
                    output.push(nmd);
                }
            }
            else if (isChunk(md.localDiff)) {
                if (isChunk(md.remoteDiff)) {
                    // Both diffs are chunks, split adds vs agreed removes
                    let nmd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md);
                    nmd.localDiff = md.localDiff.slice(0, 1);
                    nmd.remoteDiff = md.remoteDiff.slice(0, 1);
                    output.push(nmd);
                    output.push(new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md.absolutePath.slice(), md.localDiff.slice(1), md.remoteDiff.slice(1), 'either'));
                }
                else {
                    // Split off local
                    let nmd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md);
                    nmd.localDiff = md.localDiff.slice(0, 1);
                    output.push(nmd);
                    output.push(new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md.absolutePath.slice(), md.localDiff.slice(1), [], 'local', // Check for custom action first?
                    md.conflict));
                }
            }
            else if (isChunk(md.remoteDiff)) {
                // Split off remote
                let nmd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md);
                nmd.remoteDiff = md.remoteDiff.slice(0, 1);
                output.push(nmd);
                output.push(new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md.absolutePath.slice(), [], md.remoteDiff.slice(1), 'remote', // Check for custom action first?
                md.conflict));
            }
            else if ((0,_common_util__WEBPACK_IMPORTED_MODULE_0__.hasEntries)(md.remoteDiff) && (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.hasEntries)(md.localDiff)) {
                const ops = [md.remoteDiff[0].op, md.localDiff[0].op].sort();
                if (ops.join(',') === 'addrange,removerange') {
                    // Insertion and deletions on the same index are simply split
                    // but both keep the conflict status
                    // Just do local first (alt. do add first)
                    let lmd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md);
                    lmd.action = 'local';
                    lmd.localDiff = md.localDiff.slice();
                    lmd.remoteDiff = null;
                    output.push(lmd);
                    let rmd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md);
                    rmd.action = 'remote';
                    rmd.localDiff = null;
                    rmd.remoteDiff = md.remoteDiff.slice();
                    output.push(rmd);
                }
                else {
                    output.push(md); // deepCopy?
                }
            }
            else {
                output.push(md); // deepCopy?
            }
        }
        else {
            output.push(md);
        }
    }
    (0,_merge_decisions__WEBPACK_IMPORTED_MODULE_1__.resolveCommonPaths)(output);
    return output;
}
/**
 * If any decisions have diffs on different cells, split them
 * up for one decision per cell.
 */
function splitCellListPatch(mergeDecisions) {
    let output = [];
    for (let md of mergeDecisions) {
        if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.arraysEqual)(md.absolutePath, ['cells'])) {
            output.push(md);
            continue;
        }
        // Null out empty diffs
        let dl = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.hasEntries)(md.localDiff) ? md.localDiff : null;
        let dr = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.hasEntries)(md.remoteDiff) ? md.remoteDiff : null;
        if (dl && dl.length < 2 && dr && dr.length < 2) {
            // Single cell affected
            output.push(md);
            continue;
        }
        // Before this is called, we should have split up chunks
        // as well as range addition/removal, so all diffs
        // should have different keys
        let maxlen = Math.max(dl ? dl.length : 0, dr ? dr.length : 0);
        for (let i = 0; i < maxlen; ++i) {
            let subdl = dl && i < dl.length ? [dl[i]] : null;
            let subdr = dr && i < dr.length ? [dr[i]] : null;
            output.push(new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md.absolutePath.slice(), subdl, subdr, md.action, md.conflict));
        }
    }
    return (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.stableSort)(output, _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.decisionSortKey);
}
/**
 * Split "removerange" diffs on cell list level into individual decisions!
 */
function splitCellRemovals(mergeDecisions) {
    let output = [];
    let makeSplitPart = function (md, key, local, remote) {
        let newMd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md.absolutePath.slice(), null, null, md.action, md.conflict);
        let newDiff = [
            {
                key: key,
                op: 'removerange',
                length: 1,
            },
        ];
        console.assert(local || remote);
        if (local) {
            newMd.localDiff = newDiff;
        }
        if (remote) {
            newMd.remoteDiff = newDiff;
        }
        return newMd;
    };
    for (let md of mergeDecisions) {
        if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.arraysEqual)(md.absolutePath, ['cells'])) {
            output.push(md);
            continue;
        }
        let dl = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.hasEntries)(md.localDiff)
            ? md.localDiff[md.localDiff.length - 1]
            : null;
        let dr = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.hasEntries)(md.remoteDiff)
            ? md.remoteDiff[md.remoteDiff.length - 1]
            : null;
        // TODO: Does it make sense to split on custom?
        if ((dl && !dr) || (dr && !dl)) {
            // One-way diff
            let d = dl ? dl : dr;
            if (d.op === 'removerange' && d.length > 1) {
                // Found a one-way diff to split!
                for (let i = 0; i < d.length; ++i) {
                    output.push(makeSplitPart(md, d.key + i, !!dl, !!dr));
                }
            }
            else {
                // Not a removerange type:
                output.push(md);
                continue;
            }
        }
        else if (dr && dl) {
            // Two way diff, keys need to be matched
            if (dl.op !== 'removerange' && dr.op !== 'removerange') {
                // Not a removerange type:
                output.push(md);
                continue;
            }
            else if (dl.op === dr.op) {
                // Both sides have removerange, just match keys/length
                // Note: Assume that ranges have overlap, since they are in one decision
                let klStart = dl.key;
                let krStart = dr.key;
                let start = Math.min(klStart, krStart);
                let klEnd = klStart + dl.length;
                let krEnd = krStart + dr.length;
                let end = Math.max(klEnd, krEnd);
                for (let i = start; i < end; ++i) {
                    let local = i >= klStart && i < klEnd;
                    let remote = i >= krStart && i < krEnd;
                    output.push(makeSplitPart(md, i, local, remote));
                }
            }
            else {
                // One side has removerange, the other a patch op (implied)
                let remLocal = dl.op === 'removerange';
                let rOp = (remLocal ? dl : dr);
                let pOp = (remLocal ? dr : dl);
                console.assert(pOp.op === 'patch');
                let pidx = pOp.key;
                let start = rOp.key;
                for (let i = start; i < start + rOp.length; ++i) {
                    let newMd = makeSplitPart(md, i, remLocal, !remLocal);
                    if (i === pidx) {
                        if (remLocal) {
                            newMd.remoteDiff = [pOp];
                        }
                        else {
                            newMd.localDiff = [pOp];
                        }
                    }
                    output.push(newMd);
                }
            }
        }
    }
    return output;
}
/**
 * Split "addrange" diffs on cell list level into individual decisions!
 * Also splits two-way insertions into two individual ones.
 */
function splitCellInsertions(mergeDecisions) {
    let output = [];
    let makeSplitPart = function (md, value, local, remote) {
        let newMd = new _merge_decisions__WEBPACK_IMPORTED_MODULE_1__.MergeDecision(md.absolutePath.slice(), null, null, md.action, md.conflict);
        if ((local && !(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.hasEntries)(md.localDiff)) ||
            (!local && !(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.hasEntries)(md.remoteDiff))) {
            throw new Error('Invalid input: ' + md);
        }
        let key = (local ? md.localDiff : md.remoteDiff)[0].key;
        let newDiff = [
            {
                key: key,
                op: 'addrange',
                valuelist: [value],
            },
        ];
        console.assert(local || remote);
        if (local) {
            newMd.localDiff = newDiff;
        }
        if (remote) {
            newMd.remoteDiff = newDiff;
        }
        return newMd;
    };
    for (let md of mergeDecisions) {
        // Just push decisions not on cells list:
        if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.arraysEqual)(md.absolutePath, ['cells'])) {
            output.push(md);
            continue;
        }
        // Check wether all diffs are pure addrange
        let correctType = true;
        if (md.localDiff) {
            for (let dl of md.localDiff) {
                if (dl.op !== 'addrange') {
                    correctType = false;
                    break;
                }
            }
        }
        if (md.remoteDiff) {
            for (let dl of md.remoteDiff) {
                if (dl.op !== 'addrange') {
                    correctType = false;
                    break;
                }
            }
        }
        if (!correctType) {
            output.push(md);
            continue;
        }
        let dl = md.localDiff && md.localDiff.length === 1
            ? md.localDiff[0]
            : null;
        let dr = md.remoteDiff && md.remoteDiff.length === 1
            ? md.remoteDiff[0]
            : null;
        if ((dl && !dr) || (dr && !dl)) {
            // One-way diff
            let d = dl ? dl : dr;
            let insert = d.valuelist;
            for (let v of insert) {
                output.push(makeSplitPart(md, v, !!dl, !!dr));
            }
        }
        else if (dl && dr) {
            // Two way diff
            // First, check if both insertions are equal!
            let eq = (0,_patch__WEBPACK_IMPORTED_MODULE_3__.stringify)(dl.valuelist) === (0,_patch__WEBPACK_IMPORTED_MODULE_3__.stringify)(dr.valuelist);
            if (eq) {
                // Split to one decision per cell
                for (let c of dl.valuelist) {
                    output.push(makeSplitPart(md, c, true, true));
                }
            }
            else {
                // Next, check decision for ruling on order (e.g.
                // local_then_remote, which we will use as the default).
                let start = dl.key;
                console.assert(start === dr.key);
                if (md.action === 'remote_then_local') {
                    // Only case where we need to switch order!
                    for (let c of dr.valuelist) {
                        const part = makeSplitPart(md, c, false, true);
                        part.action = 'remote';
                        output.push(part);
                    }
                    for (let c of dl.valuelist) {
                        const part = makeSplitPart(md, c, true, false);
                        part.action = 'local';
                        output.push(part);
                    }
                }
                else {
                    for (let c of dl.valuelist) {
                        const part = makeSplitPart(md, c, true, false);
                        part.action = 'local';
                        output.push(part);
                    }
                    for (let c of dr.valuelist) {
                        const part = makeSplitPart(md, c, false, true);
                        part.action = 'remote';
                        output.push(part);
                    }
                }
            }
        }
    }
    return output;
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/widget/cell.js":
/*!******************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/widget/cell.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CELLMERGE_CLASS: () => (/* binding */ CELLMERGE_CLASS),
/* harmony export */   CellMergeWidget: () => (/* binding */ CellMergeWidget)
/* harmony export */ });
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/nbformat */ "webpack/sharing/consume/default/@jupyterlab/nbformat");
/* harmony import */ var _jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_basepanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/basepanel */ "./node_modules/nbdime/lib/common/basepanel.js");
/* harmony import */ var _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/collapsiblepanel */ "./node_modules/nbdime/lib/common/collapsiblepanel.js");
/* harmony import */ var _common_dragpanel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/dragpanel */ "./node_modules/nbdime/lib/common/dragpanel.js");
/* harmony import */ var _common_mergeview__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/mergeview */ "./node_modules/nbdime/lib/common/mergeview.js");
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _diff_model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../diff/model */ "./node_modules/nbdime/lib/diff/model/index.js");
/* harmony import */ var _diff_widget__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../diff/widget */ "./node_modules/nbdime/lib/diff/widget/index.js");
/* harmony import */ var _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../upstreaming/flexpanel */ "./node_modules/nbdime/lib/upstreaming/flexpanel.js");
/* harmony import */ var _output__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./output */ "./node_modules/nbdime/lib/merge/widget/output.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/merge/widget/common.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.













const CELLMERGE_CLASS = 'jp-Cell-merge';
const CELL_HEADER_CLASS = 'jp-Merge-cellHeader';
const CELL_HEADER_TITLE_CLASS = 'jp-Merge-cellHeader-title';
const MARKED_DELETE = 'jp-mod-todelete';
const MARKED_CLEAR_OUTPUTS = 'jp-mod-clearoutputs';
const CLEAR_OUTPUT_TOGGLE_CLASS = 'jp-Merge-clearOutput-toggle';
const DELETE_CELL_TOGGLE_CLASS = 'jp-Merge-delete-cell-toggle';
const EXECUTIONCOUNT_ROW_CLASS = 'jp-Cellrow-executionCount';
const SOURCE_ROW_CLASS = 'jp-Cellrow-source';
const METADATA_ROW_CLASS = 'jp-Cellrow-metadata';
const OUTPUTS_ROW_CLASS = 'jp-Cellrow-outputs';
const OUTPUTS_CONFLICTED_CLASS = 'jp-conflicted-outputs';
const MARK_OUTPUTS_RESOLVED_CLASS = 'jp-conflicted-outputs-button';
const CELL_ID_CONFLICTED_CLASS = 'jp-conflicted-cellId';
/**
 * CellMergeWidget for cell changes
 */
class CellMergeWidget extends _common_basepanel__WEBPACK_IMPORTED_MODULE_2__.MergePanel {
    static createMergeView({ merged, editorFactory, readOnly, ...others }) {
        let view = null;
        if (merged instanceof _diff_model__WEBPACK_IMPORTED_MODULE_7__.StringDiffModel) {
            view = (0,_common_mergeview__WEBPACK_IMPORTED_MODULE_5__.createNbdimeMergeView)({
                merged,
                readOnly: readOnly ?? false,
                factory: editorFactory,
                ...others,
            });
        }
        return view;
    }
    static getOutputs(models, base) {
        let raw = [];
        for (let m of models) {
            if (base === true) {
                if (m.base) {
                    raw.push(m.base);
                }
            }
            else {
                if (m.remote) {
                    raw.push(m.remote);
                }
            }
        }
        return raw;
    }
    /**
     *
     */
    constructor({ rendermime, mimetype, ...options }) {
        super(options);
        this.sourceView = null;
        this.metadataView = null;
        this.outputViews = null;
        this.addClass(CELLMERGE_CLASS);
        this._rendermime = rendermime;
        this._trans = this._translator.load('nbdime');
        this.mimetype = mimetype;
        this.init();
    }
    validateMerged(candidate) {
        if (this.sourceView && this.sourceView instanceof _common_mergeview__WEBPACK_IMPORTED_MODULE_5__.MergeView) {
            let text = this.sourceView.getMergedValue();
            let lines = (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.splitLines)(text);
            if (candidate.source !== lines) {
                candidate.source = lines;
            }
        }
        if (this.metadataView && this.metadataView instanceof _common_mergeview__WEBPACK_IMPORTED_MODULE_5__.MergeView) {
            let text = this.metadataView.getMergedValue();
            if (JSON.stringify(candidate.metadata) !== text) {
                // This will need to be validated server side,
                // and should not be touched by client side
                // (structure might differ from assumed form)
                candidate.metadata = JSON.parse(text);
            }
        }
        if (_jupyterlab_nbformat__WEBPACK_IMPORTED_MODULE_0__.isCode(candidate) && this.outputViews) {
            let model = this.outputViews.merged;
            let outputs = model.toJSON();
            candidate.outputs = outputs;
        }
        return candidate;
    }
    init() {
        let model = this.model;
        let CURR_CLASSES = _common__WEBPACK_IMPORTED_MODULE_11__.MERGE_CLASSES.slice(); // copy
        this.createHeader();
        // Mark cells that have no changes:
        if (model.merged.unchanged &&
            model.local &&
            model.local.unchanged &&
            model.remote &&
            model.remote.unchanged) {
            this.addClass(_common__WEBPACK_IMPORTED_MODULE_11__.UNCHANGED_MERGE_CLASS);
        }
        /*
         Two different display layouts depending on cell merge type:
         1. Unchanged or one way insert/delete of cell, or identical insert/delete:
            Single r/w editor (merged), with appropriate coloring for insert/delete
         2. Everything else:
            Full 4x merge view
        */
        let ladd = model.local && model.local.added;
        let ldel = model.local && model.local.deleted;
        let radd = model.remote && model.remote.added;
        let rdel = model.remote && model.remote.deleted;
        if ((ladd && !radd) || (ldel && !rdel)) {
            this.headerTitle = ladd
                ? this._trans.__('Cell added locally')
                : this._trans.__('Cell deleted locally');
        }
        else if ((radd && !ladd) || (rdel && !ldel)) {
            this.headerTitle = radd
                ? this._trans.__('Cell added remotely')
                : this._trans.__('Cell deleted remotely');
        }
        if (model.local === null ||
            model.remote === null || // One sided change
            (model.local.unchanged &&
                model.remote.unchanged &&
                model.merged.unchanged) || // Unchanged
            model.local.added !== model.remote.added || // Onesided addition
            (model.local.deleted && model.remote.unchanged) || // Onesided deletion (other side unchanged)
            (model.local.unchanged && model.remote.deleted) || // Onesided deletion (other side unchanged)
            (model.local.added && model.agreedCell) || // Identical additions
            (model.local.deleted && model.remote.deleted) // Deletion on both
        ) {
            CURR_CLASSES = CURR_CLASSES.slice(1, 3);
            // Add single view of source:
            let view = _diff_widget__WEBPACK_IMPORTED_MODULE_8__.CellDiffWidget.createView({
                model: model.merged.source,
                parent: model.merged,
                editorClasses: CURR_CLASSES,
                rendermime: this._rendermime,
                editorFactory: this._editorFactory,
                translator: this._translator,
            });
            if ((ladd && !radd) || (ldel && !rdel)) {
                this.addClass(_common__WEBPACK_IMPORTED_MODULE_11__.ONEWAY_LOCAL_CLASS);
            }
            else if ((radd && !ladd) || (rdel && !ldel)) {
                this.addClass(_common__WEBPACK_IMPORTED_MODULE_11__.ONEWAY_REMOTE_CLASS);
            }
            else if (ldel && rdel) {
                this.headerTitle = this._trans.__('Deleted on both sides');
                this.addClass(_common__WEBPACK_IMPORTED_MODULE_11__.TWOWAY_DELETION_CLASS);
            }
            else if (ladd && radd) {
                this.headerTitle = this._trans.__('Added on both sides');
                this.addClass(_common__WEBPACK_IMPORTED_MODULE_11__.TWOWAY_ADDITION_CLASS);
            }
            view.addClass(SOURCE_ROW_CLASS);
            this.addWidget(view);
            if ((0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(model.merged.outputs)) {
                // Add single view of rendered output
                let container = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Panel();
                for (let m of model.merged.outputs) {
                    view = _diff_widget__WEBPACK_IMPORTED_MODULE_8__.CellDiffWidget.createView({
                        model: m,
                        parent: model.merged,
                        editorClasses: CURR_CLASSES,
                        rendermime: this._rendermime,
                        editorFactory: this._editorFactory,
                        translator: this._translator,
                    });
                    container.addWidget(view);
                }
                container.addClass(OUTPUTS_ROW_CLASS);
                this.addWidget(container);
            }
        }
        else {
            // Setup full 4-way mergeview of source, metadata and outputs
            // as needed (if changed). Source/metadata/output are each a "row"
            let execDec = model.getExecutionCountDecision();
            if (execDec && execDec.action === 'clear') {
                let row = new _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_9__.FlexPanel({ direction: 'left-to-right' });
                row.addClass(EXECUTIONCOUNT_ROW_CLASS);
                let textWidget = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget();
                textWidget.node.textContent = this._trans.__('Execution count will be cleared.');
                row.addWidget(textWidget);
                this.addWidget(row);
            }
            let idDec = model.getCellIdDecision();
            if (idDec && idDec.conflict) {
                this.headerTitle = this._trans.__('Cell has conflicting IDs! Use a text editor to edit the value (base value kept).');
                this.addClass(CELL_ID_CONFLICTED_CLASS);
            }
            let sourceView = null;
            if (model.local &&
                model.local.source.unchanged &&
                model.remote &&
                model.remote.source.unchanged &&
                model.merged.source.unchanged) {
                // Use single unchanged view of source
                sourceView = _diff_widget__WEBPACK_IMPORTED_MODULE_8__.CellDiffWidget.createView({
                    model: model.merged.source,
                    parent: model.merged,
                    editorClasses: CURR_CLASSES,
                    rendermime: this._rendermime,
                    editorFactory: this._editorFactory,
                    translator: this._translator,
                });
            }
            else {
                sourceView = CellMergeWidget.createMergeView({
                    local: model.local ? model.local.source : null,
                    remote: model.remote ? model.remote.source : null,
                    merged: model.merged.source,
                    editorClasses: CURR_CLASSES,
                    editorFactory: this._editorFactory,
                    translator: this._translator,
                    ...this._viewOptions,
                });
            }
            if (sourceView === null) {
                throw new Error('Was not able to create merge view for cell!');
            }
            this.sourceView = sourceView;
            sourceView.addClass(SOURCE_ROW_CLASS);
            this.addWidget(sourceView);
            let metadataChanged = false;
            let outputsChanged = false;
            for (let m of model.subModels) {
                if (!m || m.deleted) {
                    // Don't consider deleted cells
                    continue;
                }
                metadataChanged =
                    metadataChanged || (!!m.metadata && !m.metadata.unchanged);
                if (m.outputs && m.outputs.length > 0) {
                    for (let o of m.outputs) {
                        outputsChanged = outputsChanged || !o.unchanged;
                    }
                }
            }
            if (metadataChanged) {
                let metadataView = CellMergeWidget.createMergeView({
                    local: model.local ? model.local.metadata : null,
                    remote: model.remote ? model.remote.metadata : null,
                    merged: model.merged.metadata,
                    editorClasses: CURR_CLASSES,
                    editorFactory: this._editorFactory,
                    translator: this._translator,
                    ...this._viewOptions,
                    readOnly: true, // Do not allow manual edit of metadata
                });
                if (metadataView === null) {
                    throw new Error('Was not able to create merge view for cell metadata!');
                }
                this.metadataView = metadataView;
                let container = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Panel();
                container.addWidget(metadataView);
                let header = this._trans.__('Metadata changed');
                let collapser = new _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_3__.CollapsiblePanel(container, header, true);
                collapser.addClass(METADATA_ROW_CLASS);
                this.addWidget(collapser);
            }
            if (outputsChanged || (0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(model.merged.outputs)) {
                // We know here that we have code cell
                // -> all have outputs !== null
                let baseOut = CellMergeWidget.getOutputs(model.local ? model.local.outputs : [], true);
                let localOut = CellMergeWidget.getOutputs(model.local ? model.local.outputs : []);
                let remoteOut = CellMergeWidget.getOutputs(model.remote ? model.remote.outputs : []);
                let mergedOut = CellMergeWidget.getOutputs(model.merged.outputs);
                let view = new _output__WEBPACK_IMPORTED_MODULE_10__.RenderableOutputsMergeView(mergedOut, _common__WEBPACK_IMPORTED_MODULE_11__.MERGE_CLASSES, this._rendermime, baseOut, remoteOut, localOut, this._viewOptions.showBase);
                this.outputViews = view;
                let header = outputsChanged
                    ? model.outputsConflicted
                        ? this._trans.__('Outputs conflicted')
                        : this._trans.__('Outputs changed')
                    : this._trans.__('Outputs unchanged');
                let collapser = new _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_3__.CollapsiblePanel(view, header, !outputsChanged);
                collapser.addClass(OUTPUTS_ROW_CLASS);
                if (model.outputsConflicted) {
                    collapser.addClass(OUTPUTS_CONFLICTED_CLASS);
                    let conflictClearBtn = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget();
                    conflictClearBtn.addClass(MARK_OUTPUTS_RESOLVED_CLASS);
                    let node = conflictClearBtn.node;
                    let btn = document.createElement('button');
                    btn.onclick = (ev) => {
                        if (ev.button !== 0) {
                            return; // Only main button clicks
                        }
                        model.clearOutputConflicts();
                        collapser.removeClass(OUTPUTS_CONFLICTED_CLASS);
                        collapser.headerTitle = this._trans.__('Outputs changed');
                        ev.preventDefault();
                        ev.stopPropagation();
                        conflictClearBtn.parent = null;
                    };
                    btn.textContent = this._trans.__('Mark resolved');
                    node.appendChild(btn);
                    collapser.header.insertWidget(1, conflictClearBtn);
                }
                this.addWidget(collapser);
            }
        }
    }
    createHeader() {
        let header = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Panel();
        header.addClass(CELL_HEADER_CLASS);
        // Add drag handle
        let w = _common_dragpanel__WEBPACK_IMPORTED_MODULE_4__.DragPanel.createDefaultHandle();
        header.addWidget(w);
        // Add title widget
        w = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget();
        this.headerTitleWidget = w;
        w.addClass(CELL_HEADER_TITLE_CLASS);
        header.addWidget(w);
        if ((0,_common_util__WEBPACK_IMPORTED_MODULE_6__.hasEntries)(this.model.merged.outputs)) {
            // Add "clear outputs" checkbox
            let clearOutputToggle = this._createClearOutputToggle();
            header.addWidget(clearOutputToggle);
        }
        // Add "delete cell" checkbox
        let deleteToggle = this._createDeleteToggle();
        header.addWidget(deleteToggle);
        // Add header to widget
        this.addWidget(header);
        this.header = header;
    }
    _createClearOutputToggle() {
        let { checkbox, widget } = (0,_common__WEBPACK_IMPORTED_MODULE_11__.createCheckbox)(this.model.clearOutputs, this._trans.__('Clear outputs'));
        if (this.model.clearOutputs) {
            this.addClass(MARKED_CLEAR_OUTPUTS);
        }
        // Map checkbox -> model
        checkbox.onchange = event => {
            this.model.clearOutputs = checkbox.checked;
            this.toggleClass(MARKED_CLEAR_OUTPUTS, checkbox.checked);
        };
        // Map model -> checkbox
        this.model.clearOutputsChanged.connect((_model, value) => {
            checkbox.checked = value;
            this.toggleClass(MARKED_CLEAR_OUTPUTS, value);
        });
        widget.addClass(CLEAR_OUTPUT_TOGGLE_CLASS);
        return widget;
    }
    _createDeleteToggle() {
        let { checkbox, widget } = (0,_common__WEBPACK_IMPORTED_MODULE_11__.createCheckbox)(this.model.deleteCell, this._trans.__('Delete cell'));
        if (this.model.deleteCell) {
            this.addClass(MARKED_DELETE);
        }
        // Map checkbox -> model
        checkbox.onchange = event => {
            this.model.deleteCell = checkbox.checked;
            this.toggleClass(MARKED_DELETE, checkbox.checked);
        };
        // Map model -> checkbox
        this.model.deleteCellChanged.connect((_model, value) => {
            checkbox.checked = value;
            this.toggleClass(MARKED_DELETE, value);
        });
        widget.addClass(DELETE_CELL_TOGGLE_CLASS);
        return widget;
    }
    set headerTitle(value) {
        this.headerTitleWidget.node.innerText = value;
    }
    /**
     * Get the model for the widget.
     *
     * #### Notes
     * This is a read-only property.
     */
    get model() {
        return this._model;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/widget/common.js":
/*!********************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/widget/common.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MERGE_CLASSES: () => (/* binding */ MERGE_CLASSES),
/* harmony export */   ONEWAY_LOCAL_CLASS: () => (/* binding */ ONEWAY_LOCAL_CLASS),
/* harmony export */   ONEWAY_REMOTE_CLASS: () => (/* binding */ ONEWAY_REMOTE_CLASS),
/* harmony export */   TWOWAY_ADDITION_CLASS: () => (/* binding */ TWOWAY_ADDITION_CLASS),
/* harmony export */   TWOWAY_DELETION_CLASS: () => (/* binding */ TWOWAY_DELETION_CLASS),
/* harmony export */   UNCHANGED_MERGE_CLASS: () => (/* binding */ UNCHANGED_MERGE_CLASS),
/* harmony export */   createCheckbox: () => (/* binding */ createCheckbox)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


// Merge classes:
const UNCHANGED_MERGE_CLASS = 'jp-Merge-unchanged';
const ONEWAY_LOCAL_CLASS = 'jp-Merge-oneway-local';
const ONEWAY_REMOTE_CLASS = 'jp-Merge-oneway-remote';
const TWOWAY_ADDITION_CLASS = 'jp-Merge-twoway-addition';
const TWOWAY_DELETION_CLASS = 'jp-Merge-twoway-deletion';
const BASE_MERGE_CLASS = 'jp-Merge-base';
const LOCAL_MERGE_CLASS = 'jp-Merge-local';
const REMOTE_MERGE_CLASS = 'jp-Merge-remote';
const MERGED_MERGE_CLASS = 'jp-Merge-merged';
const MERGE_CLASSES = [
    BASE_MERGE_CLASS,
    LOCAL_MERGE_CLASS,
    REMOTE_MERGE_CLASS,
    MERGED_MERGE_CLASS,
];
/**
 * Create a widget containing a checkbox with a label.
 *
 * @export
 * @param {boolean} value - The initial check state (true = checked)
 * @param {string} text - The text of the label
 * @returns {{checkbox: HTMLInputElement, widget: Widget }}
 */
function createCheckbox(value, text, indeterminate = false) {
    let checkbox = document.createElement('input');
    checkbox.setAttribute('type', 'checkbox');
    checkbox.checked = value;
    checkbox.indeterminate = indeterminate;
    // Create label for checkbox:
    let widget = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget();
    let label = document.createElement('label');
    label.textContent = text;
    // Combine checkbox and label:
    label.insertBefore(checkbox, label.childNodes[0]);
    // Add checkbox to header:
    widget.node.appendChild(label);
    return { checkbox, widget };
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/widget/dragdrop.js":
/*!**********************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/widget/dragdrop.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellsDragDrop: () => (/* binding */ CellsDragDrop),
/* harmony export */   ChunkedCellsWidget: () => (/* binding */ ChunkedCellsWidget)
/* harmony export */ });
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_dragpanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/dragpanel */ "./node_modules/nbdime/lib/common/dragpanel.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





const CELL_DRAG_DROP_CLASS = 'jp-merge-celldragdrop';
const MARK_CHUNK_RESOLVED_CLASS = 'jp-conflicted-cells-button';
const CHUNK_HEADER_CLASS = 'jp-conflicted-cells-header';
const CONFLICTED_CELL_CHUNK_CLASS = 'jp-conflicted-cells';
class CellsDragDrop extends _common_dragpanel__WEBPACK_IMPORTED_MODULE_3__.FriendlyDragDrop {
    /**
     *
     */
    constructor(options) {
        super(options);
        this._moved = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);
        this.addClass(CELL_DRAG_DROP_CLASS);
    }
    /**
     * Called when something has been dropped in the panel.
     *
     * As only internal moves are supported, we know the type of the keys
     */
    move(from, to) {
        let friendFromId = from[0];
        let friendToId = to[0];
        let widgetFromId = from[1];
        let widgetToId = to[1];
        let adjustedTo = widgetToId;
        if (friendFromId === friendToId) {
            if (widgetToId > widgetFromId) {
                // Have to adjust index for insertWidget in same instance
                adjustedTo -= 1;
                to[1] = adjustedTo;
            }
            else if (widgetFromId === widgetToId) {
                // No-op, same position
                return;
            }
        }
        let toPanel = this.friends[friendToId];
        let fromPanel = this.friends[friendFromId];
        const cell = fromPanel.widgets[widgetFromId];
        toPanel.insertWidget(adjustedTo, cell);
        this._moved.emit({
            widget: cell,
            oldParent: fromPanel,
            before: adjustedTo > 0
                ? toPanel.widgets[adjustedTo - 1]
                : null,
            after: adjustedTo < toPanel.widgets.length
                ? toPanel.widgets[adjustedTo + 1]
                : null,
        });
    }
    get moved() {
        return this._moved;
    }
}
class ChunkedCellsWidget extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Panel {
    /**
     *
     */
    constructor({ translator } = {}) {
        super();
        this._resolved = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);
        const trans = (translator ?? _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator).load('nbdime');
        this.addClass(CONFLICTED_CELL_CHUNK_CLASS);
        this.header = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget();
        this.header.addClass(CHUNK_HEADER_CLASS);
        this.header.node.textContent = trans.__('Conflicting cell operations');
        let button = document.createElement('button');
        button.textContent = trans.__('Resolve Conflict');
        button.onclick = this.onResolve.bind(this);
        button.className = MARK_CHUNK_RESOLVED_CLASS;
        this.header.node.appendChild(button);
        this.addWidget(this.header);
        this.cells = new CellsDragDrop();
        this.addWidget(this.cells);
    }
    onResolve(event) {
        for (let cell of this.cells.widgets) {
            let model = cell.model;
            if (model.onesided && model.conflicted) {
                for (let d of model.decisions) {
                    d.conflict = false;
                }
            }
        }
        this.removeClass(CONFLICTED_CELL_CHUNK_CLASS);
        this.header.parent = null;
        this.header.dispose();
        this._resolved.emit(undefined);
    }
    dispose() {
        this.cells.parent = null;
        this.cells = null;
        if (this.header) {
            this.header.parent = null;
        }
        this.header = null;
        super.dispose();
    }
    get resolved() {
        return this._resolved;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/widget/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/widget/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CELLMERGE_CLASS: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.CELLMERGE_CLASS),
/* harmony export */   CellMergeWidget: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.CellMergeWidget),
/* harmony export */   MetadataMergeWidget: () => (/* reexport safe */ _metadata__WEBPACK_IMPORTED_MODULE_2__.MetadataMergeWidget),
/* harmony export */   NotebookMergeWidget: () => (/* reexport safe */ _notebook__WEBPACK_IMPORTED_MODULE_1__.NotebookMergeWidget)
/* harmony export */ });
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ "./node_modules/nbdime/lib/merge/widget/cell.js");
/* harmony import */ var _notebook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notebook */ "./node_modules/nbdime/lib/merge/widget/notebook.js");
/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metadata */ "./node_modules/nbdime/lib/merge/widget/metadata.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





/***/ }),

/***/ "./node_modules/nbdime/lib/merge/widget/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/widget/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MetadataMergeWidget: () => (/* binding */ MetadataMergeWidget)
/* harmony export */ });
/* harmony import */ var _common_mergeview__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/mergeview */ "./node_modules/nbdime/lib/common/mergeview.js");
/* harmony import */ var _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/collapsiblepanel */ "./node_modules/nbdime/lib/common/collapsiblepanel.js");
/* harmony import */ var _common_basepanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/basepanel */ "./node_modules/nbdime/lib/common/basepanel.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




const ROOT_METADATA_CLASS = 'jp-Metadata-merge';
/**
 * MetadataWidget for changes to Notebook-level metadata
 */
class MetadataMergeWidget extends _common_basepanel__WEBPACK_IMPORTED_MODULE_2__.MergePanel {
    constructor(options) {
        super(options);
        this.addClass(ROOT_METADATA_CLASS);
        this.init();
    }
    init() {
        const model = this._model;
        // We know/assume that MetadataMergeModel never has
        // null values for local/remote:
        const viewOptions = { ...this._viewOptions };
        const unchanged = model.decisions.length === 0;
        if (unchanged) {
            viewOptions.collapseIdentical = false;
        }
        this.view = (0,_common_mergeview__WEBPACK_IMPORTED_MODULE_0__.createNbdimeMergeView)({
            remote: model.remote,
            local: model.local,
            merged: model.merged,
            factory: this._editorFactory,
            translator: this._translator,
            ...viewOptions,
        });
        const trans = this._translator.load('nbdime');
        const wrapper = new _common_collapsiblepanel__WEBPACK_IMPORTED_MODULE_1__.CollapsiblePanel(this.view, unchanged ? trans.__('Notebook metadata unchanged') : trans.__('Notebook metadata changed'), true);
        this.addWidget(wrapper);
    }
    validateMerged(candidate) {
        const text = this.view.getMergedValue();
        if (JSON.stringify(candidate) !== text) {
            // This will need to be validated server side,
            // and should not be touched by client side
            // (structure might differ from assumed form)
            candidate = JSON.parse(text);
        }
        return candidate;
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/widget/notebook.js":
/*!**********************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/widget/notebook.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotebookMergeWidget: () => (/* binding */ NotebookMergeWidget)
/* harmony export */ });
/* harmony import */ var _common_basepanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/basepanel */ "./node_modules/nbdime/lib/common/basepanel.js");
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../upstreaming/flexpanel */ "./node_modules/nbdime/lib/upstreaming/flexpanel.js");
/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metadata */ "./node_modules/nbdime/lib/merge/widget/metadata.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cell */ "./node_modules/nbdime/lib/merge/widget/cell.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/merge/widget/common.js");
/* harmony import */ var _dragdrop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dragdrop */ "./node_modules/nbdime/lib/merge/widget/dragdrop.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








const NBMERGE_CLASS = 'jp-Notebook-merge';
const NB_MERGE_CONTROLS_CLASS = 'jp-Merge-notebook-controls';
/**
 * NotebookMergeWidget
 */
class NotebookMergeWidget extends _common_basepanel__WEBPACK_IMPORTED_MODULE_0__.MergePanel {
    constructor({ rendermime, ...options }) {
        super(options);
        this.metadataWidget = null;
        this._rendermime = rendermime;
        this.addClass(NBMERGE_CLASS);
    }
    /**
     * Start adding sub-widgets.
     *
     * Separated from constructor to allow 'live' adding of widgets
     */
    init() {
        let model = this._model;
        let rendermime = this._rendermime;
        let work = Promise.resolve();
        this.addWidget(new NotebookMergeControls({ model, translator: this._translator }));
        work = work.then(() => {
            if (model.metadata) {
                this.metadataWidget = new _metadata__WEBPACK_IMPORTED_MODULE_3__.MetadataMergeWidget({
                    model: model.metadata,
                    editorFactory: this._editorFactory,
                    translator: this._translator,
                    ...this._viewOptions,
                });
                this.addWidget(this.metadataWidget);
            }
        });
        work = work.then(() => {
            this.cellContainer = new _dragdrop__WEBPACK_IMPORTED_MODULE_6__.CellsDragDrop({
                acceptDropsFromExternalSource: true,
            });
            this.cellContainer.setFriendlyGroup(_dragdrop__WEBPACK_IMPORTED_MODULE_6__.CellsDragDrop.makeGroup());
            this.cellContainer.moved.connect(this.onDragDropMove, this);
            this.addWidget(this.cellContainer);
        });
        this.cellWidgets = [];
        let chunk = null;
        for (let c of model.cells) {
            work = work.then(() => {
                return new Promise(resolve => {
                    let w = new _cell__WEBPACK_IMPORTED_MODULE_4__.CellMergeWidget({
                        model: c,
                        rendermime,
                        mimetype: model.mimetype,
                        editorFactory: this._editorFactory,
                        translator: this._translator,
                        ...this._viewOptions,
                    });
                    this.cellWidgets.push(w);
                    if (c.onesided && c.conflicted) {
                        if (chunk === null) {
                            chunk = new _dragdrop__WEBPACK_IMPORTED_MODULE_6__.ChunkedCellsWidget({ translator: this._translator });
                            chunk.cells.moved.connect(this.onDragDropMove, this);
                            chunk.resolved.connect(this.onChunkResolved, this);
                            this.cellContainer.addToFriendlyGroup(chunk.cells);
                        }
                        chunk.cells.addWidget(w);
                    }
                    else {
                        if (chunk !== null) {
                            this.cellContainer.addWidget(chunk);
                            chunk = null;
                        }
                        this.cellContainer.addWidget(w);
                    }
                    // This limits us to drawing 60 cells per second, which shouldn't
                    // be a problem...
                    requestAnimationFrame(() => {
                        resolve();
                    });
                });
            });
        }
        work = work.then(() => {
            if (chunk !== null) {
                this.cellContainer.addWidget(chunk);
            }
        });
        return work;
    }
    validateMerged(candidate) {
        let validated = (0,_common_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(candidate);
        // Validate metadata
        if (this.metadataWidget) {
            validated.metadata = this.metadataWidget.validateMerged(candidate.metadata);
        }
        // Validate cells
        let i = 0;
        for (let c of this.cellWidgets) {
            if (!c.model.deleteCell) {
                validated.cells[i] = c.validateMerged(candidate.cells[i]);
                ++i;
            }
        }
        return validated;
    }
    /**
     * Get the model for the widget.
     *
     * #### Notes
     * This is a read-only property.
     */
    get model() {
        return this._model;
    }
    onDragDropMove(sender, args) {
        // Move cell in model list
        let { widget, oldParent, before, after } = args;
        let from = this._model.cells.indexOf(widget.model);
        let to;
        if (after) {
            to = this._model.cells.indexOf(after.model);
        }
        else if (before) {
            to = this._model.cells.indexOf(before.model) + 1;
        }
        else {
            throw new Error('Need either before or after');
        }
        if (to > from) {
            to -= 1;
        }
        this._model.cells.splice(to, 0, this._model.cells.splice(from, 1)[0]);
        if (oldParent.widgets.length === 0) {
            let chunk = oldParent.parent;
            chunk.onResolve();
        }
        // Mark any conflict on a cell moved from chunk as resolved
        if (oldParent !== this.cellContainer &&
            widget.parent === this.cellContainer) {
            for (let d of widget.model.decisions) {
                d.conflict = false;
            }
        }
    }
    onChunkResolved(sender, args) {
        let index = this.cellContainer.widgets.indexOf(sender);
        while (sender.cells.widgets.length > 0) {
            this.cellContainer.insertWidget(index++, sender.cells.widgets[0]);
        }
        sender.parent = null;
        sender.dispose();
    }
}
/**
 * Collection of notebook-wide controls
 */
class NotebookMergeControls extends _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_2__.FlexPanel {
    constructor({ model, translator, }) {
        super({
            direction: 'left-to-right',
        });
        this.model = model;
        this.trans = translator.load('nbdime');
        this.addClass(NB_MERGE_CONTROLS_CLASS);
        let anyOutputs = false;
        for (let cell of model.cells) {
            if ((0,_common_util__WEBPACK_IMPORTED_MODULE_1__.hasEntries)(cell.merged.outputs)) {
                anyOutputs = true;
                break;
            }
        }
        if (anyOutputs) {
            this.init_controls();
        }
    }
    init_controls() {
        // Add "Clear all outputs" checkbox
        let chk = (0,_common__WEBPACK_IMPORTED_MODULE_5__.createCheckbox)(false, this.trans.__('Clear all cell outputs'));
        this.clearOutputsToggle = chk.checkbox;
        this.addWidget(chk.widget);
        // Add "Clear all conflicted outputs" checkbox
        chk = (0,_common__WEBPACK_IMPORTED_MODULE_5__.createCheckbox)(false, this.trans.__('Clear conflicted cell outputs'));
        this.clearConflictedOutputsToggle = chk.checkbox;
        this.addWidget(chk.widget);
        this.updateOutputsToggles();
        this.connectOutputsToggles();
    }
    connectOutputsToggles() {
        for (let cell of this.model.cells) {
            if ((0,_common_util__WEBPACK_IMPORTED_MODULE_1__.hasEntries)(cell.merged.outputs)) {
                cell.clearOutputsChanged.connect(this.updateOutputsToggles, this);
            }
        }
        this.clearOutputsToggle.addEventListener('change', this);
        this.clearConflictedOutputsToggle.addEventListener('change', this);
    }
    disconnectOutputsToggles() {
        for (let cell of this.model.cells) {
            if ((0,_common_util__WEBPACK_IMPORTED_MODULE_1__.hasEntries)(cell.merged.outputs)) {
                cell.clearOutputsChanged.disconnect(this.updateOutputsToggles, this);
            }
        }
        this.clearOutputsToggle.removeEventListener('change', this);
        this.clearConflictedOutputsToggle.removeEventListener('change', this);
    }
    handleEvent(event) {
        switch (event.type) {
            case 'change':
                if (event.currentTarget === this.clearOutputsToggle) {
                    this.onClearAllOutputsChanged();
                }
                else if (event.currentTarget === this.clearConflictedOutputsToggle) {
                    this.onClearConflictedOutputsChanged();
                }
                break;
            default:
                break;
        }
    }
    onClearAllOutputsChanged() {
        this.disconnectOutputsToggles();
        try {
            let value = this.clearOutputsToggle.checked;
            for (let cell of this.model.cells) {
                if ((0,_common_util__WEBPACK_IMPORTED_MODULE_1__.hasEntries)(cell.merged.outputs)) {
                    cell.clearOutputs = value;
                }
            }
        }
        finally {
            this.updateOutputsToggles();
            this.connectOutputsToggles();
        }
    }
    onClearConflictedOutputsChanged() {
        this.disconnectOutputsToggles();
        try {
            let value = this.clearConflictedOutputsToggle.checked;
            for (let cell of this.model.cells) {
                if ((0,_common_util__WEBPACK_IMPORTED_MODULE_1__.hasEntries)(cell.merged.outputs) && cell.outputsConflicted) {
                    cell.clearOutputs = value;
                }
            }
        }
        finally {
            this.updateOutputsToggles();
            this.connectOutputsToggles();
        }
    }
    updateOutputsToggles() {
        // null = indeterminate
        let all = undefined;
        let conflicted = undefined;
        for (let cell of this.model.cells) {
            if ((0,_common_util__WEBPACK_IMPORTED_MODULE_1__.hasEntries)(cell.merged.outputs)) {
                let current = cell.clearOutputs;
                if (all === null) {
                    // Indeterminate, current value won't change it
                }
                else if (all === undefined) {
                    all = current;
                }
                else if (all !== current) {
                    all = null;
                }
                if (cell.outputsConflicted) {
                    if (conflicted === null) {
                        // Indeterminate, current value won't change it
                    }
                    else if (conflicted === undefined) {
                        conflicted = current;
                    }
                    else if (conflicted !== current) {
                        conflicted = null;
                    }
                }
            }
            if (conflicted === null && all === null) {
                // Both indeterminate, short circuit
                break;
            }
        }
        this.clearOutputsToggle.checked = all === true;
        this.clearOutputsToggle.indeterminate = all === null;
        this.clearConflictedOutputsToggle.checked = conflicted === true;
        this.clearConflictedOutputsToggle.indeterminate = conflicted === null;
        this.clearConflictedOutputsToggle.disabled = conflicted === undefined;
        if (conflicted === undefined) {
            this.clearConflictedOutputsToggle.parentElement.setAttribute('disabled', '');
        }
        else {
            this.clearConflictedOutputsToggle.parentElement.removeAttribute('disabled');
        }
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/merge/widget/output.js":
/*!********************************************************!*\
  !*** ./node_modules/nbdime/lib/merge/widget/output.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderableOutputsMergeView: () => (/* binding */ RenderableOutputsMergeView),
/* harmony export */   ReorderableOutputModel: () => (/* binding */ ReorderableOutputModel),
/* harmony export */   ReorderableOutputWidget: () => (/* binding */ ReorderableOutputWidget)
/* harmony export */ });
/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/outputarea */ "webpack/sharing/consume/default/@jupyterlab/outputarea");
/* harmony import */ var _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_dragpanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/dragpanel */ "./node_modules/nbdime/lib/common/dragpanel.js");
/* harmony import */ var _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../upstreaming/flexpanel */ "./node_modules/nbdime/lib/upstreaming/flexpanel.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





const REORDERABLE_OUTPUT_CLASS = 'jp-Merge-reorder-outputs';
const REORDERABLE_OUTPUT_DRAGIMAGE_CLASS = 'jp-Merge-dragimage-output';
const DELETE_DROP_ZONE_CLASS = 'jp-Merge-output-drop-delete';
/**
 * An OutputAreaModel which allows for reordering of its
 * outputs.
 */
class ReorderableOutputModel extends _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__.OutputAreaModel {
    insert(index, item) {
        // Note: We do not need worry about consolidating outputs
        // like the `add` method in parent class.
        this.list.insert(index, item);
    }
    move(fromIndex, toIndex) {
        // Note: We do not need worry about consolidating outputs
        // like the `add` method in parent class.
        this.list.move(fromIndex, toIndex);
    }
    remove(index) {
        return this.list.remove(index);
    }
}
/**
 * An OutputArea which supports the reordering
 * capabilities of ReorderableOutputModel
 */
class ReorderableOutputWidget extends _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__.OutputArea {
    /**
     * Follow changes on the model state.
     */
    onModelChanged(sender, args) {
        let layout = this.layout;
        switch (args.type) {
            case 'move':
                layout.insertWidget(args.newIndex, layout.widgets[args.oldIndex]);
                break;
            case 'remove':
                layout.removeWidgetAt(args.oldIndex);
                break;
            default:
                return super.onModelChanged(sender, args);
        }
    }
}
class DisconnectedDropTarget extends _common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.DropPanel {
    constructor() {
        super({ acceptDropsFromExternalSource: true });
        this.callback = null;
    }
    findDropTarget(input) {
        if (input === this.node || this.node.contains(input)) {
            return this.node;
        }
        return null;
    }
    processDrop(dropTarget, event) {
        if (this.callback) {
            this.callback(dropTarget, event);
        }
    }
}
/**
 * Widget for showing side by side comparison and picking of merge outputs
 */
class RenderableOutputsMergeView extends _common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.DragDropPanel {
    static makeOutputsDraggable(area) {
        for (const widget of area.layout) {
            _common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.DragPanel.makeHandle(widget);
        }
    }
    static get deleteDrop() {
        if (!RenderableOutputsMergeView._deleteDrop) {
            let widget = new DisconnectedDropTarget();
            widget.addClass(DELETE_DROP_ZONE_CLASS);
            let icon = document.createElement('i');
            icon.className = 'fa fa-lg fa-trash-o';
            icon.setAttribute('aria-hidden', 'true');
            widget.node.appendChild(icon);
            widget.node.style.position = 'absolute';
            RenderableOutputsMergeView._deleteDrop = widget;
        }
        return RenderableOutputsMergeView._deleteDrop;
    }
    /**
     *
     */
    constructor(merged, classes, rendermime, base, remote, local, showBase = true) {
        super();
        this.base = null;
        this.remote = null;
        this.local = null;
        this.showBase = showBase;
        this.addClass(REORDERABLE_OUTPUT_CLASS);
        if (!base !== !remote || !base !== !local) {
            // Assert that either none, or all of base/remote/local are given
            throw new Error('Renderable outputs merge-view either takes only merged output ' +
                'or a full set of four output lists.');
        }
        if (base) {
            this.base = new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__.OutputAreaModel();
            for (let output of base) {
                this.base.add(output);
            }
            this.remote = new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__.OutputAreaModel();
            for (let output of remote) {
                this.remote.add(output);
            }
            this.local = new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__.OutputAreaModel();
            for (let output of local) {
                this.local.add(output);
            }
        }
        this.merged = new ReorderableOutputModel();
        for (let output of merged) {
            this.merged.add(output);
        }
        this.rendermime = rendermime;
        this.panes = [];
        this.init(classes);
    }
    init(classes) {
        let row = new _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_3__.FlexPanel({ direction: 'left-to-right', evenSizes: true });
        if (this.local) {
            let leftPane = new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__.OutputArea({
                model: this.local,
                rendermime: this.rendermime,
            });
            leftPane.addClass(classes[1]);
            row.addWidget(leftPane);
            this.panes.push(leftPane);
        }
        if (this.base && this.showBase) {
            let basePane = new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__.OutputArea({
                model: this.base,
                rendermime: this.rendermime,
            });
            basePane.addClass(classes[0]);
            row.addWidget(basePane);
            this.panes.push(basePane);
        }
        if (this.remote) {
            let rightPane = new _jupyterlab_outputarea__WEBPACK_IMPORTED_MODULE_0__.OutputArea({
                model: this.remote,
                rendermime: this.rendermime,
            });
            rightPane.addClass(classes[2]);
            row.addWidget(rightPane);
            this.panes.push(rightPane);
        }
        if (row.widgets.length > 0) {
            this.addWidget(row);
            row = new _upstreaming_flexpanel__WEBPACK_IMPORTED_MODULE_3__.FlexPanel({ direction: 'left-to-right', evenSizes: true });
        }
        this.mergePane = new ReorderableOutputWidget({
            model: this.merged,
            rendermime: this.rendermime,
        });
        this.mergePane.addClass(classes[3]);
        row.addWidget(this.mergePane);
        this.panes.push(this.mergePane);
        this.addWidget(row);
        for (let p of this.panes) {
            RenderableOutputsMergeView.makeOutputsDraggable(p);
        }
    }
    /**
     * Overrided version to allow drag and drop from source lists to merged list
     */
    findDragTarget(handle) {
        // First check for a drag handle
        if (handle === null) {
            return null;
        }
        // Next find out which pane it belongs to, and which output it belongs to
        for (let pane of this.panes) {
            let child = (0,_common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.findChild)(pane.node, handle);
            if (child !== null) {
                return child;
            }
        }
        return null;
    }
    getIndexOfChildNode(node, parent) {
        for (let pane of this.panes) {
            let child = (0,_common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.findChild)(pane.node, node);
            if (child !== null) {
                let paneIndex = this.panes.indexOf(pane);
                return [
                    paneIndex,
                    super.getIndexOfChildNode(child, pane.layout),
                ];
            }
        }
        return null;
    }
    /**
     * Called when something has been dropped in the panel.
     *
     * As only internal moves are supported, we know the type of the keys
     */
    move(from, to) {
        let paneFrom = from[0];
        let paneTo = to[0];
        if (this.panes[paneTo] !== this.mergePane) {
            // Shouldn't happen if drop target code is correct...
            return;
        }
        let outputFrom = from[1];
        let outputTo = to[1];
        let adjustedTo = outputTo;
        if (paneFrom === paneTo) {
            if (outputTo > outputFrom) {
                // Have to adjust index for insertWidget in same instance
                adjustedTo -= 1;
                to[1] = adjustedTo;
            }
            else if (outputFrom === outputTo) {
                // No-op, same position
                return;
            }
        }
        let toModel = this.mergePane.model;
        let fromModel = this.panes[paneFrom].model;
        if (paneTo !== paneFrom) {
            toModel.insert(adjustedTo, fromModel.get(outputFrom));
        }
        else {
            toModel.move(outputFrom, adjustedTo);
        }
        RenderableOutputsMergeView.makeOutputsDraggable(this.mergePane);
    }
    /**
     * Find a drop target from a given node
     *
     * Returns null if no valid drop target was found.
     */
    findDropTarget(node) {
        if (node === this.mergePane.node && this.mergePane.model.length === 0) {
            // If empty, use pane as target
            return this.mergePane.node;
        }
        // Only valid drop target is in merge pane!
        return (0,_common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.findChild)(this.mergePane.node, node);
    }
    processDrop(dropTarget, event) {
        if (dropTarget === RenderableOutputsMergeView.deleteDrop.node) {
            // Simply remove output
            let [paneIdx, outputIdx] = event.mimeData.getData(_common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.MIME_INDEX);
            if (this.panes[paneIdx] !== this.mergePane) {
                // Shouldn't happen if drop target code is correct...
                return;
            }
            this.mergePane.model.remove(outputIdx);
            // Event cleanup
            event.preventDefault();
            event.stopPropagation();
            event.dropAction = 'move';
        }
        else if (dropTarget === this.mergePane.node &&
            this.mergePane.model.length === 0) {
            // Dropping on empty merge pane
            let sourceKey = event.mimeData.getData(_common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.MIME_INDEX);
            this.move(sourceKey, [this.panes.indexOf(this.mergePane), 0]);
            // Event cleanup
            event.preventDefault();
            event.stopPropagation();
            event.dropAction = 'copy';
        }
        else {
            super.processDrop(dropTarget, event);
        }
    }
    getDragImage(handle) {
        let target = this.findDragTarget(handle);
        if (target) {
            let image = target.cloneNode(true);
            image.style.width = target.offsetWidth.toString() + 'px';
            image.classList.add(REORDERABLE_OUTPUT_DRAGIMAGE_CLASS);
            return image;
        }
        return null;
    }
    startDrag(handle, clientX, clientY) {
        super.startDrag(handle, clientX, clientY);
        // After starting drag, show delete drop-zone ('trash')
        if ((0,_common_dragpanel__WEBPACK_IMPORTED_MODULE_2__.findChild)(this.mergePane.node, handle)) {
            let dd = RenderableOutputsMergeView.deleteDrop;
            dd.callback = this.processDrop.bind(this);
            // Calculate position and size:
            let ourRect = this.mergePane.node.getBoundingClientRect();
            dd.node.style.left = '0';
            dd.node.style.width =
                (ourRect.left + window.pageXOffset).toString() + 'px';
            dd.node.style.top = (ourRect.top + window.pageYOffset).toString() + 'px';
            dd.node.style.height = ourRect.height.toString() + 'px';
            // Attach to document
            _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget.attach(dd, document.body);
        }
    }
    onDragComplete(action) {
        super.onDragComplete(action);
        // After finishing drag, hide delete drop-zone ('trash')
        if (RenderableOutputsMergeView.deleteDrop.isAttached) {
            _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget.detach(RenderableOutputsMergeView.deleteDrop);
        }
    }
}
RenderableOutputsMergeView._deleteDrop = null;


/***/ }),

/***/ "./node_modules/nbdime/lib/patch/common.js":
/*!*************************************************!*\
  !*** ./node_modules/nbdime/lib/patch/common.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PatchObjectHelper: () => (/* binding */ PatchObjectHelper)
/* harmony export */ });
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class PatchObjectHelper {
    constructor(base, diff) {
        this._diffLUT = {};
        let diffKeys = [];
        if (diff) {
            for (let d of diff) {
                diffKeys.push(d.key);
                this._diffLUT[d.key] = d;
            }
        }
        this._diffKeys = diffKeys;
        this.baseKeys = _objectKeys(base);
    }
    keys() {
        this._remainingKeys = this.baseKeys
            .concat(this._diffKeys)
            .filter(_common_util__WEBPACK_IMPORTED_MODULE_0__.unique)
            .sort();
        const iterator = this;
        return {
            [Symbol.iterator]() {
                return iterator;
            },
        };
    }
    isDiffKey(key) {
        return (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(key, this._diffKeys);
    }
    getDiffEntry(key) {
        return this._diffLUT[key];
    }
    /**
     * Whether there any dict entries after the current add/remove diff op.
     *
     * Note that if the current op is a remove op, it does not take into
     * account any entries added below it. Similarly, if the current op is
     * an add op it does not take into account any entries that are
     * removed after it.
     *
     * Assumes current key is a diff key to either an add or remove op.
     * @returns {boolean}
     */
    entriesAfterCurrentAddRem() {
        if (this._currentIsAddition === undefined) {
            throw new Error('Current op is not an add or remove op');
        }
        // Check for unchanged entries after, or any changed entries
        // that are not of the OPPOSITE add/remove type:
        let oppositeOp = this._currentIsAddition ? 'remove' : 'add';
        for (let key of this._remainingKeys) {
            if (!(0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(key, this._diffKeys)) {
                // There remains unchanged entries after
                return true;
            }
            else if (this._diffLUT[key].op !== oppositeOp) {
                // There remains entries that should not be ignored
                return true;
            }
        }
        return false;
    }
    next() {
        let key = this._remainingKeys.shift();
        if (!key) {
            return {
                done: true,
                value: undefined,
            };
        }
        if (key && (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(key, this._diffKeys)) {
            let op = this._diffLUT[key].op;
            if (op === 'add') {
                this._currentIsAddition = true;
            }
            else if (op === 'remove') {
                this._currentIsAddition = false;
            }
            else {
                this._currentIsAddition = undefined;
            }
        }
        return { value: key, done: false };
    }
}
/**
 * The keys present in a Object class. Equivalent to Object.keys, but with a
 * fallback if not defined.
 */
let _objectKeys = Object.keys ||
    function (obj) {
        let has = Object.prototype.hasOwnProperty ||
            function () {
                return true;
            };
        let keys = [];
        for (let key in obj) {
            if (has.call(obj, key)) {
                keys.push(key);
            }
        }
        return keys;
    };


/***/ }),

/***/ "./node_modules/nbdime/lib/patch/generic.js":
/*!**************************************************!*\
  !*** ./node_modules/nbdime/lib/patch/generic.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   patch: () => (/* binding */ patch)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _diff_diffentries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../diff/diffentries */ "./node_modules/nbdime/lib/diff/diffentries.js");
/* harmony import */ var _stringified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringified */ "./node_modules/nbdime/lib/patch/stringified.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





function patch(base, diff) {
    if (typeof base === 'string') {
        return (0,_stringified__WEBPACK_IMPORTED_MODULE_3__.patchString)(base, diff, 0, false).remote;
    }
    else if (Array.isArray(base)) {
        const baseCopy = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(base);
        return patchSequence(baseCopy, diff);
    }
    else if (typeof base === 'number' || typeof base === 'boolean') {
        throw new TypeError('Cannot patch an atomic type: ' + typeof base);
    }
    else if (base === null) {
        throw new TypeError('Cannot patch a null base!');
    }
    else {
        const baseCopy = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(base);
        return patchObject(baseCopy, diff);
    }
}
/**
 * Patch an array according to the diff.
 */
function patchSequence(base, diff) {
    if (diff === null) {
        return (0,_common_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(base);
    }
    // The patched sequence to build and return
    let patched = [];
    // Index into obj, the next item to take unless diff says otherwise
    let take = 0;
    let skip = 0;
    for (let e of diff) {
        // Check for valid entry first:
        (0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_2__.validateSequenceOp)(base, e);
        let index = e.key;
        // Take values from base not mentioned in diff, up to not including
        // index
        for (let value of base.slice(take, index)) {
            patched.push((0,_common_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(value));
        }
        if (e.op === 'addrange') {
            // Extend with new values directly
            patched = patched.concat(e.valuelist);
            skip = 0;
        }
        else if (e.op === 'removerange') {
            // Delete a number of values by skipping
            skip = e.length;
        }
        else if (e.op === 'patch') {
            patched.push(patch(base[index], e.diff));
            skip = 1;
        }
        // Skip the specified number of elements, but never decrement take.
        // Note that take can pass index in diffs with repeated +/- on the
        // same index, i.e. [op_remove(index), op_add(index, value)]
        take = Math.max(take, index + skip);
    }
    // Take values at end not mentioned in diff
    for (let value of base.slice(take)) {
        patched.push((0,_common_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(value));
    }
    return patched;
}
/**
 * Patch an object (dictionary type) according to the diff.
 */
function patchObject(base, diff) {
    let patched = {};
    let keysToCopy = Object.keys(base);
    if (diff) {
        for (let e of diff) {
            // Check for valid entry first:
            (0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_2__.validateObjectOp)(base, e, keysToCopy);
            let key = e.key;
            if (e.op === 'add') {
                patched[key] = e.value;
            }
            else if (e.op === 'remove') {
                keysToCopy.splice(keysToCopy.indexOf(key), 1); // Remove key
            }
            else if (e.op === 'replace') {
                keysToCopy.splice(keysToCopy.indexOf(key), 1); // Remove key
                patched[key] = e.value;
            }
            else if (e.op === 'patch') {
                keysToCopy.splice(keysToCopy.indexOf(key), 1); // Remove key
                patched[key] = patch(base[key], e.diff);
            }
        }
    }
    // Take items not mentioned in diff
    for (let key of keysToCopy) {
        patched[key] = (0,_common_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(base[key]);
    }
    return patched;
}


/***/ }),

/***/ "./node_modules/nbdime/lib/patch/index.js":
/*!************************************************!*\
  !*** ./node_modules/nbdime/lib/patch/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PatchObjectHelper: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_0__.PatchObjectHelper),
/* harmony export */   patch: () => (/* reexport safe */ _generic__WEBPACK_IMPORTED_MODULE_1__.patch),
/* harmony export */   patchString: () => (/* reexport safe */ _stringified__WEBPACK_IMPORTED_MODULE_2__.patchString),
/* harmony export */   patchStringified: () => (/* reexport safe */ _stringified__WEBPACK_IMPORTED_MODULE_2__.patchStringified),
/* harmony export */   stringify: () => (/* reexport safe */ _stringified__WEBPACK_IMPORTED_MODULE_2__.stringify),
/* harmony export */   stringifyAndBlankNull: () => (/* reexport safe */ _stringified__WEBPACK_IMPORTED_MODULE_2__.stringifyAndBlankNull)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/patch/common.js");
/* harmony import */ var _generic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generic */ "./node_modules/nbdime/lib/patch/generic.js");
/* harmony import */ var _stringified__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringified */ "./node_modules/nbdime/lib/patch/stringified.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/***/ }),

/***/ "./node_modules/nbdime/lib/patch/stringified.js":
/*!******************************************************!*\
  !*** ./node_modules/nbdime/lib/patch/stringified.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   patchString: () => (/* binding */ patchString),
/* harmony export */   patchStringified: () => (/* binding */ patchStringified),
/* harmony export */   stringify: () => (/* binding */ stringify),
/* harmony export */   stringifyAndBlankNull: () => (/* binding */ stringifyAndBlankNull)
/* harmony export */ });
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util */ "./node_modules/nbdime/lib/common/util.js");
/* harmony import */ var _diff_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../diff/util */ "./node_modules/nbdime/lib/diff/util.js");
/* harmony import */ var _diff_diffentries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../diff/diffentries */ "./node_modules/nbdime/lib/diff/diffentries.js");
/* harmony import */ var _diff_range__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../diff/range */ "./node_modules/nbdime/lib/diff/range.js");
/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! json-stable-stringify */ "./node_modules/json-stable-stringify/index.js");
/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common */ "./node_modules/nbdime/lib/patch/common.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







/**
 * Ordered stringify. Wraps stableStringify(), but handles indentation.
 *
 * indentFirst controls whether the first line is indented as well, and
 * defaults to true.
 */
function stringify(values, level, indentFirst = true) {
    let ret = json_stable_stringify__WEBPACK_IMPORTED_MODULE_4___default()(values, { space: _diff_util__WEBPACK_IMPORTED_MODULE_1__.JSON_INDENT });
    if (level) {
        ret = _indent(ret, level, indentFirst);
    }
    return ret;
}
/**
 * Ensure value is string, if not stringify.
 */
function stringifyAndBlankNull(value) {
    if (typeof value === 'string') {
        return value;
    }
    else if (value === null) {
        return '';
    }
    else {
        return stringify(value);
    }
}
/**
 * Patch a stringified JSON object.
 *
 * Returns the stringified value of the patched JSON object, as well as
 * position ranges indicating which parts of the string that was added or
 * removed.
 *
 * Internally, this builds the ranges based on the actual supplied diff, which
 * can therefore differ from a straigh string-based diff of stringified JSON
 * objects.
 */
function patchStringified(base, diff, level) {
    if (level === undefined) {
        level = 0;
    }
    if (typeof base === 'string') {
        // Only stringify if level > 0
        let stringifyPatch = level > 0;
        return patchString(base, diff, level, stringifyPatch);
    }
    else if (Array.isArray(base)) {
        return patchStringifiedList(base, diff, level);
    }
    else if (typeof base === 'number' || typeof base === 'boolean') {
        throw new TypeError('Cannot patch an atomic type: ' + typeof base);
    }
    else if (base === null) {
        throw new TypeError('Cannot patch a null base!');
    }
    else {
        return patchStringifiedObject(base, diff, level);
    }
}
/**
 * Patch a string according to a line based diff
 */
function patchString(base, diff, level, stringifyPatch) {
    let additions = [];
    let deletions = [];
    let baseIndex = 0;
    // Short-circuit if diff is empty
    if (diff === null) {
        return {
            remote: stringifyPatch ? stringify(base, level) : base,
            additions: additions,
            deletions: deletions,
        };
    }
    // Diffs are line-based, so flatten to character based:
    diff = (0,_diff_util__WEBPACK_IMPORTED_MODULE_1__.flattenStringDiff)(base, diff);
    // Index into obj, the next item to take unless diff says otherwise
    let take = 0;
    let skip = 0;
    let remote = '';
    for (let e of diff) {
        let index = e.key;
        // Take values from obj not mentioned in diff, up to not including index
        let unchanged = base.slice(take, index);
        remote += unchanged;
        baseIndex += unchanged.length;
        if (e.op === 'addrange') {
            let added = e.valuelist;
            additions.push(new _diff_range__WEBPACK_IMPORTED_MODULE_3__.DiffRangeRaw(remote.length, added.length, e.source));
            remote += added;
            skip = 0;
        }
        else if (e.op === 'removerange') {
            // Delete a number of values by skipping
            skip = e.length;
            deletions.push(new _diff_range__WEBPACK_IMPORTED_MODULE_3__.DiffRangeRaw(baseIndex, skip, e.source));
            baseIndex += skip;
        }
        take = Math.max(take, index + skip);
    }
    remote += base.slice(take, base.length);
    if (stringifyPatch) {
        // The remote string should be stringified
        remote = stringify(remote, level);
        // Shift all indices by indentation + one to account for opening quote
        _offsetRanges(level * _diff_util__WEBPACK_IMPORTED_MODULE_1__.JSON_INDENT.length + 1, additions, deletions);
        // Offset ranges by JSON escaping
        _adjustRangesByJSONEscapes(remote, additions);
        _adjustRangesByJSONEscapes(stringify(base, level), deletions);
    }
    return { remote: remote, additions: additions, deletions: deletions };
}
/**
 * Patch a stringified object according to the object diff
 */
function patchStringifiedObject(base, diff, level) {
    let remote = '';
    let additions = [];
    let deletions = [];
    let postfix = ',\n';
    let baseIndex = 0;
    // Short-circuit if diff is empty
    if (diff === null) {
        return {
            remote: stringify(base, level),
            additions: additions,
            deletions: deletions,
        };
    }
    // Object is dict. As diff keys should be unique, create map for easy processing
    let helper = new _common__WEBPACK_IMPORTED_MODULE_5__.PatchObjectHelper(base, diff);
    let baseKeys = helper.baseKeys.slice();
    for (const key of helper.keys()) {
        let keyString = _makeKeyString(key, level + 1);
        if (helper.isDiffKey(key)) {
            // Entry has a change
            let e = helper.getDiffEntry(key);
            // Check for valid entry first:
            (0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_2__.validateObjectOp)(base, e, baseKeys);
            if ((0,_common_util__WEBPACK_IMPORTED_MODULE_0__.valueIn)(e.op, ['add', 'replace', 'remove'])) {
                // Replace is simply an add + remove, but without modifying keystring
                let isReplace = e.op === 'replace';
                if (e.op === 'add' || e.op === 'replace') {
                    let valr = stringify(e.value, level + 1, false) + postfix;
                    let start = remote.length;
                    let length = valr.length;
                    // Modify range depending on add or replace:
                    if (isReplace) {
                        start += keyString.length;
                    }
                    else {
                        length += keyString.length;
                    }
                    // Check if postfix should be included or not
                    if (isReplace || !helper.entriesAfterCurrentAddRem()) {
                        length -= postfix.length;
                        if (e.op === 'add') {
                            length += 1; // Newline will still be added
                        }
                    }
                    additions.push(new _diff_range__WEBPACK_IMPORTED_MODULE_3__.DiffRangeRaw(start, length, e.source));
                    remote += keyString + valr;
                }
                if (e.op === 'remove' || e.op === 'replace') {
                    let valb = stringify(base[key], level + 1, false) + postfix;
                    let start = baseIndex;
                    let length = valb.length;
                    // Modify range depending on remove or replace:
                    if (isReplace) {
                        start += keyString.length;
                    }
                    else {
                        length += keyString.length;
                    }
                    // Check if postfix should be included or not
                    if (isReplace || !helper.entriesAfterCurrentAddRem()) {
                        length -= postfix.length;
                        if (e.op === 'remove') {
                            length += 1; // Newline will still be removed
                        }
                    }
                    deletions.push(new _diff_range__WEBPACK_IMPORTED_MODULE_3__.DiffRangeRaw(start, length, e.source));
                    baseIndex += keyString.length + valb.length;
                    baseKeys.splice(baseKeys.indexOf(key), 1);
                }
            }
            else if (e.op === 'patch') {
                let pd = patchStringified(base[key], e.diff, level + 1);
                let valr = pd.remote;
                // Insert key string:
                valr =
                    keyString + valr.slice((level + 1) * _diff_util__WEBPACK_IMPORTED_MODULE_1__.JSON_INDENT.length) + postfix;
                let offset = remote.length + keyString.length - (level + 1) * _diff_util__WEBPACK_IMPORTED_MODULE_1__.JSON_INDENT.length;
                _offsetRanges(offset, pd.additions, pd.deletions);
                remote += valr;
                additions = additions.concat(pd.additions);
                deletions = deletions.concat(pd.deletions);
                baseIndex +=
                    stringify(base[key], level + 1, false).length +
                        keyString.length +
                        postfix.length;
                baseKeys.splice(baseKeys.indexOf(key), 1);
            }
        }
        else {
            // Entry unchanged
            let val = keyString + stringify(base[key], level + 1, false) + postfix;
            remote += val;
            baseIndex += val.length;
        }
    }
    // Stringify correctly
    if (remote.slice(remote.length - postfix.length) === postfix) {
        remote = remote.slice(0, remote.length - postfix.length);
    }
    let indent = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.repeatString)(_diff_util__WEBPACK_IMPORTED_MODULE_1__.JSON_INDENT, level);
    remote = indent + '{\n' + remote + '\n' + indent + '}';
    _offsetRanges(indent.length + 2, additions, deletions);
    return { remote: remote, additions: additions, deletions: deletions };
}
/**
 * Patch a stringified list according to the list diff
 */
function patchStringifiedList(base, diff, level) {
    let remote = '';
    let additions = [];
    let deletions = [];
    let baseIndex = 0; // Position in base string
    let postfix = ',\n';
    // Short-circuit if diff is empty
    if (diff === null) {
        return {
            remote: stringify(base, level),
            additions: additions,
            deletions: deletions,
        };
    }
    // Index into obj, the next item to take unless diff says otherwise
    let take = 0;
    let skip = 0;
    for (let e of diff) {
        // Check for valid entry first:
        (0,_diff_diffentries__WEBPACK_IMPORTED_MODULE_2__.validateSequenceOp)(base, e);
        let index = e.key;
        // Take values from obj not mentioned in diff, up to not including index
        for (; index > take; take++) {
            let unchanged = stringify(base[take], level + 1) + postfix;
            remote += unchanged;
            baseIndex += unchanged.length;
        }
        if (e.op === 'addrange') {
            // Extend with new values directly
            let val = '';
            for (let v of e.valuelist) {
                val += stringify(v, level + 1) + postfix;
            }
            let difflen = val.length;
            if (index === base.length) {
                difflen -= 1; // No comma if at end
            }
            additions.push(new _diff_range__WEBPACK_IMPORTED_MODULE_3__.DiffRangeRaw(remote.length, difflen, e.source));
            remote += val;
            skip = 0;
        }
        else if (e.op === 'removerange') {
            // Delete a number of values by skipping
            let val = '';
            let len = e.length;
            for (let i = index; i < index + len; i++) {
                val += stringify(base[i], level + 1) + postfix;
            }
            let difflen = val.length;
            if (len + index === base.length) {
                difflen -= 1; // No comma if at end
            }
            deletions.push(new _diff_range__WEBPACK_IMPORTED_MODULE_3__.DiffRangeRaw(baseIndex, difflen, e.source));
            baseIndex += val.length;
            skip = e.length;
        }
        else if (e.op === 'patch') {
            let pd = patchStringified(base[index], e.diff, level + 1);
            skip = 1;
            let val = pd.remote + postfix;
            _offsetRanges(remote.length, pd.additions, pd.deletions);
            additions = additions.concat(pd.additions);
            deletions = deletions.concat(pd.deletions);
            baseIndex += stringify(base[index], level + 1).length;
            remote += val;
        }
        // Skip the specified number of elements, but never decrement take.
        // Note that take can pass index in diffs with repeated +/- on the
        // same index, i.e. [op_remove(index), op_add(index, value)]
        take = Math.max(take, index + skip);
    }
    // Take unchanged values at end
    for (; base.length > take; take++) {
        remote += stringify(base[take], level + 1) + postfix;
    }
    // Stringify correctly
    if (remote.slice(remote.length - postfix.length) === postfix) {
        remote = remote.slice(0, remote.length - postfix.length);
    }
    let indent = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.repeatString)(_diff_util__WEBPACK_IMPORTED_MODULE_1__.JSON_INDENT, level);
    remote = indent + '[\n' + remote + '\n' + indent + ']';
    _offsetRanges(indent.length + 2, additions, deletions);
    return { remote: remote, additions: additions, deletions: deletions };
}
// Utility functions and variables:
/**
 * Indent a (multiline) string with `JSON_INDENT` given number of times.
 *
 * indentFirst controls whether the first line is indented as well.
 */
function _indent(str, levels, indentFirst) {
    indentFirst = indentFirst !== false;
    let lines = str.split('\n');
    let ret = new Array(lines.length);
    if (!indentFirst) {
        ret[0] = lines[0];
    }
    for (let i = indentFirst ? 0 : 1; i < lines.length; i++) {
        ret[i] = (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.repeatString)(_diff_util__WEBPACK_IMPORTED_MODULE_1__.JSON_INDENT, levels) + lines[i];
    }
    return ret.join('\n');
}
/** Make a string for a stringified dict key, with indentation */
function _makeKeyString(key, level) {
    return (0,_common_util__WEBPACK_IMPORTED_MODULE_0__.repeatString)(_diff_util__WEBPACK_IMPORTED_MODULE_1__.JSON_INDENT, level) + '"' + key + '": ';
}
/** Shift all positions in given ranges by same amount */
function _offsetRanges(offset, additions, deletions) {
    for (let a of additions) {
        a.offset(offset);
    }
    for (let d of deletions) {
        d.offset(offset);
    }
}
/**
 * Adjust diff ranges to compensate for increased length occupied by characters
 * escaped during JSON stringification.
 */
function _adjustRangesByJSONEscapes(jsonString, ranges) {
    // First find all escaped characters, and expansion coefficients
    let simpleEscapes = ['\\"', '\\\\', '\\/', '\\b', '\\f', '\\n', '\\r', '\\t'];
    let surrogateUnicodes = /\\uD[89A-Fa-f][0-9a-fA-F]{2}\\uD[c-fC-F][0-9a-fA-F]{2}/g;
    // Look for unicodes that are not part of a surrogate:
    let unicodes = /(?!\\uD[c-fC-F][0-9a-fA-F]{2})\\u(?!D[89A-Fa-f][0-9a-fA-F]{2})\d{4}/g;
    const SIMPLE_ESCAPE_LENGTH = 2;
    const UNICODE_ESCAPE_LENGTH = 6;
    const SURROGATE_ESCAPE_LENGTH = 12;
    // Equal sized arrays identifying location and expansion
    // factor of each escaped character:
    let indices = [];
    let expansions = [];
    for (let e of simpleEscapes) {
        let len = JSON.parse('"' + e + '"').length;
        let i = 0;
        while (1) {
            i = jsonString.indexOf(e, i);
            if (i < 0) {
                break;
            }
            indices.push(i);
            expansions.push(SIMPLE_ESCAPE_LENGTH - len);
            i++;
        }
    }
    let match;
    while ((match = unicodes.exec(jsonString)) !== null) {
        indices.push(match.index);
        expansions.push(UNICODE_ESCAPE_LENGTH - JSON.parse('"' + match[0] + '"').length);
    }
    while ((match = surrogateUnicodes.exec(jsonString)) !== null) {
        indices.push(match.index);
        expansions.push(SURROGATE_ESCAPE_LENGTH - JSON.parse('"' + match[0] + '"').length);
    }
    // Now adjust differences
    // TODO: Optimize this algorithm?
    for (let i = 0; i < indices.length; i++) {
        for (let r of ranges) {
            let idx = indices[i];
            let exp = expansions[i];
            if (r.from > idx) {
                r.from += exp;
            }
            if (r.to > idx) {
                r.to += exp;
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/nbdime/lib/upstreaming/flexlayout.js":
/*!***********************************************************!*\
  !*** ./node_modules/nbdime/lib/upstreaming/flexlayout.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FlexLayout: () => (/* binding */ FlexLayout)
/* harmony export */ });
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/messaging */ "webpack/sharing/consume/default/@lumino/messaging");
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_messaging__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/



/**
 * The class name added to left-to-right flex layout parents.
 */
const LEFT_TO_RIGHT_CLASS = 'lm-mod-left-to-right';
/**
 * The class name added to right-to-left flex layout parents.
 */
const RIGHT_TO_LEFT_CLASS = 'lm-mod-right-to-left';
/**
 * The class name added to top-to-bottom flex layout parents.
 */
const TOP_TO_BOTTOM_CLASS = 'lm-mod-top-to-bottom';
/**
 * The class name added to bottom-to-top flex layout parents.
 */
const BOTTOM_TO_TOP_CLASS = 'lm-mod-bottom-to-top';
/**
 * A layout which arranges its widgets in a single row or column.
 *
 * Use the direction attribute to specify the layout direction.
 *
 * The sizing and flow of the children can be specified in several ways:
 *  - The container level properties `minimumSpacing`,`wrap`,
 *    `justifyContent`, `alignItems` and `alignContent`.
 *  - The stretching of the children in the layout direction either by:
 *    - Setting individual values per widget of grow/shrink/basis by
 *      `setGrow`, `setShrink` and `setSizeBasis`.
 *    - Using the convenience attributes `evenSizes` or `stretchType`.
 *  - Manually by CSS using the flexbox CSS attribute for the classes
 *    `lm-FlexPanel` and `lm-FlexPanel-child`.
 */
class FlexLayout extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.PanelLayout {
    /**
     * Construct a new flex layout.
     *
     * @param options - The options for initializing the layout.
     */
    constructor(options = {}) {
        super();
        /**
         * Manage the display order of the widgets via the flexbox
         * attribute `order`, while keeping the internal DOM order
         * intact.
         */
        this.order = null;
        this._wrap = false;
        this._minimumSpacing = 4;
        this._justifyContent = null;
        this._alignItems = null;
        this._alignContent = null;
        this._dirty = false;
        this._direction = 'top-to-bottom';
        this._stretchType = null;
        this._evenSizes = false;
        if (options.direction !== void 0) {
            this._direction = options.direction;
        }
        if (options.minimumSpacing !== void 0) {
            this._minimumSpacing = Private.clampSpacing(options.minimumSpacing);
        }
        if (options.wrap !== void 0) {
            this._wrap = options.wrap;
        }
        if (options.justifyContent !== void 0) {
            this._justifyContent = options.justifyContent;
        }
        if (options.alignItems !== void 0) {
            this._alignItems = options.alignItems;
        }
        if (options.alignContent !== void 0) {
            this._alignContent = options.alignContent;
        }
        if (options.stretchType !== void 0) {
            this._stretchType = options.stretchType;
        }
        if (options.evenSizes !== void 0) {
            this._evenSizes = options.evenSizes;
        }
    }
    /**
     * Get the layout direction for the flex layout.
     */
    get direction() {
        return this._direction;
    }
    /**
     * Set the layout direction for the flex layout.
     */
    set direction(value) {
        if (this._direction === value) {
            return;
        }
        this._direction = value;
        if (!this.parent) {
            return;
        }
        Private.toggleDirection(this.parent, value);
        this.parent.fit();
    }
    /**
     * Get the minimum inter-element spacing for the flex layout.
     */
    get minimumSpacing() {
        return this._minimumSpacing;
    }
    /**
     * Set the minimum inter-element spacing for the flex layout.
     */
    set minimumSpacing(value) {
        value = Private.clampSpacing(value);
        if (this._minimumSpacing === value) {
            return;
        }
        this._minimumSpacing = value;
        if (!this.parent) {
            return;
        }
        this.parent.node.style.flexWrap = value ? 'wrap' : 'nowrap';
        this.parent.fit();
    }
    /**
     * Whether the layout should wrap its children if they do not all fit in
     * column/row.
     */
    get wrap() {
        return this._wrap;
    }
    set wrap(value) {
        if (this._wrap === value) {
            return;
        }
        this._wrap = value;
        if (!this.parent) {
            return;
        }
        this.parent.node.style.flexWrap = value ? 'wrap' : 'nowrap';
        this.parent.fit();
    }
    /**
     * Controls how to align children in the direction of the layout.
     */
    get justifyContent() {
        return this._justifyContent;
    }
    set justifyContent(value) {
        if (this._justifyContent === value) {
            return;
        }
        this._justifyContent = value;
        let flex = Private.translateFlexString(value);
        if (!this.parent) {
            return;
        }
        this.parent.node.style.justifyContent = flex;
        this.parent.fit();
    }
    /**
     * Controls how to align children in the direction perpendicular to that
     * of the layout (for a horizontal layout the will be the vertical align,
     * and vice-versa).
     */
    get alignItems() {
        return this._alignItems;
    }
    set alignItems(value) {
        if (this._alignItems === value) {
            return;
        }
        this._alignItems = value;
        let flex = Private.translateFlexString(value);
        if (!this.parent) {
            return;
        }
        this.parent.node.style.alignItems = flex;
        this.parent.fit();
    }
    /**
     * If layout is set to wrap, this defines how the wrapped lines will be
     * aligned in relation ro each other.
     */
    get alignContent() {
        return this._alignContent;
    }
    set alignContent(value) {
        if (this._alignContent === value) {
            return;
        }
        this._alignContent = value;
        let flex = Private.translateFlexString(value);
        if (!this.parent) {
            return;
        }
        this.parent.node.style.alignContent = flex;
        // Setting has no effect unless wrap is true, but
        // check against false to accomodate unset scenario
        // where CSS rules might apply:
        if (this._wrap !== false) {
            this.parent.fit();
        }
    }
    /**
     * Describe how to stretch items to fit into flex panel.
     */
    get stretchType() {
        return this._stretchType;
    }
    set stretchType(value) {
        if (this._stretchType === value) {
            return;
        }
        this._stretchType = value;
        if (!this.parent) {
            return;
        }
        this.parent.fit();
    }
    /**
     * If set, the free space is distributed such that the
     * children are all the same size. Defaults to `false`.
     *
     * ### Notes
     * Setting this to `true` will make the layout
     * ignore the setting of `stretchType`.
     */
    get evenSizes() {
        return this._evenSizes;
    }
    set evenSizes(value) {
        if (this._evenSizes === value) {
            return;
        }
        this._evenSizes = value;
        if (!this.parent) {
            return;
        }
        this.parent.fit();
    }
    /**
     * Determine whether direction is a horizontal one
     */
    isHorizontal() {
        return (this.direction === 'right-to-left' || this.direction === 'left-to-right');
    }
    /**
     * Determine whether direction is a vertical one
     */
    isVertical() {
        return !this.isHorizontal();
    }
    /**
     * Perform layout initialization which requires the parent widget.
     */
    init() {
        Private.toggleDirection(this.parent, this.direction);
        super.init();
    }
    /**
     * Attach a widget to the parent's DOM node.
     *
     * @param index - The current index of the widget in the layout.
     *
     * @param widget - The widget to attach to the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    attachWidget(index, widget) {
        // Call super implmentation
        super.attachWidget(index, widget);
        // Set order, if applicable
        if (this.order) {
            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this.order, index, widget);
        }
        // Post a layout request for the parent widget.
        this.parent.fit();
    }
    /**
     * Change a widget's display order.
     *
     * @param fromIndex - The previous index of the widget in the layout.
     *
     * @param toIndex - The current index of the widget in the layout.
     *
     * @param widget - The widget to move in the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    moveWidget(fromIndex, toIndex, widget) {
        if (fromIndex !== toIndex) {
            // Change the order of the widget.
            if (!this.order) {
                this.order = this.widgets.slice();
            }
            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this.order, fromIndex, toIndex);
            this._dirty = true;
        }
        // Post an update request for the parent widget.
        this.parent.update();
    }
    /**
     * Detach a widget from the parent's DOM node.
     *
     * @param index - The previous index of the widget in the layout.
     *
     * @param widget - The widget to detach from the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    detachWidget(index, widget) {
        // Remove widget from order vector
        if (this.order) {
            let i = 0;
            for (; i < this.order.length; ++i) {
                if (widget === this.order[i]) {
                    _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this.order, i);
                    break;
                }
            }
        }
        // Call super implmentation
        super.detachWidget(index, widget);
        // Post a layout request for the parent widget.
        this.parent.fit();
    }
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    onAfterShow(msg) {
        super.onAfterShow(msg);
        this.parent.update();
    }
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        Private.toggleDirection(this.parent, this._direction);
        let style = this.parent.node.style;
        style.flexWrap = this._wrap ? 'wrap' : 'nowrap';
        style.justifyContent =
            Private.translateFlexString(this._justifyContent) || '';
        style.alignContent = Private.translateFlexString(this._alignContent) || '';
        style.alignItems = Private.translateFlexString(this._alignItems) || '';
        this.parent.fit();
    }
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    onChildShown(msg) {
        this.parent.fit();
    }
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    onChildHidden(msg) {
        this.parent.fit();
    }
    /**
     * A message handler invoked on a `'resize'` message.
     */
    onResize(msg) {
        if (this.parent.isVisible) {
            this._update();
        }
    }
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    onUpdateRequest(msg) {
        if (this.parent.isVisible) {
            this._update();
        }
    }
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    onFitRequest(msg) {
        if (this.parent.isAttached) {
            this._fit();
        }
    }
    /**
     * Fit the layout to the total size required by the widgets.
     */
    _fit() {
        // Set the dirty flag to ensure only a single update occurs.
        this._dirty = true;
        // Notify the ancestor that it should fit immediately. This may
        // cause a resize of the parent, fulfilling the required update.
        let ancestor = this.parent.parent;
        if (ancestor) {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_1__.MessageLoop.sendMessage(ancestor, _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget.Msg.FitRequest);
        }
        // If the dirty flag is still set, the parent was not resized.
        // Trigger the required update on the parent widget immediately.
        if (this._dirty) {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_1__.MessageLoop.sendMessage(this.parent, _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget.Msg.UpdateRequest);
        }
    }
    /**
     * Update the layout position and size of the widgets.
     *
     * The parent offset dimensions should be `-1` if unknown.
     */
    _update() {
        // Clear the dirty flag to indicate the update occurred.
        this._dirty = false;
        // Bail early if there are no widgets to layout.
        let widgets = this.order || this.widgets;
        if (widgets.length === 0) {
            return;
        }
        // Set spacing by margins
        let spacing = this.minimumSpacing.toString() + 'px';
        if (this.isHorizontal()) {
            for (let i = 0; i < widgets.length - 1; ++i) {
                widgets[i].node.style.marginRight = spacing;
            }
        }
        else {
            for (let i = 0; i < widgets.length - 1; ++i) {
                widgets[i].node.style.marginBottom = spacing;
            }
        }
        // Update stretch styles if set
        if (this._evenSizes || this.stretchType) {
            let basis = null;
            let grow = null;
            let shrink = null;
            if (this._evenSizes) {
                basis = 0;
                grow = 1;
            }
            else {
                switch (this._stretchType) {
                    case 'grow':
                        // Allow items to grow from default size
                        grow = 1;
                        shrink = 0;
                        break;
                    case 'shrink':
                        // Allow items to shrink from default size
                        grow = 0;
                        shrink = 1;
                        break;
                    case 'both':
                        // Both growing and shrinking is allowed.
                        grow = 1;
                        shrink = 1;
                        break;
                    case 'fixed':
                        // Disallow both growing and shrinking.
                        grow = 0;
                        shrink = 0;
                        break;
                    default:
                        throw new TypeError('Invalid stretch type: ' + this._stretchType);
                }
            }
            for (let i = 0; i < widgets.length; ++i) {
                let style = widgets[i].node.style;
                if (basis !== null) {
                    // Can only be 0, so no unit needed
                    style.flexBasis = basis.toString();
                }
                if (grow !== null) {
                    style.flexGrow = grow.toString();
                }
                if (shrink !== null) {
                    style.flexShrink = shrink.toString();
                }
            }
        }
        // Update display order
        for (let i = 0; i < widgets.length; ++i) {
            let widget = widgets[i];
            widget.node.style.order = this.order ? i.toString() : '';
        }
    }
}
/**
 * The namespace for the `FlexLayout` class statics.
 */
(function (FlexLayout) {
    /**
     * Get the flex-grow number of the widget
     */
    function getGrow(widget) {
        let value = widget.node.style.flexGrow;
        return value ? parseInt(value, 10) : null;
    }
    FlexLayout.getGrow = getGrow;
    /**
     * Set the flex-grow number of the widget
     */
    function setGrow(widget, value, fit = true) {
        widget.node.style.flexGrow = value === null ? '' : value.toString();
        if (fit && widget.parent) {
            widget.parent.fit();
        }
    }
    FlexLayout.setGrow = setGrow;
    /**
     * Get the flex-shrink number of the widget
     */
    function getShrink(widget) {
        let value = widget.node.style.flexShrink;
        return value ? parseInt(value, 10) : null;
    }
    FlexLayout.getShrink = getShrink;
    /**
     * Set the flex-shrink number of the widget
     */
    function setShrink(widget, value, fit = true) {
        widget.node.style.flexShrink = value === null ? '' : value.toString();
        if (fit && widget.parent) {
            widget.parent.fit();
        }
    }
    FlexLayout.setShrink = setShrink;
    /**
     * Get the size basis of the widget.
     */
    function getSizeBasis(widget) {
        let value = widget.node.style.flexBasis;
        if (value === 'auto') {
            return 'auto';
        }
        else {
            return value ? parseInt(value.replace('px', ''), 10) : null;
        }
    }
    FlexLayout.getSizeBasis = getSizeBasis;
    /**
     * Set the size basis of the widget.
     *
     * This is the value used for calculating how to distribute positive
     * (grow) or negatie (shrink) free space in a flex box. The value
     * `'auto'` uses the `width`/`height` field of the box as the basis.
     */
    function setSizeBasis(widget, value, fit = true) {
        if (value === 'auto') {
            widget.node.style.flexBasis = value;
        }
        else if (value === null) {
            widget.node.style.flexBasis = '';
        }
        else {
            widget.node.style.flexBasis = value.toString() + 'px';
        }
        if (fit && widget.parent) {
            widget.parent.fit();
        }
    }
    FlexLayout.setSizeBasis = setSizeBasis;
})(FlexLayout || (FlexLayout = {}));
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Test whether a direction has horizontal orientation.
     */
    function isHorizontal(dir) {
        return dir === 'left-to-right' || dir === 'right-to-left';
    }
    Private.isHorizontal = isHorizontal;
    function translateFlexString(value) {
        if (value === 'start' || value === 'end') {
            value = 'flex-' + value;
        }
        return value;
    }
    Private.translateFlexString = translateFlexString;
    /**
     * Toggle the CSS direction class for the given widget.
     */
    function toggleDirection(widget, dir) {
        widget.toggleClass(LEFT_TO_RIGHT_CLASS, dir === 'left-to-right');
        widget.toggleClass(RIGHT_TO_LEFT_CLASS, dir === 'right-to-left');
        widget.toggleClass(TOP_TO_BOTTOM_CLASS, dir === 'top-to-bottom');
        widget.toggleClass(BOTTOM_TO_TOP_CLASS, dir === 'bottom-to-top');
    }
    Private.toggleDirection = toggleDirection;
    /**
     * Clamp a spacing value to an integer >= 0.
     */
    function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
    }
    Private.clampSpacing = clampSpacing;
})(Private || (Private = {}));


/***/ }),

/***/ "./node_modules/nbdime/lib/upstreaming/flexpanel.js":
/*!**********************************************************!*\
  !*** ./node_modules/nbdime/lib/upstreaming/flexpanel.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FlexPanel: () => (/* binding */ FlexPanel)
/* harmony export */ });
/* harmony import */ var _flexlayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flexlayout */ "./node_modules/nbdime/lib/upstreaming/flexlayout.js");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);


/**
 * The class name added to FlexPanel instances.
 */
const FLEX_PANEL_CLASS = 'lm-FlexPanel';
/**
 * The class name added to a FlexPanel child.
 */
const CHILD_CLASS = 'lm-FlexPanel-child';
/**
 * A panel which arranges its widgets in a single row or column.
 *
 * Use the direction attribute to specify the layout direction.
 *
 * The sizing and flow of the children can be specified in several ways:
 *  - The container level properties `minimumSpacing`,`wrap`,
 *    `justifyContent`, `alignItems` and `alignContent`.
 *  - The stretching of the children in the layout direction either by:
 *    - Setting individual values per widget of grow/shrink/basis by
 *      `setGrow`, `setShrink` and `setSizeBasis`.
 *    - Using the convenience attributes `evenSizes` or `stretchType`.
 *  - Manually by CSS using the flexbox CSS attribute for the classes
 *    `lm-FlexPanel` and `lm-FlexPanel-child`.
 *
 * #### Notes
 * This class provides a convenience wrapper around a [[FlexLayout]].
 */
class FlexPanel extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Panel {
    /**
     * Construct a new flex panel.
     *
     * @param options - The options for initializing the flex panel.
     */
    constructor(options = {}) {
        super({ layout: Private.createLayout(options) });
        if (!options.layout) {
            if (options.minimumSpacing !== void 0) {
                this.minimumSpacing = options.minimumSpacing;
            }
            if (options.direction !== void 0) {
                this.direction = options.direction;
            }
        }
        this.addClass(FLEX_PANEL_CLASS);
    }
    /**
     * The layout direction for the flex panel.
     */
    get direction() {
        return this.layout.direction;
    }
    set direction(value) {
        this.layout.direction = value;
    }
    /**
     * The minimum inter-element spacing for the flex panel.
     */
    get minimumSpacing() {
        return this.layout.minimumSpacing;
    }
    set minimumSpacing(value) {
        this.layout.minimumSpacing = value;
    }
    /**
     * Whether the layout should wrap its children if they do not all fit in
     * column/row.
     */
    get wrap() {
        return this.layout.wrap;
    }
    set wrap(value) {
        this.layout.wrap = value;
    }
    /**
     * Controls how to align children in the direction of the layout.
     */
    get justifyContent() {
        return this.layout.justifyContent;
    }
    set justifyContent(value) {
        this.layout.justifyContent = value;
    }
    /**
     * Controls how to align children in the direction perpendicular to that
     * of the layout (for a horizontal layout the will be the vertical align,
     * and vice-versa).
     */
    get alignItems() {
        return this.layout.alignItems;
    }
    set alignItems(value) {
        this.layout.alignItems = value;
    }
    /**
     * If layout is set to wrap, this defines how the wrapped lines will be
     * aligned in relation ro each other.
     */
    get alignContent() {
        return this.layout.alignContent;
    }
    set alignContent(value) {
        this.layout.alignContent = value;
    }
    get layout() {
        return super.layout;
    }
    set layout(value) {
        super.layout = value;
    }
    /**
     * Describe how to stretch items to fit into flex panel.
     */
    get stretchType() {
        return this.layout.stretchType;
    }
    set stretchType(value) {
        this.layout.stretchType = value;
    }
    /**
     * If set, the free space is distributed such that the
     * children are all the same size. Defaults to `false`.
     *
     * ### Notes
     * Setting this to `true` will make the layout
     * ignore the setting of `stretchType`.
     */
    get evenSizes() {
        return this.layout.evenSizes;
    }
    set evenSizes(value) {
        this.layout.evenSizes = value;
    }
    /**
     * A message handler invoked on a `'child-added'` message.
     */
    onChildAdded(msg) {
        msg.child.addClass(CHILD_CLASS);
    }
    /**
     * A message handler invoked on a `'child-removed'` message.
     */
    onChildRemoved(msg) {
        msg.child.removeClass(CHILD_CLASS);
    }
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.fit();
    }
}
/**
 * The namespace for the `FlexPanel` class statics.
 */
(function (FlexPanel) {
    /**
     * Get the flex panel grow factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The flex panel grow factor for the widget.
     */
    function getGrow(widget) {
        return _flexlayout__WEBPACK_IMPORTED_MODULE_0__.FlexLayout.getGrow(widget);
    }
    FlexPanel.getGrow = getGrow;
    /**
     * Set the flex panel grow factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the grow factor.
     */
    function setGrow(widget, value) {
        _flexlayout__WEBPACK_IMPORTED_MODULE_0__.FlexLayout.setGrow(widget, value);
    }
    FlexPanel.setGrow = setGrow;
    /**
     * Get the flex panel shrink factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The flex panel shrink factor for the widget.
     */
    function getShrink(widget) {
        return _flexlayout__WEBPACK_IMPORTED_MODULE_0__.FlexLayout.getShrink(widget);
    }
    FlexPanel.getShrink = getShrink;
    /**
     * Set the flex panel shrink factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the shrink factor.
     */
    function setShrink(widget, value) {
        _flexlayout__WEBPACK_IMPORTED_MODULE_0__.FlexLayout.setShrink(widget, value);
    }
    FlexPanel.setShrink = setShrink;
    /**
     * Get the flex panel size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The flex panel size basis for the widget.
     */
    function getSizeBasis(widget) {
        return _flexlayout__WEBPACK_IMPORTED_MODULE_0__.FlexLayout.getSizeBasis(widget);
    }
    FlexPanel.getSizeBasis = getSizeBasis;
    /**
     * Set the flex panel size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the size basis.
     */
    function setSizeBasis(widget, value) {
        _flexlayout__WEBPACK_IMPORTED_MODULE_0__.FlexLayout.setSizeBasis(widget, value);
    }
    FlexPanel.setSizeBasis = setSizeBasis;
})(FlexPanel || (FlexPanel = {}));
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Create a flex layout for the given panel options.
     */
    function createLayout(options) {
        return options.layout || new _flexlayout__WEBPACK_IMPORTED_MODULE_0__.FlexLayout(options);
    }
    Private.createLayout = createLayout;
})(Private || (Private = {}));


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_mui_icons-material_Clear_js-node_modules_nbdime_lib_merge_widget_index_js.32b450aae13aa5a9a99e.js.map